"use strict";(globalThis.webpackChunk_ethdebug_format_web=globalThis.webpackChunk_ethdebug_format_web||[]).push([[5769],{79821(e,n,s){s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>g,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"implementation-guides/compiler/case-study-bug","title":"Case study: BUG compiler","description":"BUG is a small experimental language designed to demonstrate ethdebug/format","source":"@site/docs/implementation-guides/compiler/case-study-bug.mdx","sourceDirName":"implementation-guides/compiler","slug":"/implementation-guides/compiler/case-study-bug","permalink":"/format/pr-preview/pr-168/docs/implementation-guides/compiler/case-study-bug","draft":false,"unlisted":false,"editUrl":"https://github.com/ethdebug/format/tree/main/packages/web/docs/implementation-guides/compiler/case-study-bug.mdx","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"sidebar_label":"Case Study: BUG"},"sidebar":"docsSidebar","previous":{"title":"Compiler Guides","permalink":"/format/pr-preview/pr-168/docs/implementation-guides/compiler/"},"next":{"title":"Examples","permalink":"/format/pr-preview/pr-168/docs/examples/"}}');var i=s(31085),r=s(71184),o=s(87270);const a={sidebar_position:2,sidebar_label:"Case Study: BUG"},l="Case study: BUG compiler",c={},d=[{value:"BUG language overview",id:"bug-language-overview",level:2},{value:"Compilation pipeline",id:"compilation-pipeline",level:2},{value:"Debug information strategy",id:"debug-information-strategy",level:2},{value:"Key design decisions",id:"key-design-decisions",level:3},{value:"Type generation",id:"type-generation",level:2},{value:"Pointer generation",id:"pointer-generation",level:2},{value:"Storage variables",id:"storage-variables",level:3},{value:"Composite types",id:"composite-types",level:3},{value:"Dynamic arrays",id:"dynamic-arrays",level:3},{value:"Storage analysis",id:"storage-analysis",level:3},{value:"Program annotation",id:"program-annotation",level:2},{value:"Instruction context",id:"instruction-context",level:3},{value:"Program builder",id:"program-builder",level:3},{value:"Variable scoping",id:"variable-scoping",level:2},{value:"Testing strategy",id:"testing-strategy",level:2},{value:"Lessons learned",id:"lessons-learned",level:2},{value:"Start simple",id:"start-simple",level:3},{value:"Preserve information early",id:"preserve-information-early",level:3},{value:"Test visually",id:"test-visually",level:3},{value:"Handle edge cases gracefully",id:"handle-edge-cases-gracefully",level:3},{value:"Future work",id:"future-work",level:2},{value:"Resources",id:"resources",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"case-study-bug-compiler",children:"Case study: BUG compiler"})}),"\n",(0,i.jsxs)(n.p,{children:["BUG is a small experimental language designed to demonstrate ",(0,i.jsx)(n.strong,{children:"ethdebug/format"}),"\nintegration. This case study explains how BUG implements debug information\ngeneration, providing a reference for other compiler authors."]}),"\n",(0,i.jsx)(n.admonition,{title:"Try it yourself",type:"tip",children:(0,i.jsxs)(n.p,{children:["See the ",(0,i.jsx)(n.a,{href:"/docs/examples/bug-playground",children:"BUG Playground"})," to experiment with\nBUG and see its debug output."]})}),"\n",(0,i.jsx)(n.h2,{id:"bug-language-overview",children:"BUG language overview"}),"\n",(0,i.jsx)(n.p,{children:"BUG is a minimal smart contract language with:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Storage declarations"})," \u2014 Named variables with explicit slot positions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Elementary types"})," \u2014 ",(0,i.jsx)(n.code,{children:"uint256"}),", ",(0,i.jsx)(n.code,{children:"bool"}),", ",(0,i.jsx)(n.code,{children:"address"}),", etc."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Composite types"})," \u2014 Arrays, mappings, structs"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Control flow"})," \u2014 ",(0,i.jsx)(n.code,{children:"if"}),", ",(0,i.jsx)(n.code,{children:"while"}),", expressions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Two code sections"})," \u2014 ",(0,i.jsx)(n.code,{children:"create"})," (constructor) and ",(0,i.jsx)(n.code,{children:"code"})," (runtime)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"A simple BUG contract:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bug",children:"name Counter;\n\nstorage {\n  [0] count: uint256;\n  [1] threshold: uint256;\n}\n\ncreate {\n  count = 0;\n  threshold = 100;\n}\n\ncode {\n  count = count + 1;\n  if (count >= threshold) {\n    count = 0;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"compilation-pipeline",children:"Compilation pipeline"}),"\n",(0,i.jsx)(n.p,{children:"BUG uses a multi-stage compilation pipeline:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Source \u2192 AST \u2192 IR \u2192 EVM Bytecode\n           \u2193     \u2193       \u2193\n         Types  Debug   Program\n"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Parsing"})," \u2014 Source text to AST with source locations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type checking"})," \u2014 Validates types and collects type information"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"IR generation"})," \u2014 Converts AST to intermediate representation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"EVM code generation"})," \u2014 Produces final bytecode with debug annotations"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"debug-information-strategy",children:"Debug information strategy"}),"\n",(0,i.jsxs)(n.p,{children:["BUG generates ",(0,i.jsx)(n.strong,{children:"ethdebug/format"})," output alongside bytecode by:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Tracking source locations"})," through all compilation phases"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Preserving type information"})," from the type checker"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Computing storage layouts"})," during IR generation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Emitting program annotations"})," during code generation"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"key-design-decisions",children:"Key design decisions"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Type preservation"}),': BUG\'s IR types carry an "origin" field linking back to\nthe source-level type. This allows generating rich ',(0,i.jsx)(n.strong,{children:"ethdebug/format"})," type\ninformation even after type erasure in the IR."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Storage analysis"}),": During IR generation, BUG analyzes storage access\npatterns to determine variable locations. This analysis traces through\n",(0,i.jsx)(n.code,{children:"compute_slot"})," instructions to reconstruct the storage layout."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Program builder"}),": A dedicated ",(0,i.jsx)(n.code,{children:"ProgramBuilder"})," class accumulates\ninstructions with their contexts during code generation, then serializes the\ncomplete program annotation."]}),"\n",(0,i.jsx)(n.h2,{id:"type-generation",children:"Type generation"}),"\n",(0,i.jsxs)(n.p,{children:["BUG converts its type system to ",(0,i.jsx)(n.strong,{children:"ethdebug/format"})," types:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",metastring:'title="packages/bugc/src/irgen/debug/types.ts"',children:'export function convertBugType(bugType: BugType): Format.Type | undefined {\n  // Elementary types\n  if (BugType.isElementary(bugType)) {\n    return convertElementaryType(bugType);\n  }\n\n  // Array types\n  if (BugType.isArray(bugType)) {\n    const elementType = convertBugType(bugType.element);\n    return {\n      kind: "array",\n      contains: { type: elementType },\n      ...(bugType.size !== undefined && { length: bugType.size }),\n    };\n  }\n\n  // Mapping and struct types follow similar patterns...\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"The type conversion handles:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Elementary types"})," \u2014 Direct mapping (",(0,i.jsx)(n.code,{children:"uint256"})," \u2192 ",(0,i.jsx)(n.code,{children:'{kind: "uint", bits: 256}'}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Arrays"})," \u2014 Recursive conversion with optional length"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Mappings"})," \u2014 Key/value type conversion"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Structs"})," \u2014 Field-by-field conversion with names"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"pointer-generation",children:"Pointer generation"}),"\n",(0,i.jsx)(n.p,{children:"BUG generates pointers that describe how to locate variables at runtime."}),"\n",(0,i.jsx)(n.h3,{id:"storage-variables",children:"Storage variables"}),"\n",(0,i.jsx)(n.p,{children:"For simple storage variables, BUG generates direct slot pointers:"}),"\n",(0,i.jsx)(o.A,{schema:"pointer/region/storage",href:"/spec/pointer/region/location/storage",children:'{\n  "location": "storage",\n  "slot": 0\n}'}),"\n",(0,i.jsx)(n.h3,{id:"composite-types",children:"Composite types"}),"\n",(0,i.jsx)(n.p,{children:"For structs, BUG generates group pointers with field offsets:"}),"\n",(0,i.jsx)(o.A,{schema:"pointer/collection/group",href:"/spec/pointer/collection/group",title:"Struct fields",children:'{\n  "group": [\n    { "name": "field1", "location": "storage", "slot": 0 },\n    { "name": "field2", "location": "storage", "slot": 0, "offset": 16 }\n  ]\n}'}),"\n",(0,i.jsx)(n.h3,{id:"dynamic-arrays",children:"Dynamic arrays"}),"\n",(0,i.jsx)(n.p,{children:"For dynamic arrays, BUG generates pointers with keccak256 expressions:"}),"\n",(0,i.jsx)(o.A,{schema:"pointer/collection",href:"/spec/pointer/collection",title:"Dynamic array",children:'{\n  "group": [\n    { "name": "array-length", "location": "storage", "slot": 0 },\n    {\n      "list": {\n        "count": { "$read": "array-length" },\n        "each": "i",\n        "is": {\n          "name": "element",\n          "location": "storage",\n          "slot": { "$sum": [{ "$keccak256": [{ "$wordsized": 0 }] }, "i"] }\n        }\n      }\n    }\n  ]\n}'}),"\n",(0,i.jsx)(n.h3,{id:"storage-analysis",children:"Storage analysis"}),"\n",(0,i.jsxs)(n.p,{children:["BUG includes a storage analysis pass that traces ",(0,i.jsx)(n.code,{children:"compute_slot"})," instructions\nto reconstruct dynamic storage locations. This handles patterns like:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"compute_slot(mapping, baseSlot, key) \u2192 keccak256(key, slot)\ncompute_slot(array, baseSlot) \u2192 keccak256(slot)\ncompute_slot(field, baseSlot, offset) \u2192 slot + offset\n"})}),"\n",(0,i.jsx)(n.h2,{id:"program-annotation",children:"Program annotation"}),"\n",(0,i.jsx)(n.p,{children:"BUG emits program annotations that map bytecode to source context."}),"\n",(0,i.jsx)(n.h3,{id:"instruction-context",children:"Instruction context"}),"\n",(0,i.jsx)(n.p,{children:"Each bytecode instruction includes context with:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Source range"})," \u2014 Where in source this instruction originates"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Variables"})," \u2014 Variables in scope at this point"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Remarks"})," \u2014 Human-readable annotations"]}),"\n"]}),"\n",(0,i.jsx)(o.A,{schema:"program/instruction",href:"/spec/program/instruction",title:"Instruction with context",children:'{\n  "offset": "0x1a",\n  "operation": { "mnemonic": "SLOAD" },\n  "context": {\n    "gather": [\n      {\n        "code": {\n          "source": { "id": "main" },\n          "range": { "offset": 120, "length": 5 }\n        }\n      },\n      {\n        "variables": [\n          {\n            "identifier": "count",\n            "type": { "kind": "uint", "bits": 256 },\n            "pointer": { "location": "storage", "slot": 0 }\n          }\n        ]\n      }\n    ]\n  }\n}'}),"\n",(0,i.jsx)(n.h3,{id:"program-builder",children:"Program builder"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ProgramBuilder"})," class manages instruction accumulation:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",metastring:'title="Simplified pattern"',children:"class ProgramBuilder {\n  private instructions: Program.Instruction[] = [];\n\n  addInstruction(\n    offset: number,\n    operation: Program.Instruction.Operation,\n    context?: Program.Context,\n  ) {\n    this.instructions.push({ offset, operation, context });\n  }\n\n  build(): Program {\n    return {\n      instructions: this.instructions,\n    };\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"variable-scoping",children:"Variable scoping"}),"\n",(0,i.jsx)(n.p,{children:"BUG includes storage variables in the variables context for every instruction\nthat accesses them. This allows debuggers to inspect storage values at any\nexecution point."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",metastring:'title="packages/bugc/src/irgen/debug/variables.ts"',children:"export function collectVariablesWithLocations(\n  state: State,\n  sourceId: string,\n): VariableInfo[] {\n  const variables: VariableInfo[] = [];\n\n  // Storage variables have fixed slots\n  for (const storageDecl of state.module.storageDeclarations) {\n    const bugType = state.types.get(storageDecl.id);\n    const pointer = generateStoragePointer(storageDecl.slot, bugType);\n\n    variables.push({\n      identifier: storageDecl.name,\n      type: convertBugType(bugType),\n      pointer,\n      declaration: storageDecl.loc\n        ? {\n            source: { id: sourceId },\n            range: storageDecl.loc,\n          }\n        : undefined,\n    });\n  }\n\n  return variables;\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"testing-strategy",children:"Testing strategy"}),"\n",(0,i.jsx)(n.p,{children:"BUG tests debug output in several ways:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Unit tests"})," \u2014 Test individual conversion functions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Integration tests"})," \u2014 Compile programs and verify output structure"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Playground"})," \u2014 Visual verification of output (see BUG Playground)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Example test pattern:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'test("generates correct storage pointer", () => {\n  const source = `\n    name Test;\n    storage { [0] value: uint256; }\n    code { value = 42; }\n  `;\n\n  const result = compile({ to: "bytecode", source });\n  const program = result.value.program;\n\n  // Find the SLOAD instruction\n  const sload = program.instructions.find(\n    (i) => i.operation?.mnemonic === "SLOAD",\n  );\n\n  expect(sload.context).toMatchObject({\n    variables: [\n      {\n        identifier: "value",\n        pointer: { location: "storage", slot: 0 },\n      },\n    ],\n  });\n});\n'})}),"\n",(0,i.jsx)(n.h2,{id:"lessons-learned",children:"Lessons learned"}),"\n",(0,i.jsx)(n.h3,{id:"start-simple",children:"Start simple"}),"\n",(0,i.jsx)(n.p,{children:"BUG started with just storage variables and elementary types. Complex features\n(arrays, mappings, structs) were added incrementally after the basic\ninfrastructure was working."}),"\n",(0,i.jsx)(n.h3,{id:"preserve-information-early",children:"Preserve information early"}),"\n",(0,i.jsx)(n.p,{children:"Type information is easier to preserve than reconstruct. BUG's IR types carry\ntheir source-level origin, which simplifies later conversion."}),"\n",(0,i.jsx)(n.h3,{id:"test-visually",children:"Test visually"}),"\n",(0,i.jsx)(n.p,{children:"The BUG Playground proved invaluable for debugging the debug output. Being able\nto see the generated annotations alongside bytecode helped catch issues that\nunit tests missed."}),"\n",(0,i.jsx)(n.h3,{id:"handle-edge-cases-gracefully",children:"Handle edge cases gracefully"}),"\n",(0,i.jsx)(n.p,{children:"When storage analysis can't determine a location (e.g., computed slot from\na non-constant), BUG still generates useful partial information rather than\nfailing entirely."}),"\n",(0,i.jsx)(n.h2,{id:"future-work",children:"Future work"}),"\n",(0,i.jsx)(n.p,{children:"Areas for improvement in BUG's debug support:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Memory tracking"})," \u2014 Track memory allocations for local variable pointers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Stack variables"})," \u2014 Generate stack pointers during code generation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Richer contexts"})," \u2014 Add frame information for function calls"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Source maps"})," \u2014 More granular source location tracking"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/examples/bug-playground",children:"BUG Playground"})," \u2014 Interactive compiler demo"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/ethdebug/format/tree/main/packages/bugc",children:"BUG Source Code"})," \u2014 Implementation reference"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/spec/overview",children:"ethdebug/format Specification"})," \u2014 Format reference"]}),"\n"]})]})}function g(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},87270(e,n,s){s.d(n,{A:()=>u});s(14041);var t=s(40665),i=s(54034),r=s.n(i);const o="container_eo8G",a="header_CGit",l="title_NhXp",c="schemaLink_R3qF",d="schemaName_hPpq",h="schemaLabel_TlZH";var g=s(31085);function u({schema:e,href:n,children:s,title:i}){const u="string"==typeof s?s:JSON.stringify(s,null,2),p=e.startsWith("ethdebug/format/")?e:`ethdebug/format/${e}`;return(0,g.jsxs)("div",{className:o,children:[(0,g.jsxs)("div",{className:a,children:[i&&(0,g.jsx)("span",{className:l,children:i}),(0,g.jsxs)(t.A,{to:n,className:c,children:[(0,g.jsx)("span",{className:h,children:"Schema:"}),(0,g.jsx)("span",{className:d,children:p})]})]}),(0,g.jsx)(r(),{language:"json",children:u})]})}}}]);