"use strict";(globalThis.webpackChunk_ethdebug_format_web=globalThis.webpackChunk_ethdebug_format_web||[]).push([[974],{9129(e,n,s){s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"concepts/index","title":"Concepts","description":"This section introduces the core concepts behind ethdebug/format. Understanding","source":"@site/docs/concepts/index.mdx","sourceDirName":"concepts","slug":"/concepts/","permalink":"/format/pr-preview/pr-168/docs/concepts/","draft":false,"unlisted":false,"editUrl":"https://github.com/ethdebug/format/tree/main/packages/web/docs/concepts/index.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"sidebar_label":"Overview"},"sidebar":"docsSidebar","previous":{"title":"For compiler authors","permalink":"/format/pr-preview/pr-168/docs/getting-started/for-compiler-authors"},"next":{"title":"Data locations","permalink":"/format/pr-preview/pr-168/docs/concepts/data-locations"}}');var i=s(31085),t=s(71184);const o={sidebar_position:1,sidebar_label:"Overview"},c="Concepts",d={},l=[{value:"The main components",id:"the-main-components",level:2},{value:"Types",id:"types",level:3},{value:"Pointers",id:"pointers",level:3},{value:"Programs",id:"programs",level:3},{value:"How they work together",id:"how-they-work-together",level:2},{value:"Next steps",id:"next-steps",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"concepts",children:"Concepts"})}),"\n",(0,i.jsx)(n.p,{children:"This section introduces the core concepts behind ethdebug/format. Understanding\nthese mental models will help you work with the format effectively, whether\nyou're consuming it in a debugger or producing it from a compiler."}),"\n",(0,i.jsx)(n.h2,{id:"the-main-components",children:"The main components"}),"\n",(0,i.jsx)(n.p,{children:"ethdebug/format consists of three main kinds of information:"}),"\n",(0,i.jsx)(n.h3,{id:"types",children:"Types"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Types"})," describe what kind of data you're looking at. They tell a debugger\nhow to interpret raw bytes as meaningful values."]}),"\n",(0,i.jsx)(n.p,{children:"For example, the same 32 bytes could be:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.code,{children:"uint256"})," representing a token balance"]}),"\n",(0,i.jsxs)(n.li,{children:["An ",(0,i.jsx)(n.code,{children:"address"})," padded to 32 bytes"]}),"\n",(0,i.jsxs)(n.li,{children:["Part of a ",(0,i.jsx)(n.code,{children:"bytes"})," dynamic byte array"]}),"\n",(0,i.jsxs)(n.li,{children:["Two packed ",(0,i.jsx)(n.code,{children:"uint128"})," values"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Type definitions give debuggers the information they need to decode bytes\ncorrectly."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/types",children:"Learn more about types \u2192"})})}),"\n",(0,i.jsx)(n.h3,{id:"pointers",children:"Pointers"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pointers"})," describe where data lives. They're recipes for finding bytes in\nEVM state."]}),"\n",(0,i.jsx)(n.p,{children:"Simple pointers specify static locations:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'"Storage slot 0"'}),"\n",(0,i.jsx)(n.li,{children:'"Memory offset 0x80"'}),"\n",(0,i.jsx)(n.li,{children:'"Stack position 2"'}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Complex pointers describe dynamic locations:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:['"Storage slot ',(0,i.jsx)(n.code,{children:"keccak256(key, baseSlot)"}),'" for mapping values']}),"\n",(0,i.jsx)(n.li,{children:'"Memory at the offset stored in stack position 1" for dynamic references'}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Pointers can include expressions that compute locations based on runtime state."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/pointers",children:"Learn more about pointers \u2192"})})}),"\n",(0,i.jsx)(n.h3,{id:"programs",children:"Programs"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Programs"})," describe runtime context. They tell a debugger what's happening\nat each point in execution."]}),"\n",(0,i.jsx)(n.p,{children:"Programs answer questions like:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"What source code corresponds to this bytecode instruction?"}),"\n",(0,i.jsx)(n.li,{children:"What variables are in scope right now?"}),"\n",(0,i.jsx)(n.li,{children:"What function are we in?"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This information enables source-level debugging of optimized bytecode."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/programs",children:"Learn more about programs \u2192"})})}),"\n",(0,i.jsx)(n.h2,{id:"how-they-work-together",children:"How they work together"}),"\n",(0,i.jsx)(n.p,{children:"These components combine to enable rich debugging:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["A debugger reads ",(0,i.jsx)(n.strong,{children:"program"})," information to know which variables are in\nscope at the current instruction"]}),"\n",(0,i.jsxs)(n.li,{children:["Each variable has a ",(0,i.jsx)(n.strong,{children:"type"})," that describes its structure"]}),"\n",(0,i.jsxs)(n.li,{children:["Each variable has a ",(0,i.jsx)(n.strong,{children:"pointer"})," that describes where to find its value"]}),"\n",(0,i.jsx)(n.li,{children:"The debugger resolves the pointer against current EVM state to get raw bytes"}),"\n",(0,i.jsx)(n.li,{children:"The debugger decodes the bytes using the type definition"}),"\n",(0,i.jsx)(n.li,{children:"The user sees meaningful variable values"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/concepts/data-locations",children:"Data locations"})})," \u2014 Understand where data\ncan live in the EVM"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/types",children:"Types deep dive"})})," \u2014 Full documentation on type definitions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/pointers",children:"Pointers deep dive"})})," \u2014 Full documentation on pointer\ndefinitions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/programs",children:"Programs deep dive"})})," \u2014 Full documentation on program\nannotations"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}}}]);