"use strict";(globalThis.webpackChunk_ethdebug_format_web=globalThis.webpackChunk_ethdebug_format_web||[]).push([[3453],{98373(e,n,t){t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"types/representation","title":"Representation","description":"Types in ethdebug/format describe what data is, but compilers must also","source":"@site/docs/types/representation.mdx","sourceDirName":"types","slug":"/types/representation","permalink":"/format/pr-preview/pr-168/docs/types/representation","draft":false,"unlisted":false,"editUrl":"https://github.com/ethdebug/format/tree/main/packages/web/docs/types/representation.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"Composite types","permalink":"/format/pr-preview/pr-168/docs/types/composite"},"next":{"title":"Pointers","permalink":"/format/pr-preview/pr-168/docs/pointers/"}}');var i=t(31085),r=t(71184);const a={sidebar_position:4},o="Representation",d={},l=[{value:"Encoding contexts",id:"encoding-contexts",level:2},{value:"Storage encoding",id:"storage-encoding",level:3},{value:"Memory and calldata encoding",id:"memory-and-calldata-encoding",level:3},{value:"Why this matters for debugging",id:"why-this-matters-for-debugging",level:3},{value:"Byte ordering",id:"byte-ordering",level:2},{value:"Packed storage layout",id:"packed-storage-layout",level:2},{value:"Representing layout in pointers",id:"representing-layout-in-pointers",level:2},{value:"Dynamic data representation",id:"dynamic-data-representation",level:2},{value:"Dynamic arrays",id:"dynamic-arrays",level:3},{value:"Mappings",id:"mappings",level:3},{value:"Strings and bytes",id:"strings-and-bytes",level:3},{value:"Types don&#39;t encode layout",id:"types-dont-encode-layout",level:2},{value:"Learn more",id:"learn-more",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"representation",children:"Representation"})}),"\n",(0,i.jsxs)(n.p,{children:["Types in ethdebug/format describe ",(0,i.jsx)(n.em,{children:"what"})," data is, but compilers must also\nencode ",(0,i.jsx)(n.em,{children:"how"})," that data is stored as bytes. The same logical type can have\ndifferent byte representations depending on context."]}),"\n",(0,i.jsx)(n.h2,{id:"encoding-contexts",children:"Encoding contexts"}),"\n",(0,i.jsx)(n.p,{children:"The EVM uses different encoding rules depending on where data lives:"}),"\n",(0,i.jsx)(n.h3,{id:"storage-encoding",children:"Storage encoding"}),"\n",(0,i.jsx)(n.p,{children:"Storage packs values tightly to minimize slot usage. Multiple small values\nshare a single 32-byte slot:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Slot 0: |-------- uint128 a --------|-------- uint128 b --------|\n         16 bytes                    16 bytes\n"})}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"uint128"})," needs only 16 bytes, so two fit in one slot."]}),"\n",(0,i.jsx)(n.h3,{id:"memory-and-calldata-encoding",children:"Memory and calldata encoding"}),"\n",(0,i.jsx)(n.p,{children:"Memory and calldata use ABI encoding rules. Each value occupies a full 32-byte\nword, padded as needed:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Memory: |---------------- uint128 a (padded) ----------------|\n         32 bytes (16 bytes value + 16 bytes zero padding)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"why-this-matters-for-debugging",children:"Why this matters for debugging"}),"\n",(0,i.jsxs)(n.p,{children:["A debugger reading a ",(0,i.jsx)(n.code,{children:"uint128"})," needs to know:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"In storage: read 16 bytes from the correct offset within a slot"}),"\n",(0,i.jsx)(n.li,{children:"In memory: read 32 bytes, then interpret only the relevant portion"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The pointer specifies ",(0,i.jsx)(n.em,{children:"where"}),", the type specifies ",(0,i.jsx)(n.em,{children:"what"}),", and encoding context\ndetermines ",(0,i.jsx)(n.em,{children:"how"})," to interpret the bytes."]}),"\n",(0,i.jsx)(n.h2,{id:"byte-ordering",children:"Byte ordering"}),"\n",(0,i.jsx)(n.p,{children:"The EVM is big-endian for most purposes:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Integers"})," are stored with the most significant byte first"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Addresses"})," occupy 20 bytes, left-padded with zeros in 32-byte contexts"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fixed-size bytes"})," (",(0,i.jsx)(n.code,{children:"bytes1"})," through ",(0,i.jsx)(n.code,{children:"bytes32"}),") are right-padded"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["For a ",(0,i.jsx)(n.code,{children:"uint256"})," value of ",(0,i.jsx)(n.code,{children:"0x1234"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Storage/Memory: 0x0000...001234\n                ^           ^\n                MSB         LSB (rightmost)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"packed-storage-layout",children:"Packed storage layout"}),"\n",(0,i.jsx)(n.p,{children:"Solidity packs storage variables when possible. Consider this struct:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"struct Packed {\n    uint128 a;   // 16 bytes\n    uint64 b;    // 8 bytes\n    uint64 c;    // 8 bytes\n    uint256 d;   // 32 bytes (new slot)\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"The layout in storage:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Slot 0: | c (8 bytes) | b (8 bytes) | a (16 bytes) |\n        offset 24     offset 16      offset 0\n\nSlot 1: | d (32 bytes)                             |\n        offset 0\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Note that ",(0,i.jsx)(n.code,{children:"c"})," is stored at a higher offset than ",(0,i.jsx)(n.code,{children:"a"})," despite appearing later\nin the source. Solidity fills slots from low to high offsets, but struct\nfields are placed in declaration order within that constraint."]}),"\n",(0,i.jsx)(n.h2,{id:"representing-layout-in-pointers",children:"Representing layout in pointers"}),"\n",(0,i.jsx)(n.p,{children:"Pointers capture this layout using offsets within slots:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "group": [\n    {\n      "name": "a",\n      "location": "storage",\n      "slot": 0,\n      "offset": 0,\n      "length": 16\n    },\n    {\n      "name": "b",\n      "location": "storage",\n      "slot": 0,\n      "offset": 16,\n      "length": 8\n    },\n    {\n      "name": "c",\n      "location": "storage",\n      "slot": 0,\n      "offset": 24,\n      "length": 8\n    },\n    {\n      "name": "d",\n      "location": "storage",\n      "slot": 1,\n      "offset": 0,\n      "length": 32\n    }\n  ]\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"The type describes the struct's logical shape; the pointer describes its\nphysical layout."}),"\n",(0,i.jsx)(n.h2,{id:"dynamic-data-representation",children:"Dynamic data representation"}),"\n",(0,i.jsx)(n.p,{children:"Dynamic types (dynamic arrays, mappings, strings, bytes) store a fixed-size\ncomponent at their declared slot, with actual data elsewhere:"}),"\n",(0,i.jsx)(n.h3,{id:"dynamic-arrays",children:"Dynamic arrays"}),"\n",(0,i.jsxs)(n.p,{children:["The array's slot holds its length. Elements are stored starting at\n",(0,i.jsx)(n.code,{children:"keccak256(slot)"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Slot 5:              [length]\nSlot keccak256(5):   [element 0]\nSlot keccak256(5)+1: [element 1]\n...\n"})}),"\n",(0,i.jsx)(n.h3,{id:"mappings",children:"Mappings"}),"\n",(0,i.jsxs)(n.p,{children:["Mapping slots are empty. Values are stored at ",(0,i.jsx)(n.code,{children:"keccak256(key, slot)"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Slot 3:                         (unused)\nSlot keccak256(addr, 3):        [balances[addr]]\n"})}),"\n",(0,i.jsx)(n.h3,{id:"strings-and-bytes",children:"Strings and bytes"}),"\n",(0,i.jsxs)(n.p,{children:["Short strings (\u226431 bytes) store data and length in a single slot. Long strings\nstore length in the base slot and data starting at ",(0,i.jsx)(n.code,{children:"keccak256(slot)"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"types-dont-encode-layout",children:"Types don't encode layout"}),"\n",(0,i.jsx)(n.p,{children:"A key design principle: ethdebug/format types describe logical structure, not\nphysical layout. The same type definition works regardless of encoding context:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "kind": "struct",\n  "contains": [\n    { "name": "a", "type": { "kind": "uint", "bits": 128 } },\n    { "name": "b", "type": { "kind": "uint", "bits": 64 } }\n  ]\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This struct definition is the same whether ",(0,i.jsx)(n.code,{children:"a"})," and ",(0,i.jsx)(n.code,{children:"b"})," are packed in storage\nor padded in memory. The pointer tells the debugger where each field actually\nlives."]}),"\n",(0,i.jsx)(n.p,{children:"This separation lets compilers describe complex optimizations (reordering,\npacking, splitting across locations) without inventing new type constructs."}),"\n",(0,i.jsx)(n.h2,{id:"learn-more",children:"Learn more"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"../pointers/regions",children:"Regions documentation"})," for addressing within slots"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"../pointers/expressions",children:"Expressions documentation"})," for computing dynamic\nlocations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/spec/type",children:"Type specification"})," for formal type definitions"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);