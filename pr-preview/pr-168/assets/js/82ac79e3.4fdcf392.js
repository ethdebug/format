"use strict";(globalThis.webpackChunk_ethdebug_format_web=globalThis.webpackChunk_ethdebug_format_web||[]).push([[2157],{60439(e,s,n){n.r(s),n.d(s,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"types/index","title":"Types","description":"Types in ethdebug/format describe the structure and interpretation of raw","source":"@site/docs/types/index.mdx","sourceDirName":"types","slug":"/types/","permalink":"/format/pr-preview/pr-168/docs/types/","draft":false,"unlisted":false,"editUrl":"https://github.com/ethdebug/format/tree/main/packages/web/docs/types/index.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Data locations","permalink":"/format/pr-preview/pr-168/docs/concepts/data-locations"},"next":{"title":"Elementary types","permalink":"/format/pr-preview/pr-168/docs/types/elementary"}}');var d=n(31085),i=n(71184);const t={sidebar_position:1},c="Types",a={},l=[{value:"Why types matter",id:"why-types-matter",level:2},{value:"Core ideas",id:"core-ideas",level:2},{value:"Types are organized by kind",id:"types-are-organized-by-kind",level:3},{value:"Elementary vs. complex",id:"elementary-vs-complex",level:3},{value:"Complex types use <code>contains</code>",id:"complex-types-use-contains",level:3},{value:"Type references avoid duplication",id:"type-references-avoid-duplication",level:3},{value:"What&#39;s next",id:"whats-next",level:2}];function o(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(s.header,{children:(0,d.jsx)(s.h1,{id:"types",children:"Types"})}),"\n",(0,d.jsxs)(s.p,{children:["Types in ",(0,d.jsx)(s.strong,{children:"ethdebug/format"})," describe the structure and interpretation of raw\nbytes. They tell a debugger how to decode values from EVM state into\nhuman-readable representations."]}),"\n",(0,d.jsx)(s.h2,{id:"why-types-matter",children:"Why types matter"}),"\n",(0,d.jsx)(s.p,{children:"When a debugger reads bytes from storage, memory, or the stack, those bytes\nare meaningless without context. A 32-byte value could be:"}),"\n",(0,d.jsxs)(s.ul,{children:["\n",(0,d.jsxs)(s.li,{children:["A ",(0,d.jsx)(s.code,{children:"uint256"})," representing a token balance"]}),"\n",(0,d.jsxs)(s.li,{children:["An ",(0,d.jsx)(s.code,{children:"address"})," padded to 32 bytes"]}),"\n",(0,d.jsxs)(s.li,{children:["Part of a ",(0,d.jsx)(s.code,{children:"string"})," or ",(0,d.jsx)(s.code,{children:"bytes"})," array"]}),"\n",(0,d.jsx)(s.li,{children:"A storage slot containing packed struct members"}),"\n"]}),"\n",(0,d.jsx)(s.p,{children:"Type information bridges this gap. It tells the debugger exactly how to\ninterpret the raw bytes and present them to developers in a meaningful way."}),"\n",(0,d.jsx)(s.h2,{id:"core-ideas",children:"Core ideas"}),"\n",(0,d.jsx)(s.h3,{id:"types-are-organized-by-kind",children:"Types are organized by kind"}),"\n",(0,d.jsxs)(s.p,{children:["Every type representation is a JSON object with a ",(0,d.jsx)(s.code,{children:"kind"})," field:"]}),"\n",(0,d.jsx)(s.pre,{children:(0,d.jsx)(s.code,{className:"language-json",children:'{\n  "kind": "uint",\n  "bits": 256\n}\n'})}),"\n",(0,d.jsxs)(s.p,{children:["The ",(0,d.jsx)(s.code,{children:"kind"})," field determines which schema applies. Common kinds include:"]}),"\n",(0,d.jsxs)(s.ul,{children:["\n",(0,d.jsxs)(s.li,{children:[(0,d.jsx)(s.strong,{children:"Elementary types"}),": ",(0,d.jsx)(s.code,{children:"uint"}),", ",(0,d.jsx)(s.code,{children:"int"}),", ",(0,d.jsx)(s.code,{children:"bool"}),", ",(0,d.jsx)(s.code,{children:"address"}),", ",(0,d.jsx)(s.code,{children:"bytes"}),", ",(0,d.jsx)(s.code,{children:"string"}),",\n",(0,d.jsx)(s.code,{children:"enum"}),", ",(0,d.jsx)(s.code,{children:"ufixed"}),", ",(0,d.jsx)(s.code,{children:"fixed"})]}),"\n",(0,d.jsxs)(s.li,{children:[(0,d.jsx)(s.strong,{children:"Complex types"}),": ",(0,d.jsx)(s.code,{children:"array"}),", ",(0,d.jsx)(s.code,{children:"struct"}),", ",(0,d.jsx)(s.code,{children:"mapping"}),", ",(0,d.jsx)(s.code,{children:"tuple"}),", ",(0,d.jsx)(s.code,{children:"alias"}),", ",(0,d.jsx)(s.code,{children:"function"})]}),"\n"]}),"\n",(0,d.jsx)(s.h3,{id:"elementary-vs-complex",children:"Elementary vs. complex"}),"\n",(0,d.jsx)(s.p,{children:"Types fall into two classes:"}),"\n",(0,d.jsxs)(s.ul,{children:["\n",(0,d.jsxs)(s.li,{children:[(0,d.jsx)(s.strong,{children:"Elementary types"})," stand alone\u2014they don't contain other types. Examples:\n",(0,d.jsx)(s.code,{children:"uint256"}),", ",(0,d.jsx)(s.code,{children:"address"}),", ",(0,d.jsx)(s.code,{children:"bool"})]}),"\n",(0,d.jsxs)(s.li,{children:[(0,d.jsx)(s.strong,{children:"Complex types"})," compose other types. A ",(0,d.jsx)(s.code,{children:"uint256[]"})," array contains a\n",(0,d.jsx)(s.code,{children:"uint256"}),". A ",(0,d.jsx)(s.code,{children:"mapping(address => uint256)"})," contains both ",(0,d.jsx)(s.code,{children:"address"})," and\n",(0,d.jsx)(s.code,{children:"uint256"}),"."]}),"\n"]}),"\n",(0,d.jsxs)(s.h3,{id:"complex-types-use-contains",children:["Complex types use ",(0,d.jsx)(s.code,{children:"contains"})]}),"\n",(0,d.jsxs)(s.p,{children:["Complex types express their composition through a ",(0,d.jsx)(s.code,{children:"contains"})," field. This field\ncan take three forms:"]}),"\n",(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.strong,{children:"Single type"})," (arrays, aliases):"]}),"\n",(0,d.jsx)(s.pre,{children:(0,d.jsx)(s.code,{className:"language-json",children:'{\n  "kind": "array",\n  "contains": {\n    "type": { "kind": "uint", "bits": 256 }\n  }\n}\n'})}),"\n",(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.strong,{children:"Ordered list"})," (structs, tuples):"]}),"\n",(0,d.jsx)(s.pre,{children:(0,d.jsx)(s.code,{className:"language-json",children:'{\n  "kind": "struct",\n  "contains": [\n    { "name": "balance", "type": { "kind": "uint", "bits": 256 } },\n    { "name": "owner", "type": { "kind": "address" } }\n  ]\n}\n'})}),"\n",(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.strong,{children:"Object mapping"})," (mappings):"]}),"\n",(0,d.jsx)(s.pre,{children:(0,d.jsx)(s.code,{className:"language-json",children:'{\n  "kind": "mapping",\n  "contains": {\n    "key": { "type": { "kind": "address" } },\n    "value": { "type": { "kind": "uint", "bits": 256 } }\n  }\n}\n'})}),"\n",(0,d.jsx)(s.h3,{id:"type-references-avoid-duplication",children:"Type references avoid duplication"}),"\n",(0,d.jsx)(s.p,{children:"Instead of repeating a full type definition everywhere it's used, you can\nreference types by ID:"}),"\n",(0,d.jsx)(s.pre,{children:(0,d.jsx)(s.code,{className:"language-json",children:'{\n  "kind": "array",\n  "contains": {\n    "type": { "id": "some-opaque-type-id" }\n  }\n}\n'})}),"\n",(0,d.jsx)(s.p,{children:"This keeps debugging information compact and allows types to reference each\nother (useful for recursive structures)."}),"\n",(0,d.jsx)(s.h2,{id:"whats-next",children:"What's next"}),"\n",(0,d.jsxs)("div",{className:"row",children:[(0,d.jsx)("div",{className:"col col--6",children:(0,d.jsxs)("div",{className:"card margin-bottom--md",children:[(0,d.jsx)("div",{className:"card__header",children:(0,d.jsx)("h3",{children:"Elementary types"})}),(0,d.jsx)("div",{className:"card__body",children:(0,d.jsx)("p",{children:"Integers, addresses, booleans, and other atomic types."})}),(0,d.jsx)("div",{className:"card__footer",children:(0,d.jsx)("a",{className:"button button--secondary button--block",href:"./elementary",children:(0,d.jsx)(s.p,{children:"Learn more \u2192"})})})]})}),(0,d.jsx)("div",{className:"col col--6",children:(0,d.jsxs)("div",{className:"card margin-bottom--md",children:[(0,d.jsx)("div",{className:"card__header",children:(0,d.jsx)("h3",{children:"Composite types"})}),(0,d.jsx)("div",{className:"card__body",children:(0,d.jsx)("p",{children:"Arrays, structs, mappings, and types that contain other types."})}),(0,d.jsx)("div",{className:"card__footer",children:(0,d.jsx)("a",{className:"button button--secondary button--block",href:"./composite",children:(0,d.jsx)(s.p,{children:"Learn more \u2192"})})})]})})]}),"\n",(0,d.jsxs)("div",{className:"row",children:[(0,d.jsx)("div",{className:"col col--6",children:(0,d.jsxs)("div",{className:"card margin-bottom--md",children:[(0,d.jsx)("div",{className:"card__header",children:(0,d.jsx)("h3",{children:"Representation"})}),(0,d.jsx)("div",{className:"card__body",children:(0,d.jsx)("p",{children:"How types map to bytes in storage vs. memory encoding contexts."})}),(0,d.jsx)("div",{className:"card__footer",children:(0,d.jsx)("a",{className:"button button--secondary button--block",href:"./representation",children:(0,d.jsx)(s.p,{children:"Learn more \u2192"})})})]})}),(0,d.jsx)("div",{className:"col col--6",children:(0,d.jsxs)("div",{className:"card margin-bottom--md",children:[(0,d.jsx)("div",{className:"card__header",children:(0,d.jsx)("h3",{children:"Full specification"})}),(0,d.jsx)("div",{className:"card__body",children:(0,d.jsx)("p",{children:"Complete JSON schemas and detailed reference."})}),(0,d.jsx)("div",{className:"card__footer",children:(0,d.jsx)("a",{className:"button button--secondary button--block",href:"/spec/type",children:(0,d.jsx)(s.p,{children:"View spec \u2192"})})})]})})]})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,d.jsx)(s,{...e,children:(0,d.jsx)(o,{...e})}):o(e)}}}]);