"use strict";(globalThis.webpackChunk_ethdebug_format_web=globalThis.webpackChunk_ethdebug_format_web||[]).push([[7288],{792(e,t,n){n.d(t,{A:()=>u});n(14041);var s=n(40665);const o="container_Hrln",r="link_y57m",i="label_feh8",a="schema_kJnE",c="arrow_YbSg";var l=n(31085);function u({schema:e,href:t}){return(0,l.jsx)("div",{className:o,children:(0,l.jsxs)(s.A,{to:t,className:r,children:[(0,l.jsx)("span",{className:i,children:"Schema:"}),(0,l.jsx)("span",{className:a,children:e}),(0,l.jsx)("span",{className:c,children:"\u2192"})]})})}},9921(e,t,n){n.d(t,{Ir:()=>r,AI:()=>L,wE:()=>ho});var s={};n.r(s),n.d(s,{K$:()=>T});var o={};n.r(o),n.d(o,{combineDebugContexts:()=>A,combineSubInstructionContexts:()=>D,extractContexts:()=>I,extractSubInstructionContexts:()=>$,preserveDebug:()=>j,preserveSubInstructionDebug:()=>M});var r={};n.r(r),n.d(r,{ht:()=>s,bQ:()=>w,ZU:()=>v,Aq:()=>o,WT:()=>x});var i=n(31917);var a;!function(e){e.isBase=e=>{return"object"==typeof e&&!!e&&"id"in e&&"string"==typeof e.id&&"kind"in e&&"string"==typeof e.kind&&!!e.kind&&"loc"in e&&(null===e.loc||(t=e.loc,i.t8.isSourceRange({source:{id:"pending"},range:t})));var t},e.clone=function(t){const n={...t};for(const[s,o]of Object.entries(n))o&&"object"==typeof o&&(Array.isArray(o)?n[s]=o.map((t=>t&&"object"==typeof t&&"kind"in t?e.clone(t):t)):"kind"in o&&(n[s]=e.clone(o)));return n},e.update=function(e,t){return{...e,...t}}}(a||(a={}));var c;!function(e){e.isBase=e=>a.isBase(e)&&e.kind.startsWith("declaration")&&"name"in e&&"string"==typeof e.name,e.struct=function(e,t,n,s){return{id:e,kind:"declaration:struct",name:t,fields:n,loc:s??null}},e.isStruct=e=>"kind"in e&&"declaration:struct"===e.kind,e.field=function(e,t,n,s,o){return{id:e,kind:"declaration:field",name:t,type:n,initializer:s,loc:o??null}},e.isField=e=>"kind"in e&&"declaration:field"===e.kind,e.storage=function(e,t,n,s,o){return{id:e,kind:"declaration:storage",name:t,type:n,slot:s,loc:o??null}},e.isStorage=e=>"kind"in e&&"declaration:storage"===e.kind,e.variable=function(e,t,n,s,o){return{id:e,kind:"declaration:variable",name:t,type:n,initializer:s,loc:o??null}},e.isVariable=e=>"kind"in e&&"declaration:variable"===e.kind,e.function_=function(e,t,n,s,o,r){return{id:e,kind:"declaration:function",name:t,parameters:n,returnType:s,body:o,loc:r??null}},e.isFunction=e=>"kind"in e&&"declaration:function"===e.kind,e.parameter=function(e,t,n,s){return{id:e,kind:"declaration:parameter",name:t,type:n,loc:s??null}},e.isParameter=e=>"declaration:parameter"===e.kind}(c||(c={}));var l;!function(e){e.isBase=e=>a.isBase(e)&&e.kind.startsWith("block:"),e.statements=function(e,t,n){return{id:e,kind:"block:statements",items:t,loc:n??null}},e.isStatements=e=>"block:statements"===e.kind,e.definitions=function(e,t,n){return{id:e,kind:"block:definitions",items:t,loc:n??null}},e.isDefinitions=e=>"block:definitions"===e.kind}(l||(l={}));var u;!function(e){let t,n;e.isBase=e=>a.isBase(e)&&e.kind.startsWith("type:"),e.isElementary=e=>e.kind.startsWith("type:elementary:"),function(e){e.isBase=e=>e.kind.startsWith("type:elementary:"),e.isUint=e=>"type:elementary:uint"===e.kind,e.uint=function(e,t=256,n){return{id:e,kind:"type:elementary:uint",bits:t,loc:n??null}},e.isInt=e=>"type:elementary:int"===e.kind,e.int=function(e,t=256,n){return{id:e,kind:"type:elementary:int",bits:t,loc:n??null}},e.isAddress=e=>"type:elementary:address"===e.kind,e.address=function(e,t){return{id:e,kind:"type:elementary:address",loc:t??null}},e.isBool=e=>"type:elementary:bool"===e.kind,e.bool=function(e,t){return{id:e,kind:"type:elementary:bool",loc:t??null}},e.isBytes=e=>"type:elementary:bytes"===e.kind,e.bytes=function(e,t,n){return{id:e,kind:"type:elementary:bytes",size:t,loc:n??null}},e.isString=e=>"type:elementary:string"===e.kind,e.string=function(e,t){return{id:e,kind:"type:elementary:string",loc:t??null}},e.isFixed=e=>"type:elementary:fixed"===e.kind,e.fixed=function(e,t=128,n){return{id:e,kind:"type:elementary:fixed",bits:t,loc:n??null}},e.isUfixed=e=>"type:elementary:ufixed"===e.kind,e.ufixed=function(e,t=128,n){return{id:e,kind:"type:elementary:ufixed",bits:t,loc:n??null}}}(t=e.Elementary||(e.Elementary={})),e.isComplex=e=>e.kind.startsWith("type:complex:"),function(e){e.isBase=e=>e.kind.startsWith("type:complex:"),e.isArray=e=>"type:complex:array"===e.kind,e.array=function(e,t,n,s){return{id:e,kind:"type:complex:array",element:t,size:n,loc:s??null}},e.isMapping=e=>"type:complex:mapping"===e.kind,e.mapping=function(e,t,n,s){return{id:e,kind:"type:complex:mapping",key:t,value:n,loc:s??null}},e.isStruct=e=>"type:complex:struct"===e.kind,e.struct=function(e,t,n){return{id:e,kind:"type:complex:struct",fields:t,loc:n??null}},e.isTuple=e=>"type:complex:tuple"===e.kind,e.tuple=function(e,t,n){return{id:e,kind:"type:complex:tuple",members:t,loc:n??null}},e.isFunction=e=>"type:complex:function"===e.kind,e.function_=function(e,t,n,s){return{id:e,kind:"type:complex:function",parameters:t,returns:n,loc:s??null}},e.isAlias=e=>"type:complex:alias"===e.kind,e.alias=function(e,t,n){return{id:e,kind:"type:complex:alias",base:t,loc:n??null}},e.isContract=e=>"type:complex:contract"===e.kind,e.contract=function(e,t,n){return{id:e,kind:"type:complex:contract",name:t,loc:n??null}},e.isEnum=e=>"type:complex:enum"===e.kind,e.enum_=function(e,t,n){return{id:e,kind:"type:complex:enum",members:t,loc:n??null}}}(n=e.Complex||(e.Complex={})),e.isReference=e=>"type:reference"===e.kind,e.reference=function(e,t,n){return{id:e,kind:"type:reference",name:t,loc:n??null}}}(u||(u={}));const d=e=>p.isBase(e)&&[p.isDeclare,p.isAssign,p.isControlFlow,p.isExpress].some((t=>t(e)));var p;!function(e){let t;e.isBase=e=>a.isBase(e)&&e.kind.startsWith("statement:"),e.isDeclare=e=>"statement:declare"===e.kind,e.declare=function(e,t,n){return{id:e,kind:"statement:declare",declaration:t,loc:n??null}},e.isAssign=e=>"statement:assign"===e.kind,e.assign=function(e,t,n,s,o){return{id:e,kind:"statement:assign",target:t,value:n,operator:s,loc:o??null}},e.isControlFlow=t=>e.ControlFlow.isBase(t)&&[e.ControlFlow.isIf,e.ControlFlow.isFor,e.ControlFlow.isWhile,e.ControlFlow.isReturn,e.ControlFlow.isBreak,e.ControlFlow.isContinue].some((e=>e(t))),function(e){e.isBase=e=>e.kind.startsWith("statement:control-flow:"),e.isIf=e=>"statement:control-flow:if"===e.kind,e.if_=function(e,t,n,s,o){return{id:e,kind:"statement:control-flow:if",condition:t,body:n,alternate:s,loc:o??null}},e.isFor=e=>"statement:control-flow:for"===e.kind,e.for_=function(e,t,n,s,o,r){return{id:e,kind:"statement:control-flow:for",init:n,condition:s,update:o,body:t,loc:r??null}},e.isWhile=e=>"statement:control-flow:while"===e.kind,e.while_=function(e,t,n,s){return{id:e,kind:"statement:control-flow:while",condition:t,body:n,loc:s??null}},e.isReturn=e=>"statement:control-flow:return"===e.kind,e.return_=function(e,t,n){return{id:e,kind:"statement:control-flow:return",value:t,loc:n??null}},e.isBreak=e=>"statement:control-flow:break"===e.kind,e.break_=function(e,t,n){return{id:e,kind:"statement:control-flow:break",label:t,loc:n??null}},e.isContinue=e=>"statement:control-flow:continue"===e.kind,e.continue_=function(e,t,n){return{id:e,kind:"statement:control-flow:continue",label:t,loc:n??null}}}(t=e.ControlFlow||(e.ControlFlow={})),e.isExpress=e=>"statement:express"===e.kind,e.express=function(e,t,n){return{id:e,kind:"statement:express",expression:t,loc:n??null}}}(p||(p={}));const m=e=>f.isBase(e)&&[f.isIdentifier,f.isLiteral,f.isArray,f.isStruct,f.isOperator,f.isAccess,f.isCall,f.isCast,f.isSpecial].some((t=>t(e)));var f;!function(e){let t,n,s;e.isBase=e=>a.isBase(e)&&e.kind.startsWith("expression:"),e.isAssignable=function(e){return"expression:identifier"===e.kind||e.kind.startsWith("expression:access")},e.isIdentifier=e=>"expression:identifier"===e.kind&&"name"in e&&"string"==typeof e.name,e.identifier=function(e,t,n){return{id:e,kind:"expression:identifier",name:t,loc:n??null}},e.isLiteral=t=>e.Literal.isBase(t)&&[e.Literal.isNumber,e.Literal.isString,e.Literal.isBoolean,e.Literal.isAddress,e.Literal.isHex].some((e=>e(t))),function(e){e.isBase=e=>e.kind.startsWith("expression:literal:")&&"value"in e&&"string"==typeof e.value,e.isNumber=e=>"expression:literal:number"===e.kind,e.number=function(e,t,n,s){return{id:e,kind:"expression:literal:number",value:t,unit:n,loc:s??null}},e.isString=e=>"expression:literal:string"===e.kind,e.string=function(e,t,n){return{id:e,kind:"expression:literal:string",value:t,loc:n??null}},e.isBoolean=e=>"expression:literal:boolean"===e.kind,e.boolean=function(e,t,n){return{id:e,kind:"expression:literal:boolean",value:t,loc:n??null}},e.isAddress=e=>"expression:literal:address"===e.kind,e.address=function(e,t,n){return{id:e,kind:"expression:literal:address",value:t,loc:n??null}},e.isHex=e=>"expression:literal:hex"===e.kind,e.hex=function(e,t,n){return{id:e,kind:"expression:literal:hex",value:t,loc:n??null}}}(t=e.Literal||(e.Literal={})),e.isArray=e=>"expression:array"===e.kind&&"elements"in e&&h.isArray(e.elements)&&e.elements.every(m),e.array=function(e,t,n){return{id:e,kind:"expression:array",elements:t,loc:n??null}},e.isStruct=e=>"expression:struct"===e.kind&&"fields"in e&&h.isArray(e.fields)&&e.fields.every((e=>"object"==typeof e&&null!==e&&"name"in e&&"string"==typeof e.name&&"value"in e&&m(e.value))),e.struct=function(e,t,n,s){return{id:e,kind:"expression:struct",structName:n,fields:t,loc:s??null}},e.isOperator=e=>"expression:operator"===e.kind&&"operator"in e&&"string"==typeof e.operator&&"operands"in e&&Array.isArray(e.operands),e.operator=function(e,t,n,s){return{id:e,kind:"expression:operator",operator:t,operands:n,loc:s??null}},e.isAccess=t=>e.Access.isBase(t)&&[e.Access.isMember,e.Access.isSlice,e.Access.isIndex].some((e=>e(t))),function(e){e.isBase=e=>a.isBase(e)&&e.kind.startsWith("expression:access:")&&"object"in e&&m(e.object),e.member=function(e,t,n,s){return{id:e,kind:"expression:access:member",object:t,property:n,loc:s??null}},e.isMember=e=>"expression:access:member"===e.kind,e.slice=function(e,t,n,s,o){return{id:e,kind:"expression:access:slice",object:t,start:n,end:s,loc:o??null}},e.isSlice=e=>"expression:access:slice"===e.kind,e.index=function(e,t,n,s){return{id:e,kind:"expression:access:index",object:t,index:n,loc:s??null}},e.isIndex=e=>"expression:access:index"===e.kind}(n=e.Access||(e.Access={})),e.isCall=e=>"expression:call"===e.kind&&"callee"in e&&"object"==typeof e.callee&&"arguments"in e&&Array.isArray(e.arguments),e.call=function(e,t,n,s){return{id:e,kind:"expression:call",callee:t,arguments:n,loc:s??null}},e.isCast=e=>"expression:cast"===e.kind&&"expression"in e&&"object"==typeof e.expression&&"targetType"in e&&"object"==typeof e.targetType,e.cast=function(e,t,n,s){return{id:e,kind:"expression:cast",expression:t,targetType:n,loc:s??null}},e.isSpecial=t=>e.Special.isBase(t)&&[e.Special.isMsgData,e.Special.isMsgValue,e.Special.isMsgSender,e.Special.isBlockNumber,e.Special.isBlockTimestamp].some((e=>e(t))),function(e){e.isBase=e=>e.kind.startsWith("expression:special:"),e.isMsgSender=e=>"expression:special:msg.sender"===e.kind,e.msgSender=function(e,t){return{id:e,kind:"expression:special:msg.sender",loc:t??null}},e.isMsgValue=e=>"expression:special:msg.value"===e.kind,e.msgValue=function(e,t){return{id:e,kind:"expression:special:msg.value",loc:t??null}},e.isMsgData=e=>"expression:special:msg.data"===e.kind,e.msgData=function(e,t){return{id:e,kind:"expression:special:msg.data",loc:t??null}},e.isBlockTimestamp=e=>"expression:special:block.timestamp"===e.kind,e.blockTimestamp=function(e,t){return{id:e,kind:"expression:special:block.timestamp",loc:t??null}},e.isBlockNumber=e=>"expression:special:block.number"===e.kind,e.blockNumber=function(e,t){return{id:e,kind:"expression:special:block.number",loc:t??null}}}(s=e.Special||(e.Special={}))}(f||(f={}));const h=Array;function g(e,t,n){if("program"===t.kind)return e.program(t,n);if(t.kind.startsWith("declaration:"))return e.declaration(t,n);if(t.kind.startsWith("block:"))return e.block(t,n);if(t.kind.startsWith("type:"))return e.type(t,n);if(t.kind.startsWith("statement:"))return e.statement(t,n);if(t.kind.startsWith("expression:"))return e.expression(t,n);throw new Error(`Unknown node kind: ${t.kind}`)}const y=e=>k.isBase(e)&&[k.isElementary,k.isArray,k.isStruct,k.isMapping,k.isFunction,k.isFailure].some((t=>t(e))),b=Array;var k,v,x,w,T,E,S;function N(e,t,n){const s=new Map(e);return s.set(t,n),s}!function(e){let t,n,s,o,r,i;e.equals=(t,n)=>{if(t.kind!==n.kind)return!1;if(e.isElementary(t)&&e.isElementary(n))return e.Elementary.equals(t,n);return{array:e.Array.equals,struct:e.Struct.equals,mapping:e.Mapping.equals,function:e.Function.equals,failure:e.Failure.equals}[t.kind](t,n)},e.format=t=>{if(e.isElementary(t))return e.Elementary.format(t);return{array:e.Array,struct:e.Struct,mapping:e.Mapping,function:e.Function,failure:e.Failure}[t.kind].format(t)},e.isBase=e=>"object"==typeof e&&!!e&&"kind"in e&&"string"==typeof e.kind&&!!e.kind,e.isElementary=t=>[e.Elementary.isUint,e.Elementary.isInt,e.Elementary.isAddress,e.Elementary.isBool,e.Elementary.isBytes,e.Elementary.isString].some((e=>e(t))),function(t){let n,s,o,r,i,a;t.equals=(t,n)=>{if(t.kind!==n.kind)return!1;return{uint:e.Elementary.Uint.equals,int:e.Elementary.Int.equals,address:e.Elementary.Address.equals,bytes:e.Elementary.Bytes.equals,bool:e.Elementary.Bool.equals,string:e.Elementary.String.equals}[t.kind](t,n)},t.format=t=>({uint:e.Elementary.Uint,int:e.Elementary.Int,address:e.Elementary.Address,bytes:e.Elementary.Bytes,bool:e.Elementary.Bool,string:e.Elementary.String}[t.kind].format(t)),t.uint=e=>({kind:"uint",bits:e}),function(e){e.equals=(e,t)=>e.bits===t.bits,e.format=e=>`uint${e.bits}`}(n=t.Uint||(t.Uint={})),t.int=e=>({kind:"int",bits:e}),function(e){e.equals=(e,t)=>e.bits===t.bits,e.format=e=>`int${e.bits}`}(s=t.Int||(t.Int={})),t.address=()=>({kind:"address"}),function(e){e.equals=(e,t)=>!0,e.format=e=>"address"}(o=t.Address||(t.Address={})),t.bool=()=>({kind:"bool"}),function(e){e.equals=(e,t)=>!0,e.format=e=>"bool"}(r=t.Bool||(t.Bool={})),t.bytes=e=>({kind:"bytes",size:e}),function(e){e.isDynamic=e=>!("size"in e)||void 0===e.size,e.equals=(e,t)=>e.size==t.size,e.format=e=>`bytes${"size"in e&&"number"==typeof e.size?e.size.toString():""}`}(i=t.Bytes||(t.Bytes={})),t.string=()=>({kind:"string"}),function(e){e.equals=(e,t)=>!0,e.format=e=>"string"}(a=t.String||(t.String={}));const c=e=>t=>t.kind===e;t.isUint=c("uint"),t.isInt=c("int"),t.isAddress=c("address"),t.isBool=c("bool"),t.isBytes=c("bytes"),t.isString=c("string"),t.isNumeric=t=>e.Elementary.isUint(t)||e.Elementary.isInt(t)}(t=e.Elementary||(e.Elementary={})),e.isArray=e=>"array"===e.kind&&"element"in e&&y(e.element),e.array=(e,t)=>({kind:"array",element:e,size:t}),function(t){t.equals=(t,n)=>e.equals(t.element,n.element)&&t.size===n.size,t.format=t=>`array<${e.format(t.element)}${"size"in t&&"number"==typeof t.size?`, ${t.size}`:""}>`}(n=e.Array||(e.Array={})),e.mapping=(e,t)=>({kind:"mapping",key:e,value:t}),e.isMapping=e=>"mapping"===e.kind&&"key"in e&&"value"in e&&y(e.key)&&y(e.value),function(t){t.equals=(t,n)=>e.equals(t.key,n.key)&&e.equals(t.value,n.value),t.format=t=>`mapping<${e.format(t.key)}, ${e.format(t.value)}>`}(s=e.Mapping||(e.Mapping={})),e.isStruct=e=>"struct"===e.kind&&"name"in e&&"string"==typeof e.name&&"fields"in e&&e.fields instanceof Map&&[...e.fields.values()].every(y),e.struct=(e,t,n)=>({kind:"struct",name:e,fields:t,layout:n}),function(e){e.equals=(e,t)=>e.name===t.name&&e.fields.size==t.fields.size&&[...e.fields.entries()].every((([e,n],s)=>[...t.fields.keys()][s]===e&&[...t.fields.values()][s]===n)),e.format=e=>e.name}(o=e.Struct||(e.Struct={})),e.function_=(e,t,n)=>({kind:"function",parameters:e,return:t,name:n}),e.isFunction=e=>"function"===e.kind&&"parameters"in e&&e.parameters instanceof b&&e.parameters.every(y)&&"return"in e&&(null===e.return||y(e.return)),function(t){t.equals=(t,n)=>t.parameters.length===n.parameters.length&&t.parameters.every(((e,t)=>e==n.parameters[t]))&&(null===t.return&&null===n.return||null!==t.return&&null!==n.return&&e.equals(t.return,n.return)),t.format=t=>`function ${"name"in t?t.name:""}(${t.parameters.map((t=>e.format(t))).join(", ")})${null!==t.return?`-> ${e.format(t.return)}`:""}`}(r=e.Function||(e.Function={})),e.failure=e=>({kind:"fail",reason:e}),e.isFailure=e=>"fail"===e.kind&&"reason"in e&&"string"==typeof e.reason&&!!e.reason,function(e){e.equals=(e,t)=>e.reason===t.reason,e.format=e=>`fail<"${e.reason}">`}(i=e.Failure||(e.Failure={}))}(k||(k={}));!function(e){let t,n;e.isBase=e=>"object"==typeof e&&!!e&&"kind"in e&&"string"==typeof e.kind,e.scalar=(e,t)=>({kind:"scalar",size:e,origin:t}),e.isScalar=e=>"scalar"===e.kind&&"size"in e&&"number"==typeof e.size&&e.size>=1&&e.size<=32&&"origin"in e,function(t){t.synthetic=t=>e.scalar(t,"synthetic"),t.bytes1=t.synthetic(1),t.bytes4=t.synthetic(4),t.bytes8=t.synthetic(8),t.bytes20=t.synthetic(20),t.bytes32=t.synthetic(32),t.uint8=t.bytes1,t.uint32=t.bytes4,t.uint64=t.bytes8,t.uint256=t.bytes32,t.int8=t.bytes1,t.int256=t.bytes32,t.address=t.bytes20,t.bool=t.bytes1,t.word=t.bytes32,t.equals=(e,t)=>e.size===t.size&&e.origin===t.origin,t.format=e=>{const t=`scalar${e.size}`;return"synthetic"===e.origin?t:`${t}[${k.format(e.origin)}]`}}(t=e.Scalar||(e.Scalar={})),e.ref=(e,t)=>({kind:"ref",location:e,origin:t}),e.isRef=e=>"ref"===e.kind&&"location"in e&&"string"==typeof e.location&&["memory","storage","calldata","returndata","transient"].includes(e.location)&&"origin"in e,function(t){t.synthetic=t=>e.ref(t,"synthetic"),t.memory=()=>t.synthetic("memory"),t.storage=()=>t.synthetic("storage"),t.calldata=()=>t.synthetic("calldata"),t.returndata=()=>t.synthetic("returndata"),t.transient=()=>t.synthetic("transient"),t.equals=(e,t)=>e.location===t.location&&e.origin===t.origin,t.format=e=>{const t=`ref<${e.location}>`;return"synthetic"===e.origin?t:`${t}[${k.format(e.origin)}]`}}(n=e.Ref||(e.Ref={})),e.equals=(t,n)=>t.kind===n.kind&&(e.isScalar(t)&&e.isScalar(n)?e.Scalar.equals(t,n):!(!e.isRef(t)||!e.isRef(n))&&e.Ref.equals(t,n)),e.format=t=>e.isScalar(t)?e.Scalar.format(t):e.isRef(t)?e.Ref.format(t):"unknown"}(v||(v={})),function(e){e.temp=function(e,t,n){return{kind:"temp",id:e,type:t,debug:n}},e.constant=function(e,t,n){return{kind:"const",value:e,type:t,debug:n}}}(x||(x={})),function(e){let t,n;!function(e){e.isArray=e=>"array"===e.offsetKind,e.array=(e,t,n,s,o,r,i,a)=>({kind:"compute_offset",offsetKind:"array",location:e,base:t,baseDebug:i,index:n,indexDebug:a,stride:s,dest:o,operationDebug:r}),e.isField=e=>"field"===e.offsetKind,e.field=(e,t,n,s,o,r,i)=>({kind:"compute_offset",offsetKind:"field",location:e,base:t,baseDebug:i,field:n,fieldOffset:s,dest:o,operationDebug:r}),e.isByte=e=>"byte"===e.offsetKind,e.byte=(e,t,n,s,o,r,i)=>({kind:"compute_offset",offsetKind:"byte",location:e,base:t,baseDebug:r,offset:n,offsetDebug:i,dest:s,operationDebug:o})}(t=e.ComputeOffset||(e.ComputeOffset={})),function(e){e.isMapping=e=>"mapping"===e.slotKind,e.mapping=(e,t,n,s,o,r,i)=>({kind:"compute_slot",slotKind:"mapping",base:e,baseDebug:r,key:t,keyDebug:i,keyType:n,dest:s,operationDebug:o}),e.isArray=e=>"array"===e.slotKind,e.array=(e,t,n,s)=>({kind:"compute_slot",slotKind:"array",base:e,baseDebug:s,dest:t,operationDebug:n}),e.isField=e=>"field"===e.slotKind,e.field=(e,t,n,s,o)=>({kind:"compute_slot",slotKind:"field",base:e,baseDebug:o,fieldOffset:t,dest:n,operationDebug:s})}(n=e.ComputeSlot||(e.ComputeSlot={}))}(w||(w={}));function A(...e){const t=e.filter((e=>void 0!==e)).map((e=>e.context)).filter((e=>void 0!==e));if(0===t.length)return{};const n=[];for(const r of t)"pick"in r&&Array.isArray(r.pick)?n.push(...r.pick):n.push(r);const s=[],o=new Set;for(const r of n){const e=JSON.stringify(r,((e,t)=>t&&"object"==typeof t&&!Array.isArray(t)?Object.keys(t).sort().reduce(((e,n)=>(e[n]=t[n],e)),{}):t));o.has(e)||(o.add(e),s.push(r))}return 0===s.length?{}:1===s.length?{context:s[0]}:{context:{pick:s}}}function j(e,...t){let n;return"operationDebug"in e?n=e.operationDebug:"debug"in e&&(n=e.debug),A(n,...t)}function I(...e){const t=[];for(const n of e){if(!n)continue;let e;"operationDebug"in n?e=n.operationDebug:"debug"in n&&(e=n.debug),e?.context&&t.push(e.context)}return t}function D(e,t){return A(...[e,...Object.values(t)])}function $(e){const t=[];switch(e.operationDebug?.context&&t.push(e.operationDebug.context),e.kind){case"binary":e.leftDebug?.context&&t.push(e.leftDebug.context),e.rightDebug?.context&&t.push(e.rightDebug.context);break;case"unary":e.operandDebug?.context&&t.push(e.operandDebug.context);break;case"read":case"write":e.slotDebug?.context&&t.push(e.slotDebug.context),e.offsetDebug?.context&&t.push(e.offsetDebug.context),e.lengthDebug?.context&&t.push(e.lengthDebug.context),"write"===e.kind&&e.valueDebug?.context&&t.push(e.valueDebug.context);break;case"compute_offset":e.baseDebug?.context&&t.push(e.baseDebug.context),"array"===e.offsetKind&&e.indexDebug?.context&&t.push(e.indexDebug.context),"byte"===e.offsetKind&&e.offsetDebug?.context&&t.push(e.offsetDebug.context);break;case"compute_slot":e.baseDebug?.context&&t.push(e.baseDebug.context),"mapping"===e.slotKind&&e.keyDebug?.context&&t.push(e.keyDebug.context);break;case"const":case"hash":case"cast":e.valueDebug?.context&&t.push(e.valueDebug.context);break;case"allocate":e.sizeDebug?.context&&t.push(e.sizeDebug.context);break;case"length":e.objectDebug?.context&&t.push(e.objectDebug.context)}const n=e=>{e?.debug?.context&&t.push(e.debug.context)};switch(e.kind){case"binary":n(e.left),n(e.right);break;case"unary":n(e.operand);break;case"read":n(e.slot),n(e.offset),n(e.length);break;case"write":n(e.slot),n(e.offset),n(e.length),n(e.value);break;case"compute_offset":n(e.base),"array"===e.offsetKind&&n(e.index),"byte"===e.offsetKind&&n(e.offset);break;case"compute_slot":n(e.base),"mapping"===e.slotKind&&n(e.key);break;case"allocate":n(e.size);break;case"hash":case"cast":n(e.value);break;case"length":n(e.object)}return t}function M(e,...t){const n=$(e),s=t.filter((e=>void 0!==e)).map((e=>e.context)).filter((e=>void 0!==e));return A(...n.map((e=>({context:e}))),...s.map((e=>({context:e}))))}!function(e){e.Analyzer=class{analyze(e){const t=e.main,n=Array.from(t.blocks.values()),s=n.length,o=n.flatMap((e=>e.instructions)),r=o.length,i={};for(const g of o)i[g.kind]=(i[g.kind]||0)+1;const a=n.map((e=>e.instructions.length+1)),c=Math.max(...a),l=a.reduce(((e,t)=>e+t),0)/s,u=this.countTemporaries(t),d=t.parameters.length,p=this.countCfgEdges(t),m=this.computeDominatorTree(t),f=this.findCriticalPaths(t),h=this.detectLoops(t,m);return{blockCount:s,instructionCount:r,tempCount:u,parameterCount:d,maxBlockSize:c,avgBlockSize:Math.round(10*l)/10,cfgEdges:p,instructionTypes:i,criticalPaths:f,dominatorTree:m,loopInfo:h}}countTemporaries(e){const t=new Set;for(const n of e.blocks.values()){for(const e of n.instructions)"dest"in e&&e.dest&&t.add(e.dest),this.collectTempsFromValue(e,t);"branch"===n.terminator.kind?this.collectTempsFromValueRef(n.terminator.condition,t):"return"===n.terminator.kind&&n.terminator.value&&this.collectTempsFromValueRef(n.terminator.value,t)}return t.size}collectTempsFromValue(e,t){const n=["value","left","right","operand","object","array","index","key"];for(const s of n)if(s in e){const n=e[s];n&&this.collectTempsFromValueRef(n,t)}}collectTempsFromValueRef(e,t){"object"==typeof e&&e&&"kind"in e&&"temp"===e.kind&&t.add(e.id)}countCfgEdges(e){let t=0;for(const n of e.blocks.values())switch(n.terminator.kind){case"jump":t+=1;break;case"branch":t+=2}return t}computeDominatorTree(e){const t={},n=Array.from(e.blocks.keys()),s={};for(const r of n)s[r]=Array.from(e.blocks.get(r)?.predecessors||[]);t[e.entry]=null;for(const r of n)r!==e.entry&&(t[r]=void 0);let o=!0;for(;o;){o=!1;const n=[e.entry],r=new Set([e.entry]);for(;n.length>0;){const i=n.shift(),a=e.blocks.get(i);if(!a)continue;const c=this.getSuccessors(a);for(const e of c)r.has(e)||(n.push(e),r.add(e));if(i===e.entry)continue;const l=s[i]||[];if(0===l.length)continue;let u;for(const e of l)if(void 0!==t[e]){u=e;break}if(void 0!==u){for(const e of l)e!==u&&void 0!==t[e]&&(u=this.intersectDominators(e,u,t));t[i]!==u&&(t[i]=u,o=!0)}}}return t}intersectDominators(e,t,n){let s=e,o=t;const r=new Set;for(;null!==s;)r.add(s),s=n[s]??null;for(;null!==o;){if(r.has(o))return o;o=n[o]??null}throw new Error("No common dominator found - CFG may be disconnected")}findCriticalPaths(e){const t=[],n=new Set,s=(o,r,i)=>{if(n.has(o))return;const a=e.blocks.get(o);if(!a)return;const c=[...r,o],l=i+a.instructions.length+1;if("return"===a.terminator.kind)return void t.push({from:e.entry,to:o,length:l,blocks:c});n.add(o);const u=this.getSuccessors(a);for(const e of u)s(e,c,l);n.delete(o)};return s(e.entry,[],0),t.sort(((e,t)=>t.length-e.length)).slice(0,3)}detectLoops(e,t){const n=[];for(const[s,o]of e.blocks.entries()){const r=this.getSuccessors(o);for(const o of r)if(this.dominates(o,s,t)){const t=this.findLoopBlocks(o,s,e);n.push({header:o,blocks:t,depth:0})}}return this.computeLoopDepths(n),n}computeLoopDepths(e){for(let t=0;t<e.length;t++){let n=1;for(let s=0;s<e.length;s++)t!==s&&this.isLoopContainedIn(e[t],e[s])&&n++;e[t].depth=n}}isLoopContainedIn(e,t){return t.blocks.includes(e.header)}dominates(e,t,n){let s=t;for(;null!==s;){if(s===e)return!0;s=n[s]||null}return!1}findLoopBlocks(e,t,n){const s=new Set([e,t]),o=[t];for(;o.length>0;){const t=o.pop(),r=n.blocks.get(t);if(r)for(const n of r.predecessors)s.has(n)||(s.add(n),n!==e&&o.push(n))}return Array.from(s)}getSuccessors(e){switch(e.terminator.kind){case"jump":return[e.terminator.target];case"branch":return[e.terminator.trueTarget,e.terminator.falseTarget];default:return[]}}}}(T||(T={}));function C(e,t,n,s,o,r,i){let a,c=e.popN(t,n.length);for(let l=s.length-1;l>=0;l--)({id:a,state:c}=e.generateId(c,r)),c=e.push(c,e.create(a,(i?.produces||s)[l]));return e.emit(c,o)}!function(e){e.makeControls=({slice:e,prepend:t,readTop:n,generateId:s,create:o,duplicate:r,rebrand:i,emit:a})=>({popN:(t,n)=>e(t,n),push:(e,n)=>t(e,n),topN:(e,t)=>n(e,t),create:(e,t)=>o(e,t),duplicate:(e,t)=>r(e,t),rebrand:(e,t)=>i(e,t),generateId:(e,t)=>s(e,t),emit:(e,t)=>a(e,t)})}(E||(E={})),function(e){e.makeUsing=function(e){return{mapInstruction:(e,t)=>({[e.mnemonic]:t(e)}),makeOperationForInstruction:({consumes:t,produces:n,idPrefix:s})=>o=>r=>i=>C(e,i,t,n,{...o,...r},s,void 0),makeOperationWithImmediatesForInstruction:({consumes:t,produces:n,idPrefix:s})=>o=>(r,i)=>a=>C(e,a,t,n,{...o,immediates:r,...i},s,void 0)}}}(S||(S={}));const O=e=>{function t(t){return n=>{const s=Object.keys(t).map(Number).sort(((e,t)=>t-e));if(0===s.length)return n;const o=s[0],r=e.topN(n,o),i=e.popN(n,o);return r.reduceRight(((n,s,o)=>e.push(n,o+1 in t?e.rebrand(s,t[o+1]):s)),i)}}return{rebrand:t,rebrandTop:e=>n=>t({1:e})(n)}};class U{constructor(e,t){this.controls=e,this.transition=t}err(e){return this.then((()=>{throw e}))}peek(e){return new U(this.controls,(t=>{const n=this.transition(t),s=new U(this.controls,(e=>e));return e(n,s).transition(n)}))}then(e,t){const{rebrandTop:n}=O(this.controls),s=t=>e(this.transition(t));return new U(this.controls,t?e=>n(t.as)(s(e)):s)}done(){return e=>this.transition(e)}}var L,P=n(1159);!function(e){e.Error="error",e.Warning="warning"}(L||(L={}));const _={ok:e=>({success:!0,value:e,messages:{}}),okWith:(e,t)=>_.addMessages(_.ok(e),t),err(e){const t=Array.isArray(e)?e:[e];return{success:!1,messages:{[L.Error]:t}}},map:(e,t)=>e.success?{...e,value:t(e.value)}:e,addMessages(e,t){const n={...e.messages};for(const s of t){const e=s.severity;n[e]||(n[e]=[]),n[e].push(s)}return{...e,messages:n}},mergeMessages(e,t){const n={...e};for(const[s,o]of Object.entries(t))n[s]||(n[s]=[]),n[s].push(...o);return n},hasErrors:e=>(e.messages[L.Error]?.length??0)>0,hasWarnings:e=>(e.messages[L.Warning]?.length??0)>0,allMessages:e=>Object.values(e.messages).flat(),getMessages:(e,t)=>e.messages[t]||[],firstError(e){const t=e.messages[L.Error];return t?.[0]},firstMessage:e=>_.allMessages(e)[0],countBySeverity:(e,t)=>e.messages[t]?.length??0,countMessages:(e,t)=>t?_.findMessages(e,t).length:_.allMessages(e).length,findMessage:(e,t)=>_.allMessages(e).find((e=>{if(void 0!==t.severity&&e.severity!==t.severity)return!1;if(t.code&&e.code!==t.code)return!1;if(t.message){if(!("string"==typeof t.message?e.message.includes(t.message):t.message.test(e.message)))return!1}if(t.location){if(!e.location)return!1;if(e.location.offset!==t.location.offset)return!1;if(void 0!==t.location.length&&e.location.length!==t.location.length)return!1}return!0})),findMessages:(e,t)=>_.allMessages(e).filter((e=>{if(void 0!==t.severity&&e.severity!==t.severity)return!1;if(t.code&&e.code!==t.code)return!1;if(t.message){if(!("string"==typeof t.message?e.message.includes(t.message):t.message.test(e.message)))return!1}if(t.location){if(!e.location)return!1;if(e.location.offset!==t.location.offset)return!1;if(void 0!==t.location.length&&e.location.length!==t.location.length)return!1}return!0})),hasMessage:(e,t)=>void 0!==_.findMessage(e,t),hasMessages:e=>_.countMessages(e)>0,errors:e=>_.getMessages(e,L.Error),warnings:e=>_.getMessages(e,L.Warning),countErrors:e=>_.errors(e).length};class B extends Error{constructor(e,t,n,s=L.Error){super(e),this.name=this.constructor.name,this.code=t,this.location=n,this.severity=s,Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)}toString(){const e=this.severity===L.Error?"Error":"Warning",t=`[${this.code}]`;return this.location?`${e} ${t}: ${this.message} at offset ${this.location.offset}`:`${e} ${t}: ${this.message}`}}class R extends B{constructor(e,t,n){super(e,"PARSE_ERROR",t),this.expected=n}}const V="<pending>";function z(e){return function(e,t){const n=e.parse(t);if(n.status)return _.ok(n.value);{const e={offset:n.index.offset,length:1};let t=`Parse error at line ${n.index.line}, column ${n.index.column}`;if(n.expected&&n.expected.length>0)for(const o of n.expected)if(o&&(o.includes("exceeds maximum safe integer")||o.includes("must be positive")||o.includes("must be non-negative")||o.includes("must be an integer")||o.includes("Cannot use keyword"))){t=o;break}const s=new R(t,e,n.expected);return _.err(s)}}(Re,e)}const F=P.alt(P.regexp(/\/\/[^\n]*/),P.regexp(/\/\*[^]*?\*\//)),H=P.alt(P.whitespace,F),q=H.many().result(void 0),W=H.atLeast(1).result(void 0),K=e=>e.skip(q),Y=e=>K(P.string(e).notFollowedBy(P.regexp(/[a-zA-Z0-9_]/)).desc(`keyword '${e}'`)),G=e=>K(P.string(e)),J={_:q,__:W,comment:F,lexeme:K,keyword:Y,operator:e=>P.string(e).desc(`operator '${e}'`),token:G,lparen:G("("),rparen:G(")"),lbracket:G("["),rbracket:G("]"),lbrace:G("{"),rbrace:G("}"),semicolon:G(";"),comma:G(","),colon:G(":"),dot:G("."),equals:G("="),arrow:G("->"),plus:G("+"),minus:G("-"),multiply:G("*"),divide:G("/"),lt:G("<"),gt:G(">"),lte:G("<="),gte:G(">="),eq:G("=="),neq:G("!="),and:G("&&"),or:G("||"),not:G("!"),as:G("as"),identifier:K(P.regexp(/[a-zA-Z_][a-zA-Z0-9_]*/).chain((e=>["let","if","else","for","while","return","break","continue","struct","mapping","array","function","storage","code","create","define","msg","true","false","wei","finney","ether","as","uint256","uint128","uint64","uint32","uint16","uint8","int256","int128","int64","int32","int16","int8","address","bool","bytes32","bytes16","bytes8","bytes4","bytes","string"].includes(e)?P.fail(`Cannot use keyword '${e}' as identifier`):P.succeed(e)))),number:K(P.regexp(/0x[0-9a-fA-F]+|[0-9]+/).desc("number").map((e=>(e.startsWith("0x"),BigInt(e))))),string:K(P.regexp(/"([^"\\\n\r]|\\[ntr"\\])*"/).desc("string literal").map((e=>e.slice(1,-1).replace(/\\n/g,"\n").replace(/\\t/g,"\t").replace(/\\r/g,"\r").replace(/\\\\/g,"\\").replace(/\\"/g,'"')))),boolean:K(P.alt(P.string("true").result(!0),P.string("false").result(!1)).desc("boolean literal")),address:K(P.regexp(/0x[0-9a-fA-F]{40}/).notFollowedBy(P.regexp(/[0-9a-fA-F]/)).desc("address literal")),weiUnit:P.alt(Y("ether"),Y("finney"),Y("wei")),elementaryType:P.alt(Y("uint256"),Y("uint128"),Y("uint64"),Y("uint32"),Y("uint16"),Y("uint8"),Y("int256"),Y("int128"),Y("int64"),Y("int32"),Y("int16"),Y("int8"),Y("address"),Y("bool"),Y("bytes32"),Y("bytes16"),Y("bytes8"),Y("bytes4"),Y("bytes"),Y("string")),reservedWord:P.alt(Y("let"),Y("if"),Y("else"),Y("for"),Y("while"),Y("return"),Y("break"),Y("continue"),Y("struct"),Y("mapping"),Y("array"),Y("function"),Y("name"),Y("storage"),Y("code"),Y("msg"),Y("true"),Y("false"))};function Z(e){return e.mark().map((e=>{const t=function(e){return{offset:e.start.offset,length:e.end.offset-e.start.offset}}(e),n=`${t.offset}_${t.length}`;return{...e.value,id:n,loc:t}}))}let X,Q,ee;const te=Z(J.elementaryType.map((e=>{if(e.startsWith("uint")){const t=parseInt(e.substring(4),10);return u.Elementary.uint(V,t)}if(e.startsWith("int")){const t=parseInt(e.substring(3),10);return u.Elementary.int(V,t)}if(e.startsWith("bytes")&&"bytes"!==e){const t=parseInt(e.substring(5),10);return u.Elementary.bytes(V,t)}if("address"===e)return u.Elementary.address(V);if("bool"===e)return u.Elementary.bool(V);if("string"===e)return u.Elementary.string(V);if("bytes"===e)return u.Elementary.bytes(V);throw new Error(`Unknown elementary type: ${e}`)}))),ne=Z(J.identifier.map((e=>u.reference(V,e)))),se=P.lazy((()=>Z(P.seq(J.keyword("array"),J.lt,X,P.seq(J.comma,ie).map((([e,t])=>t)).fallback(null),J.gt).chain((([e,t,n,s,o])=>{if(s){const e=Number(s);if(e>Number.MAX_SAFE_INTEGER)return P.fail(`Array size ${s} exceeds maximum safe integer (${Number.MAX_SAFE_INTEGER})`);if(e<=0)return P.fail(`Array size must be positive, got ${e}`)}return P.succeed(u.Complex.array(V,n,s?Number(s):void 0))}))))),oe=P.lazy((()=>Z(P.seq(J.keyword("mapping"),J.lt,X,J.comma,X,J.gt).map((([e,t,n,s,o,r])=>u.Complex.mapping(V,n,o))))));X=P.alt(se,oe,te,ne);const re=Z(J.identifier.map((e=>f.identifier(V,e)))),ie=J.lexeme(P.regexp(/[0-9]+/).desc("number")),ae=J.lexeme(P.regexp(/0x[0-9a-fA-F]+/).desc("hex literal")),ce=Z(ie.map((e=>f.Literal.number(V,e)))),le=Z(ae.map((e=>f.Literal.hex(V,e)))),ue=Z(P.alt(J.keyword("true"),J.keyword("false")).map((e=>f.Literal.boolean(V,e)))),de=Z(J.string.map((e=>f.Literal.string(V,e)))),pe=Z(P.regex(/0x[0-9a-fA-F]{40}/).desc("address literal").notFollowedBy(P.regex(/[0-9a-fA-F]/)).map((e=>f.Literal.address(V,e.toLowerCase())))),me=Z(P.seq(ie,J._,P.alt(J.keyword("wei"),J.keyword("finney"),J.keyword("ether"))).map((([e,t,n])=>f.Literal.number(V,e,n)))),fe=Z(P.seq(J.keyword("msg"),J.dot,P.alt(J.keyword("sender"),J.keyword("value"),J.keyword("data"))).map((([e,t,n])=>{const s="sender"===n?"msg.sender":"value"===n?"msg.value":"msg.data";return"msg.sender"===s?f.Special.msgSender(V):"msg.value"===s?f.Special.msgValue(V):f.Special.msgData(V)}))),he=Z(P.seq(J.keyword("block"),J.dot,P.alt(J.keyword("timestamp"),J.keyword("number"))).map((([e,t,n])=>"block.timestamp"===("timestamp"===n?"block.timestamp":"block.number")?f.Special.blockTimestamp(V):f.Special.blockNumber(V)))),ge=P.lazy((()=>P.seq(J.lbracket,P.sepBy(Q,J.comma),J.rbracket).map((([e,t,n])=>f.array(V,t))))),ye=P.lazy((()=>{const e=P.seq(J.identifier,J.colon,Q).map((([e,t,n])=>({name:e,value:n})));return P.seq(J.identifier,J.lbrace,P.sepBy(e,J.comma),J.rbrace).map((([e,t,n,s])=>f.struct(V,n,e)))})),be=P.lazy((()=>P.alt(me,pe,le,ce,ue,de,ge,ye,fe,he,re,J.lparen.then(Q).skip(J.rparen)))),ke=P.lazy((()=>{const e=P.seq(J.dot,J.identifier).map((([e,t])=>({type:"member",property:t}))),t=P.seq(J.lbracket,Q,P.seq(J.colon,Q).or(P.succeed(null)),J.rbracket).map((([e,t,n,s])=>n?{type:"slice",property:t,end:n[1]}:{type:"index",property:t})),n=P.seq(J.lparen,P.sepBy(Q,J.comma),J.rparen).map((([e,t,n])=>({type:"call",arguments:t}))),s=P.seq(J.as,X).map((([e,t])=>({type:"cast",targetType:t}))),o=P.alt(e,t,n,s),r=P.seq(be,o.many()).map((([e,t])=>t.reduce(((e,t)=>"member"===t.type?Z(P.succeed(f.Access.member(V,e,t.property))).tryParse(""):"slice"===t.type?Z(P.succeed(f.Access.slice(V,e,t.property,t.end))).tryParse(""):"call"===t.type?Z(P.succeed(f.call(V,e,t.arguments))).tryParse(""):"cast"===t.type?Z(P.succeed(f.cast(V,e,t.targetType))).tryParse(""):Z(P.succeed(f.Access.index(V,e,t.property))).tryParse("")),e)));return Z(r)})),ve=P.lazy((()=>P.alt(Z(P.seq(P.alt(J.not,J.minus),ve).map((([e,t])=>f.operator(V,e,[t])))),ke))),xe=[["||"],["&&"],["==","!="],["<",">","<=",">="],["+","-"],["*","/"]];Q=function e(t,n){if(t>=xe.length)return n;const s=[...xe[t]].sort(((e,t)=>t.length-e.length)).map((e=>J._.then(P.string(e)).skip(J._)));return P.lazy((()=>Z(P.seq(e(t+1,n),P.seq(P.alt(...s),e(t+1,n)).many()).map((([e,t])=>t.reduce(((e,[t,n])=>{const s=e.loc&&n.loc&&{offset:e.loc.offset,length:Number(n.loc.offset)+Number(n.loc.length)-Number(e.loc.offset)};return f.operator(V,t,[e,n],s||void 0)}),e))))))}(0,ve);const we=Z(P.seq(J.keyword("let"),Z(P.seq(J.identifier,P.seq(J.colon,X).map((([e,t])=>t)).fallback(void 0),J.equals,Q).map((([e,t,n,s])=>c.variable(V,e,t,s)))),J.semicolon).map((([e,t,n])=>p.declare(V,t)))),Te=P.lazy((()=>Z(P.seq(Q,J.equals,Q,J.semicolon).map((([e,t,n,s])=>p.assign(V,e,n)))))),Ee=Z(P.seq(Q,J.semicolon).map((([e,t])=>p.express(V,e)))),Se=Z(P.seq(J.keyword("return"),Q.fallback(null),J.semicolon).map((([e,t,n])=>p.ControlFlow.return_(V,t||void 0)))),Ne=Z(P.seq(J.keyword("break"),J.semicolon).map((()=>p.ControlFlow.break_(V)))),Ae=Z(P.lazy((()=>P.seq(J.lbrace,ee.many(),J.rbrace).map((([e,t,n])=>l.statements(V,t)))))),je=P.lazy((()=>Z(P.seq(J.keyword("if"),J.lparen,Q,J.rparen,Ae,P.seq(J.keyword("else"),Ae).map((([e,t])=>t)).fallback(void 0)).map((([e,t,n,s,o,r])=>p.ControlFlow.if_(V,n,o,r)))))),Ie=P.lazy((()=>Z(P.seq(J.keyword("for"),J.lparen,we,Q,J.semicolon,Z(P.seq(Q,J.equals,Q).map((([e,t,n])=>p.assign(V,e,n)))),J.rparen,Ae).map((e=>{const t=e[2],n=e[3],s=e[5],o=e[7];return p.ControlFlow.for_(V,o,t,n,s)})))));ee=P.alt(we,je,Ie,Se,Ne,Te,Ee);const De=Z(P.seq(J.identifier,J.colon,X).map((([e,t,n])=>c.field(V,e,n)))),$e=Z(P.seq(J.keyword("struct"),J.identifier,J.lbrace,De.sepBy(J.semicolon).skip(J.semicolon.or(P.succeed(null))),J.rbrace).map((([e,t,n,s,o])=>c.struct(V,t,s)))),Me=Z(P.seq(J.identifier,J.colon,X).map((([e,t,n])=>c.parameter(V,e,n)))),Ce=P.lazy((()=>Z(P.seq(J.keyword("function"),J.identifier,J.lparen,Me.sepBy(J.comma),J.rparen,P.seq(J.arrow,X).map((([e,t])=>t)).fallback(void 0),Ae).map((([e,t,n,s,o,r,i])=>c.function_(V,t,s,r,i)))))),Oe=Z(P.seq(J.lbracket,ie,J.rbracket,J.identifier,J.colon,X).chain((([e,t,n,s,o,r])=>{const i=Number(t);return i>Number.MAX_SAFE_INTEGER?P.fail(`Storage slot ${t} exceeds maximum safe integer (${Number.MAX_SAFE_INTEGER})`):i<0?P.fail(`Storage slot must be non-negative, got ${i}`):Number.isInteger(i)?P.succeed(c.storage(V,s,r,i)):P.fail(`Storage slot must be an integer, got ${i}`)}))),Ue=Z(P.seq(J.keyword("define"),J.lbrace,P.alt(P.alt($e,Ce).skip(J.semicolon).atLeast(1),P.succeed([])),J.rbrace).map((([e,t,n,s])=>l.definitions(V,n)))),Le=P.seq(J.keyword("storage"),J.lbrace,P.alt(Oe.skip(J.semicolon).atLeast(1),P.succeed([])),J.rbrace).map((([e,t,n,s])=>n)),Pe=Z(P.seq(J.keyword("create"),J.lbrace,ee.many(),J.rbrace).map((([e,t,n,s])=>l.statements(V,n)))),_e=Z(P.seq(J.keyword("code"),J.lbrace,ee.many(),J.rbrace).map((([e,t,n,s])=>l.statements(V,n)))),Be=Z(P.seq(J.keyword("name"),J.identifier,J.semicolon,Ue.or(P.succeed(null)),Le.or(P.succeed([])),Pe.or(P.succeed(null)),_e.or(P.succeed(null))).map((([e,t,n,s,o,r,i])=>function(e,t,n,s,o,r,i){return{id:e,kind:"program",name:t,storage:n,definitions:s,body:o,create:r,loc:i??null}}(V,t,o,s||void 0,i||void 0,r||void 0)))),Re=P.seq(J._,Be,J._).map((([e,t,n])=>t));var Ve;!function(e){e.TYPE_MISMATCH="TYPE001",e.UNDEFINED_VARIABLE="TYPE002",e.UNDEFINED_TYPE="TYPE003",e.INVALID_OPERATION="TYPE004",e.MISSING_INITIALIZER="TYPE005",e.INVALID_ASSIGNMENT="TYPE006",e.INVALID_CONDITION="TYPE007",e.INVALID_OPERAND="TYPE008",e.NO_SUCH_FIELD="TYPE009",e.INVALID_INDEX_TYPE="TYPE010",e.NOT_INDEXABLE="TYPE011",e.INVALID_ARGUMENT_COUNT="TYPE012",e.INVALID_TYPE_CAST="TYPE013",e.INTERNAL_ERROR="TYPE014",e.GENERAL="TYPE_ERROR"}(Ve||(Ve={}));const ze=(e,t)=>`Type mismatch: expected ${e}, got ${t}`,Fe=e=>`Undefined variable: ${e}`,He=e=>`Undefined type: ${e}`,qe=(e,t)=>`Operator ${e} requires ${t} operand`,We=(e,t)=>`Operator ${e} requires ${t} operands`,Ke=(e,t)=>`Struct ${e} has no field ${t}`,Ye=e=>`Cannot index ${e}`;class Ge extends B{constructor(e,t,n,s,o=Ve.GENERAL){super(e,o,t),this.expectedType=n,this.actualType=s}}function Je(e){switch(e.kind){case"string":case"array":case"mapping":case"struct":return!0;case"bytes":return void 0===e.size;default:return!1}}function Ze(e){switch(e.kind){case"bool":return 1;case"uint":case"int":return Math.ceil(e.bits/8);case"address":return 20;case"bytes":return e.size||32;default:return 32}}function Xe(e,t){const n=new Map;for(const o of e.fields)if(c.isField(o)&&o.type){const e=tt(o.type,t);n.set(o.name,e)}const s=function(e){const t=new Map;let n=0,s=0;const o=32;for(const[r,i]of e){const e=Ze(i);Je(i)?(s>0&&(n+=o,s=0),t.set(r,{byteOffset:n,size:o}),n+=o,s=0):(s+e>o&&(n+=o,s=0),t.set(r,{byteOffset:n+s,size:e}),s+=e,s>=o&&(n+=o,s=0))}return t}(n);return k.struct(e.name,n,s)}function Qe(e,t){const n=[];for(const o of e.parameters){const e=tt(o.type,t);n.push(e)}const s=e.returnType?tt(e.returnType,t):null;return k.function_(n,s,e.name)}function et(e,t,n){if(u.isElementary(e)){if(u.Elementary.isUint(e)){return{type:{256:k.Elementary.uint(256),128:k.Elementary.uint(128),64:k.Elementary.uint(64),32:k.Elementary.uint(32),16:k.Elementary.uint(16),8:k.Elementary.uint(8)}[e.bits||256]||k.failure(`Unknown uint size: ${e.bits}`),bindings:n}}if(u.Elementary.isInt(e)){return{type:{256:k.Elementary.int(256),128:k.Elementary.int(128),64:k.Elementary.int(64),32:k.Elementary.int(32),16:k.Elementary.int(16),8:k.Elementary.int(8)}[e.bits||256]||k.failure(`Unknown int size: ${e.bits}`),bindings:n}}if(u.Elementary.isBytes(e)){if(!e.size)return{type:k.Elementary.bytes(),bindings:n};return[4,8,16,32].includes(e.size)?{type:k.Elementary.bytes(e.size),bindings:n}:{type:k.failure(`Unknown bytes size: ${e.size}`),bindings:n}}return u.Elementary.isAddress(e)?{type:k.Elementary.address(),bindings:n}:u.Elementary.isBool(e)?{type:k.Elementary.bool(),bindings:n}:u.Elementary.isString(e)?{type:k.Elementary.string(),bindings:n}:{type:k.failure(`Unknown elementary type: ${e.kind}`),bindings:n}}if(u.isComplex(e)){if(u.Complex.isArray(e)){const s=et(e.element,t,n);return{type:k.array(s.type,e.size),bindings:s.bindings}}if(u.Complex.isMapping(e)){const s=et(e.key,t,n),o=et(e.value,t,s.bindings);return{type:k.mapping(s.type,o.type),bindings:o.bindings}}return{type:k.failure(`Unsupported complex type: ${e.kind}`),bindings:n}}if(u.isReference(e)){const s=t.get(e.name);if(!s)throw new Ge(He(e.name),e.loc||void 0,void 0,void 0,Ve.UNDEFINED_TYPE);const o=N(n,e.id,s.node);return{type:s.type,bindings:o}}return{type:k.failure("Unknown type"),bindings:n}}function tt(e,t){if(u.isElementary(e)){if(u.Elementary.isUint(e)){return{256:k.Elementary.uint(256),128:k.Elementary.uint(128),64:k.Elementary.uint(64),32:k.Elementary.uint(32),16:k.Elementary.uint(16),8:k.Elementary.uint(8)}[e.bits||256]||k.failure(`Unknown uint size: ${e.bits}`)}if(u.Elementary.isInt(e)){return{256:k.Elementary.int(256),128:k.Elementary.int(128),64:k.Elementary.int(64),32:k.Elementary.int(32),16:k.Elementary.int(16),8:k.Elementary.int(8)}[e.bits||256]||k.failure(`Unknown int size: ${e.bits}`)}if(u.Elementary.isBytes(e)){if(!e.size)return k.Elementary.bytes();return[4,8,16,32].includes(e.size)?k.Elementary.bytes(e.size):k.failure(`Unknown bytes size: ${e.size}`)}return u.Elementary.isAddress(e)?k.Elementary.address():u.Elementary.isBool(e)?k.Elementary.bool():u.Elementary.isString(e)?k.Elementary.string():k.failure(`Unknown elementary type: ${e.kind}`)}if(u.isComplex(e)){if(u.Complex.isArray(e)){const n=tt(e.element,t);return k.array(n,e.size)}if(u.Complex.isMapping(e)){const n=tt(e.key,t),s=tt(e.value,t);return k.mapping(n,s)}return k.failure(`Unsupported complex type: ${e.kind}`)}if(u.isReference(e)){const n=t.get(e.name);if(!n)throw new Ge(He(e.name),e.loc||void 0,void 0,void 0,Ve.UNDEFINED_TYPE);return n.type}return k.failure("Unknown type")}class nt{constructor(e=[new Map]){this.scopes=e}static empty(){return new nt}enterScope(){return new nt([...this.scopes,new Map])}exitScope(){return this.scopes.length<=1?this:new nt(this.scopes.slice(0,-1))}define(e){const t=[...this.scopes],n=new Map(t[t.length-1]);return n.set(e.name,e),t[t.length-1]=n,new nt(t)}lookup(e){for(let t=this.scopes.length-1;t>=0;t--){const n=this.scopes[t].get(e);if(n)return n}}isDefined(e){return void 0!==this.lookup(e)}isDefinedInCurrentScope(e){return this.scopes[this.scopes.length-1].has(e)}}function st(e,t,n){let s=e.enterScope();const o=t.parameters;for(let r=0;r<o.length;r++){const e=o[r],t={name:e.name,type:n.parameters[r],mutable:!0,location:"memory",declaration:e};s=s.define(t)}return s}function ot(e,t){if(k.isFailure(e)||k.isFailure(t))return!0;if(k.equals(e,t))return!0;if(k.isElementary(e)&&k.isElementary(t)&&k.Elementary.isNumeric(e)&&k.Elementary.isNumeric(t)){if(k.Elementary.isUint(e)&&k.Elementary.isUint(t))return!0;if(k.Elementary.isInt(e)&&k.Elementary.isInt(t))return!0}return!1}function rt(e,t){if(k.equals(e,t))return e;if(k.isElementary(e)&&k.isElementary(t)){if(k.Elementary.isUint(e)&&k.Elementary.isUint(t)){return(e.bits||256)>=(t.bits||256)?e:t}if(k.Elementary.isInt(e)&&k.Elementary.isInt(t)){return(e.bits||256)>=(t.bits||256)?e:t}}return null}const it={expression(e,t){if(f.isIdentifier(e)){const n=[],s=new Map(t.nodeTypes);let o=t.bindings;const r=t.symbols.lookup(e.name);if(!r){const r=new Ge(Fe(e.name),e.loc||void 0,void 0,void 0,Ve.UNDEFINED_VARIABLE);return n.push(r),{type:void 0,symbols:t.symbols,nodeTypes:s,bindings:o,errors:n}}return s.set(e.id,r.type),o=N(o,e.id,r.declaration),{type:r.type,symbols:t.symbols,nodeTypes:s,bindings:o,errors:n}}if(f.isLiteral(e)){const n=new Map(t.nodeTypes);let s;switch(e.kind){case"expression:literal:number":s=k.Elementary.uint(256);break;case"expression:literal:boolean":s=k.Elementary.bool();break;case"expression:literal:string":s=k.Elementary.string();break;case"expression:literal:address":s=k.Elementary.address();break;case"expression:literal:hex":{const t=e.value.startsWith("0x")?e.value.slice(2):e.value,n=Math.ceil(t.length/2);s=n>0&&n<=32?k.Elementary.bytes(n):k.Elementary.bytes();break}}return s&&n.set(e.id,s),{type:s,symbols:t.symbols,nodeTypes:n,bindings:t.bindings,errors:[]}}if(f.isOperator(e)){const n=[];let s=new Map(t.nodeTypes),o=t.symbols,r=t.bindings;const i=[];for(let c=0;c<e.operands.length;c++){const a={...t,nodeTypes:s,symbols:o,bindings:r},l=g(t.visitor,e.operands[c],a);s=l.nodeTypes,o=l.symbols,r=l.bindings,n.push(...l.errors),l.type&&i.push(l.type)}if(i.length!==e.operands.length)return{symbols:o,nodeTypes:s,bindings:r,errors:n};let a;if(1===e.operands.length){const t=i[0];switch(e.operator){case"!":if(!k.Elementary.isBool(t)){const t=new Ge(qe("!","boolean"),e.loc||void 0,void 0,void 0,Ve.INVALID_OPERAND);n.push(t)}a=k.Elementary.bool();break;case"-":if(!k.isElementary(t)||!k.Elementary.isNumeric(t)){const t=new Ge(qe("-","numeric"),e.loc||void 0,void 0,void 0,Ve.INVALID_OPERAND);n.push(t)}a=t;break;default:{const t=new Ge(`Unknown unary operator: ${e.operator}`,e.loc||void 0,void 0,void 0,Ve.INVALID_OPERATION);n.push(t);break}}}else if(2===e.operands.length){const[t,s]=i;switch(e.operator){case"+":case"-":case"*":case"/":if(!(k.isElementary(t)&&k.isElementary(s)&&k.Elementary.isNumeric(t)&&k.Elementary.isNumeric(s))){const t=new Ge(We(e.operator,"numeric"),e.loc||void 0,void 0,void 0,Ve.INVALID_OPERAND);n.push(t)}a=rt(t,s)||void 0;break;case"<":case">":case"<=":case">=":if(!(k.isElementary(t)&&k.isElementary(s)&&k.Elementary.isNumeric(t)&&k.Elementary.isNumeric(s))){const t=new Ge(We(e.operator,"numeric"),e.loc||void 0,void 0,void 0,Ve.INVALID_OPERAND);n.push(t)}a=k.Elementary.bool();break;case"==":case"!=":if(!ot(t,s)){const o=new Ge(`Cannot compare ${k.format(t)} with ${k.format(s)}`,e.loc||void 0,void 0,void 0,Ve.INVALID_OPERATION);n.push(o)}a=k.Elementary.bool();break;case"&&":case"||":if(!k.Elementary.isBool(t)||!k.Elementary.isBool(s)){const t=new Ge(We(e.operator,"boolean"),e.loc||void 0,void 0,void 0,Ve.INVALID_OPERAND);n.push(t)}a=k.Elementary.bool();break;default:{const t=new Ge(`Unknown binary operator: ${e.operator}`,e.loc||void 0,void 0,void 0,Ve.INVALID_OPERATION);n.push(t);break}}}else!function(e){throw new Ge("Unexpected code path; expected exhaustive conditionals",void 0,L.Error,Ve.INTERNAL_ERROR)}(e.operands);return a&&s.set(e.id,a),{type:a,symbols:o,nodeTypes:s,bindings:r,errors:n}}if(f.isAccess(e)){const n=[];let s=new Map(t.nodeTypes),o=t.symbols,r=t.bindings;const i={...t,nodeTypes:s,symbols:o,bindings:r},a=g(t.visitor,e.object,i);if(s=a.nodeTypes,o=a.symbols,r=a.bindings,n.push(...a.errors),!a.type)return{symbols:o,nodeTypes:s,bindings:r,errors:n};const c=a.type;let l;if(f.Access.isMember(e)){const t=e.property;if(k.isStruct(c)){const i=c.fields.get(t);if(!i){const i=new Ge(Ke(c.name,t),e.loc||void 0,void 0,void 0,Ve.NO_SUCH_FIELD);return n.push(i),{symbols:o,nodeTypes:s,bindings:r,errors:n}}l=i}else{if("length"!==t){const i=new Ge(`Cannot access member ${t} on ${k.format(c)}`,e.loc||void 0,void 0,void 0,Ve.INVALID_OPERATION);return n.push(i),{symbols:o,nodeTypes:s,bindings:r,errors:n}}if(k.isArray(c))l=k.Elementary.uint(256);else{if(!k.isElementary(c)||!k.Elementary.isBytes(c)&&!k.Elementary.isString(c)){const t=new Ge(`Type ${k.format(c)} does not have a length property`,e.loc||void 0,void 0,void 0,Ve.INVALID_OPERATION);return n.push(t),{symbols:o,nodeTypes:s,bindings:r,errors:n}}l=k.Elementary.uint(256)}}}else if(f.Access.isSlice(e)){const i=e.start,a=e.end,u={...t,nodeTypes:s,symbols:o,bindings:r},d=g(t.visitor,i,u);s=d.nodeTypes,o=d.symbols,r=d.bindings,n.push(...d.errors);const p={...t,nodeTypes:s,symbols:o,bindings:r},m=g(t.visitor,a,p);if(s=m.nodeTypes,o=m.symbols,r=m.bindings,n.push(...m.errors),!d.type||!m.type)return{symbols:o,nodeTypes:s,bindings:r,errors:n};if(!k.isElementary(c)||!k.Elementary.isBytes(c)){const t=new Ge(`Cannot slice ${k.format(c)} - only bytes types can be sliced`,e.loc||void 0,void 0,void 0,Ve.INVALID_OPERATION);return n.push(t),{symbols:o,nodeTypes:s,bindings:r,errors:n}}if(!k.isElementary(d.type)||!k.Elementary.isNumeric(d.type)){const e=new Ge("Slice start index must be numeric",i.loc||void 0,void 0,void 0,Ve.INVALID_INDEX_TYPE);n.push(e)}if(!k.isElementary(m.type)||!k.Elementary.isNumeric(m.type)){const e=new Ge("Slice end index must be numeric",a.loc||void 0,void 0,void 0,Ve.INVALID_INDEX_TYPE);n.push(e)}l=k.Elementary.bytes()}else{const i=e.index,a={...t,nodeTypes:s,symbols:o,bindings:r},u=g(t.visitor,i,a);if(s=u.nodeTypes,o=u.symbols,r=u.bindings,n.push(...u.errors),!u.type)return{symbols:o,nodeTypes:s,bindings:r,errors:n};const d=u.type;if(k.isArray(c)){if(!k.isElementary(d)||!k.Elementary.isNumeric(d)){const e=new Ge("Array index must be numeric",i.loc||void 0,void 0,void 0,Ve.INVALID_INDEX_TYPE);n.push(e)}l=c.element}else if(k.isMapping(c)){if(!ot(c.key,d)){const e=new Ge(`Invalid mapping key: expected ${k.format(c.key)}, got ${k.format(d)}`,i.loc||void 0,void 0,void 0,Ve.TYPE_MISMATCH);n.push(e)}l=c.value}else{if(!k.isElementary(c)||!k.Elementary.isBytes(c)){const t=new Ge(Ye(k.format(c)),e.loc||void 0,void 0,void 0,Ve.NOT_INDEXABLE);return n.push(t),{symbols:o,nodeTypes:s,bindings:r,errors:n}}if(!ot(k.Elementary.uint(8),d)){const e=new Ge(`Bytes index must be a numeric type, got ${k.format(d)}`,i.loc||void 0,void 0,void 0,Ve.TYPE_MISMATCH);n.push(e)}l=k.Elementary.uint(8)}}return l&&s.set(e.id,l),{type:l,symbols:o,nodeTypes:s,bindings:r,errors:n}}if(f.isCall(e)){const n=[];let s=new Map(t.nodeTypes),o=t.symbols,r=t.bindings;if("expression:identifier"===e.callee.kind){const i=e.callee.name;if("keccak256"===i){if(1!==e.arguments.length){const t=new Ge("keccak256 expects exactly 1 argument",e.loc||void 0,void 0,void 0,Ve.INVALID_ARGUMENT_COUNT);return n.push(t),{symbols:o,nodeTypes:s,bindings:r,errors:n}}const i={...t,nodeTypes:s,symbols:o,bindings:r},a=g(t.visitor,e.arguments[0],i);if(s=a.nodeTypes,o=a.symbols,r=a.bindings,n.push(...a.errors),!a.type)return{symbols:o,nodeTypes:s,bindings:r,errors:n};if(!k.Elementary.isBytes(a.type)&&!k.Elementary.isString(a.type)){const t=new Ge("keccak256 argument must be bytes or string type",e.arguments[0].loc||void 0,void 0,void 0,Ve.TYPE_MISMATCH);return n.push(t),{symbols:o,nodeTypes:s,bindings:r,errors:n}}const c=k.Elementary.bytes(32);return s.set(e.id,c),{type:c,symbols:o,nodeTypes:s,bindings:r,errors:n}}const a=o.lookup(i);if(!a){const t=new Ge(Fe(i),e.callee.loc||void 0,void 0,void 0,Ve.UNDEFINED_VARIABLE);return n.push(t),{symbols:o,nodeTypes:s,bindings:r,errors:n}}if(r=N(r,e.callee.id,a.declaration),!k.isFunction(a.type)){const t=new Ge(`${i} is not a function`,e.callee.loc||void 0,void 0,void 0,Ve.TYPE_MISMATCH);return n.push(t),{symbols:o,nodeTypes:s,bindings:r,errors:n}}const c=a.type;if(e.arguments.length!==c.parameters.length){const t=new Ge(`Function ${c.name} expects ${c.parameters.length} arguments but got ${e.arguments.length}`,e.loc||void 0,void 0,void 0,Ve.INVALID_ARGUMENT_COUNT);return n.push(t),{symbols:o,nodeTypes:s,bindings:r,errors:n}}for(let u=0;u<e.arguments.length;u++){const i={...t,nodeTypes:s,symbols:o,bindings:r},a=g(t.visitor,e.arguments[u],i);if(s=a.nodeTypes,o=a.symbols,r=a.bindings,n.push(...a.errors),!a.type)continue;const l=c.parameters[u];if(!ot(l,a.type)){const t=new Ge(`Argument ${u+1} type mismatch: expected ${k.format(l)}, got ${k.format(a.type)}`,e.arguments[u].loc||void 0,k.format(l),k.format(a.type),Ve.TYPE_MISMATCH);n.push(t)}}const l=c.return||k.failure("void function");return s.set(e.id,l),{type:l,symbols:o,nodeTypes:s,bindings:r,errors:n}}const i=new Ge("Complex function call expressions not yet supported",e.loc||void 0,void 0,void 0,Ve.INVALID_OPERATION);return n.push(i),{symbols:o,nodeTypes:s,bindings:r,errors:n}}if(f.isCast(e)){const n=[];let s=new Map(t.nodeTypes),o=t.symbols,r=t.bindings;const i={...t,nodeTypes:s,symbols:o,bindings:r},a=g(t.visitor,e.expression,i);if(s=a.nodeTypes,o=a.symbols,r=a.bindings,n.push(...a.errors),!a.type)return{symbols:o,nodeTypes:s,bindings:r,errors:n};const c={...t,nodeTypes:s,symbols:o,bindings:r},l=g(t.visitor,e.targetType,c);if(s=l.nodeTypes,o=l.symbols,r=l.bindings,n.push(...l.errors),!l.type)return{symbols:o,nodeTypes:s,bindings:r,errors:n};if(!function(e,t){if(k.isElementary(e)&&k.isElementary(t)&&k.Elementary.isNumeric(e)&&k.Elementary.isNumeric(t))return!0;if(k.Elementary.isUint(e)&&k.Elementary.isAddress(t))return!0;if(k.Elementary.isAddress(e)&&k.Elementary.isUint(t))return!0;if(k.Elementary.isBytes(e)&&k.Elementary.isBytes(t))return!0;if(k.Elementary.isString(e)&&k.Elementary.isBytes(t))return!0;if(k.Elementary.isBytes(e)&&k.Elementary.isString(t))return!0;if(k.Elementary.isBytes(e)&&k.Elementary.isAddress(t))return!0;if(k.isElementary(e)&&k.isElementary(t)&&k.Elementary.isBytes(e)&&k.Elementary.isNumeric(t))return!0;return!1}(a.type,l.type)){const t=new Ge(`Cannot cast from ${k.format(a.type)} to ${k.format(l.type)}`,e.loc||void 0,k.format(l.type),k.format(a.type),Ve.INVALID_TYPE_CAST);return n.push(t),{symbols:o,nodeTypes:s,bindings:r,errors:n}}return s.set(e.id,l.type),{type:l.type,symbols:o,nodeTypes:s,bindings:r,errors:n}}if(f.isArray(e)){const n=[];let s=new Map(t.nodeTypes),o=t.symbols,r=t.bindings;const i=[];for(let l=0;l<e.elements.length;l++){const a={...t,nodeTypes:s,symbols:o,bindings:r},c=g(t.visitor,e.elements[l],a);s=c.nodeTypes,o=c.symbols,r=c.bindings,n.push(...c.errors),c.type&&i.push(c.type)}if(i.length!==e.elements.length)return{symbols:o,nodeTypes:s,bindings:r,errors:n};let a;if(i.length>0){a=i[0];for(let t=1;t<i.length;t++){const c=rt(a,i[t]);if(!c){const c=new Ge(`Array elements must have compatible types. Element at index ${t} has type ${k.format(i[t])} which is incompatible with ${k.format(a)}`,e.loc||void 0,void 0,void 0,Ve.TYPE_MISMATCH);return n.push(c),{symbols:o,nodeTypes:s,bindings:r,errors:n}}a=c}}else a=k.Elementary.uint(256);const c=k.array(a);return s.set(e.id,c),{type:c,symbols:o,nodeTypes:s,bindings:r,errors:n}}if(f.isStruct(e)){const n=[];let s,o=new Map(t.nodeTypes),r=t.symbols,i=t.bindings;if(e.structName){const t=r.lookup(e.structName);if(!t||!k.isStruct(t.type)){const t=new Ge(`${e.structName} is not a struct type`,e.loc||void 0,void 0,void 0,Ve.TYPE_MISMATCH);return n.push(t),{symbols:r,nodeTypes:o,bindings:i,errors:n}}s=t.type}const a=new Map;for(let c=0;c<e.fields.length;c++){const s=e.fields[c],l={...t,nodeTypes:o,symbols:r,bindings:i},u=g(t.visitor,s.value,l);if(o=u.nodeTypes,r=u.symbols,i=u.bindings,n.push(...u.errors),u.type)if(a.has(s.name)){const t=new Ge(`Duplicate field ${s.name} in struct literal`,e.loc||void 0,void 0,void 0,Ve.TYPE_MISMATCH);n.push(t)}else a.set(s.name,u.type)}if(s&&k.isStruct(s)){for(const[t,o]of s.fields){const s=a.get(t);if(s){if(!ot(o,s)){const r=new Ge(`Field ${t} type mismatch: expected ${k.format(o)}, got ${k.format(s)}`,e.loc||void 0,k.format(o),k.format(s),Ve.TYPE_MISMATCH);n.push(r)}}else{const s=new Ge(`Missing field ${t} in struct literal`,e.loc||void 0,void 0,void 0,Ve.TYPE_MISMATCH);n.push(s)}}for(const t of a.keys())if(!s.fields.has(t)){const s=new Ge(`Unknown field ${t} in struct literal`,e.loc||void 0,void 0,void 0,Ve.TYPE_MISMATCH);n.push(s)}return o.set(e.id,s),{type:s,symbols:r,nodeTypes:o,bindings:i,errors:n}}{const t=k.struct("anonymous",a,new Map);return o.set(e.id,t),{type:t,symbols:r,nodeTypes:o,bindings:i,errors:n}}}if(f.isSpecial(e)){let n;switch(e.kind){case"expression:special:msg.sender":n=k.Elementary.address();break;case"expression:special:msg.value":case"expression:special:block.timestamp":case"expression:special:block.number":n=k.Elementary.uint(256);break;case"expression:special:msg.data":n=k.Elementary.bytes()}const s=new Map(t.nodeTypes);return n&&s.set(e.id,n),{type:n,symbols:t.symbols,nodeTypes:s,bindings:t.bindings,errors:[]}}throw new Error("Unknown expression kind")}};const at=[it,{statement(e,t){if(p.isDeclare(e))return g(t.visitor,e.declaration,t);if(p.isExpress(e)){const n={...t};return g(t.visitor,e.expression,n)}if(p.isAssign(e)){const n=[];let s=new Map(t.nodeTypes),o=t.symbols,r=t.bindings;if(!f.isAssignable(e.target)){const t=new Ge("Invalid assignment target",e.target.loc||void 0,void 0,void 0,Ve.INVALID_ASSIGNMENT);return n.push(t),{symbols:o,nodeTypes:s,bindings:r,errors:n}}const i={...t,nodeTypes:s,symbols:o,bindings:r},a=g(t.visitor,e.target,i);s=a.nodeTypes,o=a.symbols,r=a.bindings,n.push(...a.errors);const c={...t,nodeTypes:s,symbols:o,bindings:r},l=g(t.visitor,e.value,c);if(s=l.nodeTypes,o=l.symbols,r=l.bindings,n.push(...l.errors),a.type&&l.type&&!ot(a.type,l.type)){const t=new Ge(ze(k.format(a.type),k.format(l.type)),e.loc||void 0,k.format(a.type),k.format(l.type),Ve.TYPE_MISMATCH);n.push(t)}return{symbols:o,nodeTypes:s,bindings:r,errors:n}}if(p.isControlFlow(e)){const n=[];let s=new Map(t.nodeTypes),o=t.symbols,r=t.bindings;switch(e.kind){case"statement:control-flow:if":if(e.condition){const i={...t,nodeTypes:s,symbols:o,bindings:r},a=g(t.visitor,e.condition,i);if(s=a.nodeTypes,o=a.symbols,r=a.bindings,n.push(...a.errors),a.type&&!k.Elementary.isBool(a.type)){const t=new Ge("If condition must be boolean",e.condition.loc||void 0,void 0,void 0,Ve.INVALID_CONDITION);n.push(t)}}if(e.body){const i={...t,nodeTypes:s,symbols:o,bindings:r},a=g(t.visitor,e.body,i);s=a.nodeTypes,o=a.symbols,r=a.bindings,n.push(...a.errors)}if(e.alternate){const i={...t,nodeTypes:s,symbols:o,bindings:r},a=g(t.visitor,e.alternate,i);s=a.nodeTypes,o=a.symbols,r=a.bindings,n.push(...a.errors)}return{symbols:o,nodeTypes:s,bindings:r,errors:n};case"statement:control-flow:for":if(o=o.enterScope(),e.init){const i={...t,nodeTypes:s,symbols:o,bindings:r},a=g(t.visitor,e.init,i);s=a.nodeTypes,o=a.symbols,r=a.bindings,n.push(...a.errors)}if(e.condition){const i={...t,nodeTypes:s,symbols:o,bindings:r},a=g(t.visitor,e.condition,i);if(s=a.nodeTypes,o=a.symbols,r=a.bindings,n.push(...a.errors),a.type&&!k.Elementary.isBool(a.type)){const t=new Ge("For condition must be boolean",e.condition.loc||void 0,void 0,void 0,Ve.INVALID_CONDITION);n.push(t)}}if(e.update){const i={...t,nodeTypes:s,symbols:o,bindings:r},a=g(t.visitor,e.update,i);s=a.nodeTypes,o=a.symbols,r=a.bindings,n.push(...a.errors)}if(e.body){const i={...t,nodeTypes:s,symbols:o,bindings:r},a=g(t.visitor,e.body,i);s=a.nodeTypes,o=a.symbols,r=a.bindings,n.push(...a.errors)}return o=o.exitScope(),{symbols:o,nodeTypes:s,bindings:r,errors:n};case"statement:control-flow:return":if(e.value){const i={...t,nodeTypes:s,symbols:o,bindings:r},a=g(t.visitor,e.value,i);if(s=a.nodeTypes,o=a.symbols,r=a.bindings,n.push(...a.errors),a.type&&t.currentReturnType){if(!ot(t.currentReturnType,a.type)){const s=new Ge(ze(k.format(t.currentReturnType),k.format(a.type)),e.loc||void 0,k.format(t.currentReturnType),k.format(a.type),Ve.TYPE_MISMATCH);n.push(s)}}else if(a.type&&!t.currentReturnType){const t=new Ge("Cannot return a value from a void function",e.loc||void 0,void 0,void 0,Ve.TYPE_MISMATCH);n.push(t)}}else if(t.currentReturnType){const s=new Ge(`Function must return a value of type ${k.format(t.currentReturnType)}`,e.loc||void 0,void 0,void 0,Ve.TYPE_MISMATCH);n.push(s)}return{symbols:o,nodeTypes:s,bindings:r,errors:n};default:return{symbols:o,nodeTypes:s,bindings:r,errors:n}}}throw new Error("Unexpected statement")}},{program(e,t){let n=t.symbols,s=t.nodeTypes,o=t.bindings;const r=[];if(e.storage)for(const i of e.storage){const e={...t,symbols:n,nodeTypes:s,bindings:o,visitor:t.visitor},a=g(e.visitor,i,e);s=a.nodeTypes,o=a.bindings,r.push(...a.errors)}if(e.definitions){for(let i=0;i<e.definitions.items.length;i++){const a=e.definitions.items[i];if("declaration:function"===a.kind||"declaration:struct"===a.kind){const e={...t,symbols:n,nodeTypes:s,bindings:o,visitor:t.visitor},i=g(e.visitor,a,e);if(s=i.nodeTypes,o=i.bindings,r.push(...i.errors),"declaration:struct"===a.kind)for(const t of a.fields){const n=g(e.visitor,t,{...e,bindings:o});o=n.bindings,r.push(...n.errors)}}}for(let i=0;i<e.definitions.items.length;i++){const a=e.definitions.items[i];if(c.isFunction(a)){const e=n.lookup(a.name)?.type;if(e){const i=st(n,a,e),c={...t,symbols:i,currentReturnType:e.return||void 0,nodeTypes:s,bindings:o,visitor:t.visitor},l=g(c.visitor,a.body,c);s=l.nodeTypes,o=l.bindings,r.push(...l.errors)}}}}if(e.create){const i={...t,symbols:n,nodeTypes:s,bindings:o},a=g(i.visitor,e.create,i);n=a.symbols,s=a.nodeTypes,o=a.bindings,r.push(...a.errors)}if(e.body){const i={...t,symbols:n,nodeTypes:s,bindings:o},a=g(i.visitor,e.body,i);n=a.symbols,s=a.nodeTypes,o=a.bindings,r.push(...a.errors)}return{symbols:n,nodeTypes:s,bindings:o,errors:r}},block(e,t){if("block:statements"===e.kind){let n=t.symbols.enterScope(),s=t.nodeTypes,o=t.bindings;const r=[];for(let i=0;i<e.items.length;i++){const a=e.items[i],c={...t,symbols:n,nodeTypes:s,bindings:o},l=g(c.visitor,a,c);n=l.symbols,s=l.nodeTypes,o=l.bindings,r.push(...l.errors)}return{symbols:n.exitScope(),nodeTypes:s,bindings:o,errors:r}}if("block:definitions"===e.kind){let n=t.symbols,s=t.nodeTypes,o=t.bindings;const r=[];for(let i=0;i<e.items.length;i++){const a=e.items[i],c={...t,symbols:n,nodeTypes:s,bindings:o},l=g(c.visitor,a,c);n=l.symbols,s=l.nodeTypes,o=l.bindings,r.push(...l.errors)}return{symbols:n,nodeTypes:s,bindings:o,errors:r}}return{symbols:t.symbols,nodeTypes:t.nodeTypes,bindings:t.bindings,errors:[]}},declaration(e,t){const n=[];let s=new Map(t.nodeTypes),o=t.symbols,r=t.bindings;switch(e.kind){case"declaration:struct":default:return{symbols:o,nodeTypes:s,bindings:r,errors:n};case"declaration:function":{const i=o.lookup(e.name);i&&s.set(e.id,i.type);for(const n of e.parameters)if(n.type){r=et(n.type,t.structs,r).bindings}if(e.returnType){r=et(e.returnType,t.structs,r).bindings}return{type:i?.type,symbols:o,nodeTypes:s,bindings:r,errors:n}}case"declaration:storage":{const i=o.lookup(e.name);if(i&&s.set(e.id,i.type),e.type){r=et(e.type,t.structs,r).bindings}return{type:i?.type,symbols:o,nodeTypes:s,bindings:r,errors:n}}case"declaration:variable":{if(!e.initializer){const t=new Ge(`Variable ${e.name} must have an initializer`,e.loc||void 0,void 0,void 0,Ve.MISSING_INITIALIZER);n.push(t);const i=k.failure("missing initializer"),a={name:e.name,type:i,mutable:!0,location:"memory",declaration:e};return o=o.define(a),s.set(e.id,i),{type:i,symbols:o,nodeTypes:s,bindings:r,errors:n}}const i={...t,nodeTypes:s,bindings:r},a=g(i.visitor,e.initializer,i);let c;if(s=a.nodeTypes,r=a.bindings,n.push(...a.errors),e.type){const s=et(e.type,t.structs,r);if(c=s.type,r=s.bindings,a.type&&!ot(c,a.type)){const t=new Ge(ze(k.format(c),k.format(a.type)),e.initializer.loc||void 0,k.format(c),k.format(a.type),Ve.TYPE_MISMATCH);n.push(t)}}else c=a.type||k.failure("invalid initializer");const l={name:e.name,type:c,mutable:!0,location:"memory",declaration:e};return o=o.define(l),s.set(e.id,c),{type:c,symbols:o,nodeTypes:s,bindings:r,errors:n}}case"declaration:field":if(e.type){r=et(e.type,t.structs,r).bindings}return{symbols:o,nodeTypes:s,bindings:r,errors:n}}}},{type(e,t){if(u.isElementary(e)){const n=[],s=new Map(t.nodeTypes);let o;if(u.Elementary.isUint(e)){o={256:k.Elementary.uint(256),128:k.Elementary.uint(128),64:k.Elementary.uint(64),32:k.Elementary.uint(32),16:k.Elementary.uint(16),8:k.Elementary.uint(8)}[e.bits||256]||k.failure(`Unknown uint size: ${e.bits}`)}else if(u.Elementary.isInt(e)){o={256:k.Elementary.int(256),128:k.Elementary.int(128),64:k.Elementary.int(64),32:k.Elementary.int(32),16:k.Elementary.int(16),8:k.Elementary.int(8)}[e.bits||256]||k.failure(`Unknown int size: ${e.bits}`)}else o=u.Elementary.isBytes(e)?e.size?k.Elementary.bytes(e.size):k.Elementary.bytes():u.Elementary.isAddress(e)?k.Elementary.address():u.Elementary.isBool(e)?k.Elementary.bool():u.Elementary.isString(e)?k.Elementary.string():k.failure(`Unknown elementary type: ${e.kind}`);return o&&s.set(e.id,o),{type:o,symbols:t.symbols,nodeTypes:s,bindings:t.bindings,errors:n}}if(u.isComplex(e)){const n=[];let s,o=new Map(t.nodeTypes),r=t.symbols,i=t.bindings;if(u.Complex.isArray(e)){const a={...t,nodeTypes:o,symbols:r,bindings:i},c=g(t.visitor,e.element,a);o=c.nodeTypes,r=c.symbols,i=c.bindings,n.push(...c.errors),c.type&&(s=k.array(c.type,e.size))}else if(u.Complex.isMapping(e)){const a={...t,nodeTypes:o,symbols:r,bindings:i},c=g(t.visitor,e.key,a);o=c.nodeTypes,r=c.symbols,i=c.bindings,n.push(...c.errors);const l={...t,nodeTypes:o,symbols:r,bindings:i},u=g(t.visitor,e.value,l);o=u.nodeTypes,r=u.symbols,i=u.bindings,n.push(...u.errors),c.type&&u.type&&(s=k.mapping(c.type,u.type))}else s=k.failure(`Unsupported complex type: ${e.kind}`);return s&&o.set(e.id,s),{type:s,symbols:r,nodeTypes:o,bindings:i,errors:n}}const n=[],s=new Map(t.nodeTypes);let o;const r=t.structs.get(e.name);if(r)o=r.type;else{const t=new Ge(He(e.name),e.loc||void 0,void 0,void 0,Ve.UNDEFINED_TYPE);n.push(t),o=k.failure(`Undefined struct: ${e.name}`)}return o&&s.set(e.id,o),{type:o,symbols:t.symbols,nodeTypes:s,bindings:t.bindings,errors:n}}}].reduce(((e,t)=>({...e,...t})),{});function ct(e){const t=function(e){const t=new Map,n=new Map,s=[];for(const r of e.definitions?.items||[])if(c.isStruct(r))try{const e=Xe(r,t);t.set(r.name,{node:r,type:e})}catch(o){o instanceof Ge&&s.push(o)}for(const r of e.definitions?.items||[])if(c.isFunction(r))try{const e=Qe(r,t);n.set(r.name,{node:r,type:e})}catch(o){o instanceof Ge&&s.push(o)}return s.length>0?_.err(s):_.ok({structs:t,functions:n})}(e);if(!t.success)return t;const n=function(e,{functions:t,structs:n}){let s=nt.empty();const o=[];for(const[r,i]of t){const e={name:r,type:i.type,mutable:!1,location:"memory",declaration:i.node};s=s.define(e)}for(const r of e.storage||[]){const e=r.type?tt(r.type,n):k.failure("missing type"),t={name:r.name,type:e,mutable:!0,location:"storage",slot:r.slot,declaration:r};s=s.define(t)}return o.length>0?_.err(o):_.ok(s)}(e,t.value);if(!n.success)return n;const s={symbols:n.value,structs:t.value.structs,nodeTypes:new Map,bindings:new Map,visitor:at},o=g(at,e,s);return o.errors.length>0?_.err([...o.errors]):_.ok({types:o.nodeTypes,bindings:o.bindings})}var lt;!function(e){e.INVALID_NODE="IR001",e.UNKNOWN_IDENTIFIER="IR002",e.INTERNAL_ERROR="IR003",e.UNSUPPORTED_FEATURE="IR004",e.INVALID_LVALUE="IR005",e.STORAGE_ACCESS_ERROR="IR006",e.UNKNOWN_TYPE="IR007",e.INVALID_ARGUMENT_COUNT="IR008",e.MISSING_RETURN="IR009",e.GENERAL="IR_ERROR"}(lt||(lt={}));const ut=e=>`Unknown identifier: ${e}`;class dt extends B{constructor(e,t,n=L.Error,s=lt.GENERAL){super(e,s,t,n)}}function pt(e){throw new dt("Unexpected code path; expected exhaustive conditionals",void 0,L.Error,lt.INTERNAL_ERROR)}var mt;!function(e){let t,n,s,o,r,i,a,c,l;!function(e){const t=yt((e=>t=>e(t.types)));e.nodeType=e=>t((t=>t.get(e.id)))}(t=e.Types||(e.Types={})),function(e){const t=gt((e=>t=>({...t,module:e(t.module)})));e.main=Symbol("main"),e.create=Symbol("create"),e.addFunction=(n,s)=>t((t=>({...t,...n!==e.main&&n!==e.create?{functions:new Map([...t.functions,[n.toString(),s]])}:{},...n===e.main?{main:s}:{},...n===e.create?{create:s}:{}})))}(n=e.Module||(e.Module={})),function(e){const t=gt((e=>t=>({...t,function:e(t.function)})));e.addParameter=e=>t((t=>({...t,parameters:[...t.parameters,e]}))),e.addBlock=(e,n)=>t((t=>({...t,blocks:new Map([...t.blocks,[e,n]])})))}(s=e.Function||(e.Function={})),function(t){const n=gt((e=>t=>({...t,block:e(t.block)}))),s=yt((e=>({block:t})=>e(t)));t.emit=e=>n((t=>({...t,instructions:[...t.instructions,e]}))),t.terminator=()=>s((e=>e.terminator)),t.setTerminator=t=>e.Errors.attempt(n((e=>{if(e.terminator)throw new dt(`Block ${e.id} already has terminator`,void 0,L.Warning);return{...e,terminator:t}}))),t.addPhi=e=>n((t=>({...t,phis:[...t.phis,e]})))}(o=e.Block||(e.Block={})),function(t){t.update=gt((e=>t=>({...t,scopes:e(t.scopes)}))),t.extract=yt((e=>t=>e(t.scopes))),t.push=()=>t.update((e=>({stack:[...e.stack,{ssaVars:new Map,usedNames:new Map}]}))),t.pop=()=>e.Errors.attempt(t.update((e=>{if(e.stack.length<=1)throw new dt("Cannot pop last scope",void 0,L.Error);return{stack:e.stack.slice(0,-1)}}))),t.current=()=>t.extract((e=>e.stack.at(-1))),t.setCurrent=e=>t.update((t=>({stack:[...t.stack.slice(0,-1),e]}))),t.lookupVariable=e=>t.extract((t=>{for(let n=t.stack.length-1;n>=0;n--){const s=t.stack[n].ssaVars.get(e);if(s)return s}return null}))}(r=e.Scopes||(e.Scopes={})),function(t){const n=gt((e=>t=>({...t,loops:e(t.loops)})));t.push=(e,t)=>n((n=>({stack:[...n.stack,{continueTarget:e,breakTarget:t}]}))),t.pop=()=>e.Errors.attempt(n((e=>{if(e.stack.length<1)throw new dt("Cannot exit loop if not currently inside a loop",void 0,L.Error);return{stack:e.stack.slice(0,-1)}})))}(i=e.Loops||(e.Loops={})),function(e){const t=gt((e=>t=>({...t,counters:e(t.counters)}))),n=yt((e=>t=>e(t.counters)));e.nextTemp=()=>n((({temp:e})=>e)),e.consumeTemp=()=>t((e=>({...e,temp:e.temp+1}))),e.nextBlock=()=>n((({block:e})=>e)),e.consumeBlock=()=>t((e=>({...e,block:e.block+1})))}(a=e.Counters||(e.Counters={})),function(t){const n=gt((e=>t=>({...t,errors:e(t.errors)}))),s=yt((e=>t=>e(t.errors)));t.count=()=>s((e=>e.length)),t.append=e=>n((t=>[...t,e])),t.attempt=gt((t=>n=>{try{return t(n)}catch(s){if(s instanceof dt)return e.Errors.append(s)(n);throw s}}))}(c=e.Errors||(e.Errors={})),function(e){const t=gt((e=>t=>({...t,warnings:e(t.warnings)})));e.append=e=>t((t=>[...t,e]))}(l=e.Warnings||(e.Warnings={}))}(mt||(mt={}));const ft=Symbol("modify"),ht=Symbol("read");function gt(e){return t=>{const n=e(t);return Object.assign(n,{[ft]:!0})}}function yt(e){return t=>{const n=e(t);return Object.assign(n,{[ht]:!0})}}function bt(e){switch(e.kind){case"storage":return{location:"storage",slot:Number(e.slot)};case"storage-computed":return{location:"storage",slot:e.expression};case"memory":return{location:"memory",offset:Number(e.offset),length:Number(e.length)};case"memory-computed":return{location:"memory",offset:e.offsetExpression,length:e.lengthExpression};case"calldata":return{location:"calldata",offset:Number(e.offset),length:Number(e.length)};case"transient":return{location:"transient",slot:Number(e.slot)};case"stack":case"unknown":return}}function kt(e){if(k.isElementary(e))return function(e){const{kind:t}=e;switch(t){case"uint":return{kind:"uint",bits:e.bits};case"int":return{kind:"int",bits:e.bits};case"address":return{kind:"address"};case"bool":return{kind:"bool"};case"bytes":return void 0!==e.size?{kind:"bytes",size:e.size}:{kind:"bytes"};case"string":return{kind:"string"};default:return}}(e);if(k.isArray(e)){const t=kt(e.element);if(!t)return;return{kind:"array",contains:{type:t},...void 0!==e.size&&{length:e.size}}}if(k.isMapping(e)){const t=kt(e.key),n=kt(e.value);if(!t||!n)return;return{kind:"mapping",contains:{key:{type:t},value:{type:n}}}}if(k.isStruct(e)){const t=[];for(const[n,s]of e.fields){const e=kt(s);e&&t.push({name:n,type:e})}return{kind:"struct",contains:t}}k.isFunction(e)}function vt(e){if(k.isElementary(e))switch(e.kind){case"uint":case"int":return(e.bits||256)/8;case"address":return 20;case"bool":return 1;case"bytes":return e.size||32;default:return 32}return 32}function xt(e,t,n=0){if(k.isStruct(t)){const s=[];for(const[o,r]of t.fields){const i=t.layout.get(o);if(!i)continue;const a=n+i.byteOffset,c=xt(e+Math.floor(a/32),r,a%32);c&&s.push({...c,name:o})}if(0===s.length)return;return{group:s}}if(k.isArray(t)){const s=t.element,o=vt(s);if(void 0!==t.size){const n={name:"element",location:"storage",slot:o>=32?{$sum:[e,{$product:["i",o/32]}]}:{$sum:[e,{$quotient:[{$product:["i",o]},32]}]}};o<32&&(n.offset={$remainder:[{$product:["i",o]},32]},n.length=o);const r=k.isStruct(s)||k.isArray(s)?xt(0,s,0):n;return{list:{count:t.size,each:"i",is:r||n}}}{const t={name:"element",location:"storage",slot:o>=32?{$sum:[{$keccak256:[{$wordsized:e}]},{$product:["i",o/32]}]}:{$sum:[{$keccak256:[{$wordsized:e}]},{$quotient:[{$product:["i",o]},32]}]}};o<32&&(t.offset={$remainder:[{$product:["i",o]},32]},t.length=o);const r=k.isStruct(s)||k.isArray(s)?xt(0,s,0):t,i={name:"array-length",location:"storage",slot:e};return n>0&&(i.offset=n),{group:[i,{list:{count:{$read:"array-length"},each:"i",is:r||t}}]}}}if(k.isMapping(t)){const t={location:"storage",slot:e};return n>0&&(t.offset=n),t}const s=vt(t),o={location:"storage",slot:e};return n>0&&(o.offset=n),s<32&&(o.length=s),o}function wt(e,t){const n=[];for(const s of e.module.storageDeclarations){const o=e.types.get(s.id);if(!o){const e=bt({kind:"storage",slot:s.slot});e&&n.push({identifier:s.name,pointer:e,declaration:s.loc?{source:{id:t},range:s.loc}:void 0});continue}const r=xt(s.slot,o);if(!r)continue;const i=kt(o),a=s.loc?{source:{id:t},range:s.loc}:void 0;n.push({identifier:s.name,type:i,pointer:r,declaration:a})}return n}function Tt(e){const t={identifier:e.identifier};return e.type&&(t.type=e.type),e.pointer&&(t.pointer=e.pointer),e.declaration&&(t.declaration=e.declaration),t}var Et;function St(e){return function*(...t){const n=e(...t);if(!function(e){return"function"==typeof e&&ft in e}(n))return function(e){return"function"==typeof e&&ht in e}(n)?n(yield{type:"peek"}):void pt();yield{type:"modify",fn:n}}}function Nt(e){if(k.isFailure(e)||k.isFunction(e))throw new dt(`Cannot convert type with kind ${e.kind} to IR type`,void 0,L.Error,lt.UNKNOWN_TYPE);if(k.isArray(e))return v.ref("memory",e);if(k.isMapping(e))return v.ref("storage",e);if(k.isStruct(e))return v.ref("memory",e);if(k.isElementary(e))switch(e.kind){case"uint":{const t=e.bits||256;return v.scalar(t/8,e)}case"int":{const t=e.bits||256;return v.scalar(t/8,e)}case"address":return v.scalar(20,e);case"bool":return v.scalar(1,e);case"bytes":return e.size?v.scalar(e.size,e):v.ref("memory",e);case"string":return v.ref("memory",e);default:pt()}pt()}!function(e){let t,n,s,o,r,a,c,l,u,d;!function(e){e.nodeType=St(mt.Types.nodeType)}(t=e.Types||(e.Types={})),function(e){e.emit=St(mt.Block.emit)}(n=e.Instructions||(e.Instructions={})),function(e){e.terminate=function*(e){yield*St(mt.Block.setTerminator)(e);const n=(yield{type:"peek"}).block.id;switch(e.kind){case"jump":yield*t(e.target,n);break;case"branch":yield*t(e.trueTarget,n),yield*t(e.falseTarget,n);break;case"call":yield*t(e.continuation,n)}};const t=function*(e,t){const n=(yield{type:"peek"}).function.blocks.get(e);if(n){const s={...n,predecessors:new Set([...n.predecessors,t])};yield{type:"modify",fn:t=>({...t,function:{...t.function,blocks:new Map([...t.function.blocks,[e,s]])}})}}else{const n={id:e,instructions:[],terminator:{kind:"jump",target:e,operationDebug:{}},predecessors:new Set([t]),phis:[],debug:{}};yield{type:"modify",fn:t=>({...t,function:{...t.function,blocks:new Map([...t.function.blocks,[e,n]])}})}}};function*n(){const e=(yield{type:"peek"}).block;if(e.terminator){const t={id:e.id,instructions:e.instructions,terminator:e.terminator,predecessors:e.predecessors,phis:e.phis,debug:{}};yield*St(mt.Function.addBlock)(e.id,t)}}e.currentTerminator=St(mt.Block.terminator),e.create=function*(e){const t=`${e}_${(yield{type:"peek"}).counters.block}`;return yield*St(mt.Counters.consumeBlock)(),t},e.switchTo=function*(e){yield*n();const t=(yield{type:"peek"}).function.blocks.get(e);if(t){const n=t.terminator&&"jump"===t.terminator.kind&&t.terminator.target===e;yield{type:"modify",fn:e=>({...e,block:{id:t.id,instructions:[...t.instructions],terminator:n?void 0:t.terminator,predecessors:new Set(t.predecessors),phis:[...t.phis]}})}}else{const t={id:e,instructions:[],terminator:void 0,predecessors:new Set,phis:[]};yield{type:"modify",fn:e=>({...e,block:t})}}},e.syncCurrent=n}(s=e.Blocks||(e.Blocks={})),function(e){function*t(e,t,s){const r=yield*St(mt.Scopes.current)(),i=yield*o(),a=(r.ssaVars.get(e)?.version??-1)+1,c={name:e,currentTempId:i,type:t,version:a},l={...r,ssaVars:new Map([...r.ssaVars,[e,c]]),usedNames:new Map([...r.usedNames,[e,a+1]])};yield*St(mt.Scopes.setCurrent)(l);const u=`scope_${yield*St(mt.Scopes.extract)((e=>e.stack.length-1))}_${e}`;return yield*n(i,e,u,t,a,s),c}e.declare=t,e.declareWithExistingTemp=function*(e,t,s,o){const r=yield*St(mt.Scopes.current)(),i=(r.ssaVars.get(e)?.version??-1)+1,a={name:e,currentTempId:s,type:t,version:i},c={...r,ssaVars:new Map([...r.ssaVars,[e,a]]),usedNames:new Map([...r.usedNames,[e,i+1]])};yield*St(mt.Scopes.setCurrent)(c);const l=`scope_${yield*St(mt.Scopes.extract)((e=>e.stack.length-1))}_${e}`;return yield*n(s,e,l,t,i,o),a},e.assignSsa=function*(e,s){const r=yield*o(),i=yield*St(mt.Scopes.extract)((e=>e.stack));let a=-1;for(let t=i.length-1;t>=0;t--)if(i[t].ssaVars.has(e)){a=t;break}if(-1===a)return yield*t(e,s);const c=i[a],l=c.ssaVars.get(e).version+1,u={name:e,currentTempId:r,type:s,version:l},d={...c,ssaVars:new Map([...c.ssaVars,[e,u]])},p=[...i.slice(0,a),d,...i.slice(a+1)];yield*St(mt.Scopes.update)((()=>({stack:p})));const m=`scope_${a}_${e}`;return yield*n(r,e,m,s,l),u};const n=function*(e,t,n,s,o,r){const i=(yield{type:"peek"}).function.ssaMetadata||new Map,a=new Map(i);a.set(e,{name:t,scopeId:n,type:s,version:o,loc:r}),yield{type:"modify",fn:e=>({...e,function:{...e.function,ssaMetadata:a}})}};e.lookup=St(mt.Scopes.lookupVariable),e.checkAndInsertPhi=function*(e,t){const r=yield{type:"peek"},i=r.block;if(i.predecessors.size<=1)return null;const a=i.phis.find((t=>{const n=r.function.ssaMetadata?.get(t.dest);return n&&n.name===e}));if(a)return a.dest;const c=new Map;let l=!1,u=null;for(const n of i.predecessors){const s=r.function.blocks.get(n);if(!s)continue;let o=null;if(r.function.ssaMetadata)for(const[t,n]of r.function.ssaMetadata)if(n.name===e)for(const e of s.instructions)"dest"in e&&e.dest===t&&(o=t);o||e!==t.name||(o=t.currentTempId),o&&(c.set(n,o),null===u?u=o:u!==o&&(l=!0))}if(!l||0===c.size)return null;const d=yield*o(),p=new Map;for(const[n,s]of c){const e=r.function.ssaMetadata?.get(s);p.set(n,x.temp(s,e?.type||t.type))}const m={kind:"phi",dest:d,sources:p,type:t.type,operationDebug:{}};yield*St(mt.Block.addPhi)(m);const f=`scope_${yield*St(mt.Scopes.extract)((e=>e.stack.length-1))}_${e}`;return yield*n(d,e,f,t.type,t.version+1),yield*s(e,d),d};const s=function*(e,t){const n=yield*St(mt.Scopes.extract)((e=>e.stack));let s=-1;for(let c=n.length-1;c>=0;c--)if(n[c].ssaVars.has(e)){s=c;break}if(-1===s)return;const o=n[s],r={...o.ssaVars.get(e),currentTempId:t},i={...o,ssaVars:new Map([...o.ssaVars,[e,r]])},a=[...n.slice(0,s),i,...n.slice(s+1)];yield*St(mt.Scopes.update)((()=>({stack:a})))};function*o(){const e=`t${yield*St(mt.Counters.nextTemp)()}`;return yield*St(mt.Counters.consumeTemp)(),e}function*r(){const e=yield*St(mt.Scopes.extract)((e=>e.stack)),t=new Map;for(const n of e)for(const[e,s]of n.ssaVars)t.has(e)||t.set(e,{tempId:s.currentTempId,type:s.type});return t}e.updateSsaToExistingTemp=function*(e,t,s){const o=yield*St(mt.Scopes.extract)((e=>e.stack));let r=-1;for(let n=o.length-1;n>=0;n--)if(o[n].ssaVars.has(e)){r=n;break}if(-1===r){const o=yield*St(mt.Scopes.current)(),i=(o.ssaVars.get(e)?.version??-1)+1,a={name:e,currentTempId:t,type:s,version:i},c={...o,ssaVars:new Map([...o.ssaVars,[e,a]]),usedNames:new Map([...o.usedNames,[e,i+1]])};yield*St(mt.Scopes.setCurrent)(c);const l=`scope_${-1===r?0:r}_${e}`;return void(yield*n(t,e,l,s,i))}const i=o[r],a=i.ssaVars.get(e).version+1,c={name:e,currentTempId:t,type:s,version:a},l={...i,ssaVars:new Map([...i.ssaVars,[e,c]])},u=[...o.slice(0,r),l,...o.slice(r+1)];yield*St(mt.Scopes.update)((()=>({stack:u})));const d=`scope_${r}_${e}`;yield*n(t,e,d,s,a)},e.newTemp=o,e.enterScope=St(mt.Scopes.push),e.exitScope=St(mt.Scopes.pop),e.captureCurrentVariables=r,e.createLoopPhis=function(e,t){const n=new Map;for(const[s,{tempId:o,type:r}]of e)n.set(s,{phiTemp:"",varName:s,type:r,initialTemp:o});return n},e.createAndInsertLoopPhis=function*(e,t){const r=new Map,i=(yield{type:"peek"}).function.blocks.get(t);if(!i)return r;const a=Array.from(i.predecessors).find((e=>e!==t));if(!a)return r;for(const[c,{tempId:l,type:u}]of e){const e=yield*o(),t=new Map;t.set(a,x.temp(l,u));const i={kind:"phi",dest:e,sources:t,type:u,operationDebug:{}};yield*St(mt.Block.addPhi)(i);const d=`scope_${yield*St(mt.Scopes.extract)((e=>e.stack.length-1))}_${c}`;yield*n(e,c,d,u,0),yield*s(c,e),r.set(c,{phiTemp:e,varName:c,type:u,initialTemp:l})}return r},e.updateLoopPhis=function*(e,t,n){const s=(yield{type:"peek"}).function.blocks.get(n);if(!s)return;const o=yield*r();for(const[r,i]of e){const e=o.get(r);if(!e)continue;s.phis.find((e=>e.dest===i.phiTemp))&&(yield{type:"modify",fn:s=>{const o=s.function.blocks.get(n);if(!o)return s;const r=o.phis.map((n=>{if(n.dest===i.phiTemp){const s=new Map(n.sources);return s.set(t,x.temp(e.tempId,i.type)),{...n,sources:s}}return n}));return{...s,function:{...s.function,blocks:new Map([...s.function.blocks,[n,{...o,phis:r}]])}}}})}}}(o=e.Variables||(e.Variables={})),function(e){e.enterLoop=St(mt.Loops.push),e.exitLoop=St(mt.Loops.pop),e.currentLoop=function*(){const e=yield{type:"peek"};return e.loops.stack[e.loops.stack.length-1]||null}}(r=e.ControlFlow||(e.ControlFlow={})),function(e){e.initialize=function*(e,t){const n=[],s=new Map,o=new Map;for(const a of t){const e=`t${n.length}`,t={name:a.name,type:a.type,tempId:e};n.push(t),s.set(a.name,{name:a.name,currentTempId:e,type:a.type,version:0}),o.set(e,{name:a.name,scopeId:"param",type:a.type,version:0})}const r={id:e,parameters:n,blocks:new Map,ssaMetadata:o},i={id:"entry",instructions:[],terminator:void 0,predecessors:new Set,phis:[]};yield{type:"modify",fn:e=>({...e,function:r,block:i,scopes:{stack:[{ssaVars:s,usedNames:new Map}]},loops:{stack:[]},counters:{...e.counters,block:1,temp:t.length}})}},e.currentBlocks=function*(){return(yield{type:"peek"}).function.blocks},e.currentParameters=function*(){return(yield{type:"peek"}).function.parameters},e.finalize=function*(){yield*s.syncCurrent();const e=(yield{type:"peek"}).function;return{name:e.id,parameters:e.parameters,entry:"entry",blocks:e.blocks}},e.collectSsaMetadata=function*(){return(yield{type:"peek"}).function.ssaMetadata||new Map},e.addToModule=St(mt.Module.addFunction)}(a=e.Functions||(e.Functions={})),function(e){e.current=function*(){return(yield{type:"peek"}).module}}(c=e.Modules||(e.Modules={})),function(t){function*n(){const e=yield{type:"peek"},t=wt(e,e.module.name);return 0===t.length?{}:{context:{variables:t.map(Tt)}}}t.forAstNode=function*(t){const s=yield*n();if(!t.loc)return s;const{offset:o,length:r}=t.loc;return{context:{code:{source:{id:(yield*e.Modules.current()).name},range:{offset:o,length:r}},...i.BP.Context.isVariables(s.context)?{variables:s.context.variables}:{}}}},t.withStorageVariables=n}(l=e.Debug||(e.Debug={})),function(t){t.findSlot=function*(e){const t=(yield{type:"peek"}).module.storageDeclarations.find((t=>t.name===e));return t?{slot:t.slot,name:t.name,declaration:t}:null},t.computeSlot=function*(t,n,s){const r=yield*o.newTemp();return yield*e.Instructions.emit({kind:"compute_slot",slotKind:"mapping",base:t,key:n,dest:r,operationDebug:s?yield*e.Debug.forAstNode(s):{}}),x.temp(r,v.Scalar.uint256)},t.load=function*(t,n,s){const r=yield*o.newTemp();return yield*e.Instructions.emit({kind:"read",location:"storage",slot:t,offset:x.constant(0n,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),type:n,dest:r,operationDebug:s?yield*e.Debug.forAstNode(s):{}}),x.temp(r,n)},t.store=function*(t,n,s){yield*e.Instructions.emit({kind:"write",location:"storage",slot:t,offset:x.constant(0n,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),value:n,operationDebug:s?yield*e.Debug.forAstNode(s):{}})}}(u=e.Storage||(e.Storage={})),function(e){e.report=St(mt.Errors.append),e.count=St(mt.Errors.count),e.warning=St(mt.Warnings.append),e.attempt=St(mt.Errors.attempt)}(d=e.Errors||(e.Errors={})),e.run=function(e,t){let n=t,s=e.next();for(;!s.done;){const t=s.value;switch(t.type){case"modify":n=t.fn(n),s=e.next(n);break;case"peek":case"value":s=e.next(n);break;default:pt()}}return{state:n,value:s.value}}}(Et||(Et={}));const At=e=>function*(t){yield*Et.Variables.enterScope();for(const n of t.items)d(n)&&(yield*e(n));yield*Et.Variables.exitScope()};const jt=e=>function*(t,n){const s=yield*Et.Types.nodeType(t);if(!s)return yield*Et.Errors.report(new dt(`Cannot determine type for unary operator: ${t.operator}`,t.loc??void 0,L.Error)),x.constant(0n,v.Scalar.uint256);const o=Nt(s),r=yield*e(t.operands[0],{kind:"rvalue"}),i=yield*Et.Variables.newTemp(),a="!"===t.operator?"not":"neg";return yield*Et.Instructions.emit({kind:"unary",op:a,operand:r,dest:i,operationDebug:yield*Et.Debug.forAstNode(t)}),x.temp(i,o)},It=e=>function*(t,n){const s=yield*Et.Types.nodeType(t);if(!s)return yield*Et.Errors.report(new dt(`Cannot determine type for binary operator: ${t.operator}`,t.loc??void 0,L.Error)),x.constant(0n,v.Scalar.uint256);const o=Nt(s),r=yield*e(t.operands[0],{kind:"rvalue"}),i=yield*e(t.operands[1],{kind:"rvalue"}),a=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"binary",op:Dt(t.operator),left:r,right:i,dest:a,operationDebug:yield*Et.Debug.forAstNode(t)}),x.temp(a,o)};function Dt(e){return{"+":"add","-":"sub","*":"mul","/":"div","%":"mod","==":"eq","!=":"ne","<":"lt","<=":"le",">":"gt",">=":"ge","&&":"and","||":"or"}[e]||"add"}function*$t(e){if(f.isIdentifier(e)){const t=yield*Et.Storage.findSlot(e.name);return t?{slot:t,accesses:[]}:void 0}if(f.isAccess(e)&&f.Access.isIndex(e)){const t=e,n=yield*$t(t.object);if(!n)return;const s=yield*zt(t.index,{kind:"rvalue"});return n.accesses.push({kind:"index",key:s}),n}if(f.isAccess(e)&&f.Access.isMember(e)){const t=e,n=yield*$t(t.object);if(!n)return;return n.accesses.push({kind:"member",fieldName:t.property}),n}}function Mt(e){if("synthetic"!==e.origin){if(k.Elementary.isAddress(e.origin))return 20;if(k.Elementary.isBool(e.origin))return 1;if(k.Elementary.isBytes(e.origin)&&e.origin.size)return e.origin.size;if(k.Elementary.isUint(e.origin))return(e.origin.bits||256)/8}return"scalar"===e.kind?e.size:32}function*Ct(e,t,n){const s=yield*Et.Types.nodeType(e.slot.declaration);let o=x.constant(BigInt(e.slot.slot),v.Scalar.uint256),r=s;for(const u of e.accesses)if("index"===u.kind&&u.key){const e=yield*Et.Variables.newTemp();if(r&&k.isMapping(r)){const t=Nt(r.key);yield*Et.Instructions.emit({kind:"compute_slot",slotKind:"mapping",base:o,key:u.key,keyType:t,dest:e,operationDebug:n?yield*Et.Debug.forAstNode(n):{}}),r=r.value}else if(r&&k.isArray(r)){const t=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"compute_slot",slotKind:"array",base:o,dest:t,operationDebug:n?yield*Et.Debug.forAstNode(n):{}}),yield*Et.Instructions.emit({kind:"binary",op:"add",left:x.temp(t,v.Scalar.uint256),right:u.key,dest:e,operationDebug:n?yield*Et.Debug.forAstNode(n):{}}),r=r.element}o=x.temp(e,v.Scalar.uint256)}else if("member"===u.kind&&u.fieldName&&r&&k.isStruct(r)){const e=r.fields.get(u.fieldName),t=r.layout.get(u.fieldName);if(!e||!t)throw new Error(`Field ${u.fieldName} not found in struct ${r.name}`);const s=Math.floor(t.byteOffset/32);if(s>0){const e=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"compute_slot",slotKind:"field",base:o,fieldOffset:s,dest:e,operationDebug:n?yield*Et.Debug.forAstNode(n):{}}),o=x.temp(e,v.Scalar.uint256)}u.fieldOffset=t.byteOffset,u.fieldType=Nt(e),r=e}let i=0,a=32;const c=e.accesses[e.accesses.length-1];c&&"member"===c.kind&&void 0!==c.fieldOffset&&(i=c.fieldOffset%32,c.fieldType&&(a=Mt(c.fieldType)));const l=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"read",location:"storage",slot:o,offset:x.constant(BigInt(i),v.Scalar.uint256),length:x.constant(BigInt(a),v.Scalar.uint256),type:t,dest:l,operationDebug:n?yield*Et.Debug.forAstNode(n):{}}),x.temp(l,t)}function*Ot(e,t,n){if(0===e.accesses.length)return void(yield*Et.Instructions.emit({kind:"write",location:"storage",slot:x.constant(BigInt(e.slot.slot),v.Scalar.uint256),offset:x.constant(0n,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),value:t,operationDebug:n?yield*Et.Debug.forAstNode(n):{}}));const s=yield*Et.Types.nodeType(e.slot.declaration);let o=x.constant(BigInt(e.slot.slot),v.Scalar.uint256),r=s;for(const u of e.accesses)if("index"===u.kind&&u.key){if(r&&k.isMapping(r)){const e=yield*Et.Variables.newTemp(),t=Nt(r.key);yield*Et.Instructions.emit({kind:"compute_slot",slotKind:"mapping",base:o,key:u.key,keyType:t,dest:e,operationDebug:n?yield*Et.Debug.forAstNode(n):{}}),o=x.temp(e,v.Scalar.uint256),r=r.value}else if(r&&k.isArray(r)){const e=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"compute_slot",slotKind:"array",base:o,dest:e,operationDebug:n?yield*Et.Debug.forAstNode(n):{}});const t=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"binary",op:"add",left:x.temp(e,v.Scalar.uint256),right:u.key,dest:t,operationDebug:n?yield*Et.Debug.forAstNode(n):{}}),o=x.temp(t,v.Scalar.uint256),r=r.element}}else if("member"===u.kind&&u.fieldName&&r&&k.isStruct(r)){const e=r.fields.get(u.fieldName),t=r.layout.get(u.fieldName);if(e&&t){const s=Math.floor(t.byteOffset/32);if(s>0){const e=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"compute_slot",slotKind:"field",base:o,fieldOffset:s,dest:e,operationDebug:n?yield*Et.Debug.forAstNode(n):{}}),o=x.temp(e,v.Scalar.uint256)}u.fieldOffset=t.byteOffset,u.fieldType=Nt(e),r=e}else yield*Et.Errors.report(new dt(`Field ${u.fieldName} not found in struct`,n?.loc??void 0,L.Error))}let i,a=0;const c=e.accesses[e.accesses.length-1];c&&"member"===c.kind&&void 0!==c.fieldOffset&&(a=c.fieldOffset%32,c.fieldType&&(i=Mt(c.fieldType)));const l=void 0!==i?i:32;yield*Et.Instructions.emit({kind:"write",location:"storage",slot:o,offset:x.constant(BigInt(a),v.Scalar.uint256),length:x.constant(BigInt(l),v.Scalar.uint256),value:t,operationDebug:n?yield*Et.Debug.forAstNode(n):{}})}const Ut=(e,t)=>function*(n,s){if("length"===n.property){const t=yield*Et.Types.nodeType(n.object);if(t&&(k.isArray(t)||k.isElementary(t)&&(k.Elementary.isBytes(t)||k.Elementary.isString(t)))){const s=v.Scalar.uint256,o=yield*Et.Variables.newTemp();if(k.isArray(t)&&void 0!==t.size)return yield*Et.Instructions.emit({kind:"const",value:BigInt(t.size),type:s,dest:o,operationDebug:yield*Et.Debug.forAstNode(n)}),x.temp(o,s);const r=yield*e(n.object,{kind:"rvalue"});return yield*Et.Instructions.emit({kind:"length",object:r,dest:o,operationDebug:yield*Et.Debug.forAstNode(n)}),x.temp(o,s)}}const o=yield*t(n);if(o){const e=yield*Et.Types.nodeType(n);if(e){const t=Nt(e);return yield*Ct(o,t,n)}}const r=yield*e(n.object,{kind:"rvalue"}),i=yield*Et.Types.nodeType(n.object);if(i&&k.isStruct(i)){const e=i.fields.get(n.property);if(e){const t=Array.from(i.fields.keys()).indexOf(n.property),s=Nt(e),o=yield*Et.Variables.newTemp(),a=32*t;yield*Et.Instructions.emit(w.ComputeOffset.field("memory",r,n.property,a,o,yield*Et.Debug.forAstNode(n)));const c=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"read",location:"memory",offset:x.temp(o,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),type:s,dest:c,operationDebug:yield*Et.Debug.forAstNode(n)}),x.temp(c,s)}}throw new dt("Invalid member access expression",n.loc??void 0,L.Error)},Lt=e=>function*(t,n){const s=yield*Et.Types.nodeType(t.object);if(s&&k.isElementary(s)&&k.Elementary.isBytes(s)){const n=yield*e(t.object,{kind:"rvalue"}),s=yield*e(t.start,{kind:"rvalue"}),o=yield*e(t.end,{kind:"rvalue"}),r=v.Ref.memory(),i=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"binary",op:"sub",left:o,right:s,dest:i,operationDebug:yield*Et.Debug.forAstNode(t)});const a=x.temp(i,v.Scalar.uint256),c=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"binary",op:"add",left:a,right:x.constant(32n,v.Scalar.uint256),dest:c,operationDebug:yield*Et.Debug.forAstNode(t)});const l=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"allocate",location:"memory",size:x.temp(c,v.Scalar.uint256),dest:l,operationDebug:yield*Et.Debug.forAstNode(t)}),yield*Et.Instructions.emit({kind:"write",location:"memory",offset:x.temp(l,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),value:a,operationDebug:yield*Et.Debug.forAstNode(t)});const u=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"binary",op:"add",left:n,right:x.constant(32n,v.Scalar.uint256),dest:u,operationDebug:yield*Et.Debug.forAstNode(t)});const d=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"binary",op:"add",left:x.temp(u,v.Scalar.uint256),right:s,dest:d,operationDebug:yield*Et.Debug.forAstNode(t)});const p=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"read",location:"memory",offset:x.temp(d,v.Scalar.uint256),length:a,type:r,dest:p,operationDebug:yield*Et.Debug.forAstNode(t)});const m=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"binary",op:"add",left:x.temp(l,v.Scalar.uint256),right:x.constant(32n,v.Scalar.uint256),dest:m,operationDebug:yield*Et.Debug.forAstNode(t)}),yield*Et.Instructions.emit({kind:"write",location:"memory",offset:x.temp(m,v.Scalar.uint256),length:a,value:x.temp(p,r),operationDebug:yield*Et.Debug.forAstNode(t)}),x.temp(l,r)}throw new dt("Only bytes types can be sliced",t.loc??void 0,L.Error)},Pt=(e,t)=>function*(n,s){const o=yield*Et.Types.nodeType(n),r=yield*Et.Types.nodeType(n.object);if(r&&k.isElementary(r)&&k.Elementary.isBytes(r)){if(void 0!==r.size)throw new dt(`Cannot index into fixed-size bytes type 'bytes${r.size}'`,n.loc??void 0,L.Error);const t=yield*e(n.object,{kind:"rvalue"}),s=yield*e(n.index,{kind:"rvalue"}),o=v.scalar(1,"synthetic"),i=yield*Et.Variables.newTemp();yield*Et.Instructions.emit(w.ComputeOffset.byte("memory",t,s,i,yield*Et.Debug.forAstNode(n)));const a=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"read",location:"memory",offset:x.temp(i,v.Scalar.uint256),length:x.constant(1n,v.Scalar.uint256),type:o,dest:a,operationDebug:yield*Et.Debug.forAstNode(n)}),x.temp(a,o)}if(r&&k.isArray(r)&&f.isIdentifier(n.object)){const t=n.object.name;if(yield*Et.Variables.lookup(t)){const t=yield*e(n.object,{kind:"rvalue"}),s=yield*e(n.index,{kind:"rvalue"}),o=Nt(r.element),i=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"binary",op:"add",left:t,right:x.constant(32n,v.Scalar.uint256),dest:i,operationDebug:yield*Et.Debug.forAstNode(n)});const a=yield*Et.Variables.newTemp();yield*Et.Instructions.emit(w.ComputeOffset.array("memory",x.temp(i,v.Scalar.uint256),s,32,a,yield*Et.Debug.forAstNode(n)));const c=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"read",location:"memory",offset:x.temp(a,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),type:o,dest:c,operationDebug:yield*Et.Debug.forAstNode(n)}),x.temp(c,o)}}const i=yield*t(n);if(i&&o){const e=Nt(o);return yield*Ct(i,e,n)}const a=yield*e(n.object,{kind:"rvalue"}),c=yield*e(n.index,{kind:"rvalue"});if(r&&k.isArray(r)){const e=Nt(r.element),t=yield*Et.Variables.newTemp();yield*Et.Instructions.emit(w.ComputeOffset.array("memory",a,c,32,t,yield*Et.Debug.forAstNode(n)));const s=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"read",location:"memory",offset:x.temp(t,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),type:e,dest:s,operationDebug:yield*Et.Debug.forAstNode(n)}),x.temp(s,e)}if(r&&k.isMapping(r)&&f.isIdentifier(n.object)){const e=yield*Et.Storage.findSlot(n.object.name);if(e){const t=Nt(r.value),s=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"compute_slot",slotKind:"mapping",base:x.constant(BigInt(e.slot),v.Scalar.uint256),key:c,keyType:Nt(r.key),dest:s,operationDebug:yield*Et.Debug.forAstNode(n)});const o=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"read",location:"storage",slot:x.temp(s,v.Scalar.uint256),offset:x.constant(0n,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),type:t,dest:o,operationDebug:yield*Et.Debug.forAstNode(n)}),x.temp(o,t)}}throw new dt("Invalid index access expression",n.loc??void 0,L.Error)};const _t=(e=>{const t=jt(e),n=It(e);return function*(e,s){if(!(yield*Et.Types.nodeType(e)))return yield*Et.Errors.report(new dt(`Cannot determine type for operator expression: ${e.operator}`,e.loc??void 0,L.Error)),x.constant(0n,v.Scalar.uint256);switch(e.operands.length){case 1:return yield*t(e,s);case 2:return yield*n(e,s);default:pt(e.operands)}}})(zt),Bt=(e=>{const t=Pt(e,$t),n=Ut(e,$t),s=Lt(e);return function*(e,o){switch(e.kind){case"expression:access:member":return yield*n(e,o);case"expression:access:slice":return yield*s(e,o);case"expression:access:index":return yield*t(e,o);default:pt()}}})(zt),Rt=(e=>function*(t,n){if("expression:identifier"===t.callee.kind&&"keccak256"===t.callee.name){if(1!==t.arguments.length)return yield*Et.Errors.report(new dt("keccak256 expects exactly 1 argument",t.loc??void 0,L.Error)),x.constant(0n,v.Scalar.bytes32);const n=yield*e(t.arguments[0],{kind:"rvalue"}),s=v.Scalar.bytes32,o=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"hash",value:n,dest:o,operationDebug:yield*Et.Debug.forAstNode(t)}),x.temp(o,s)}if("expression:identifier"===t.callee.kind){const n=t.callee.name,s=yield*Et.Types.nodeType(t);if(!s)return yield*Et.Errors.report(new dt(`Unknown function: ${n}`,t.loc??void 0,L.Error)),x.constant(0n,v.Scalar.uint256);const o=[];for(const c of t.arguments)o.push(yield*e(c,{kind:"rvalue"}));const r=Nt(s);let i;k.isFailure(s)&&"void function"===s.reason||(i=yield*Et.Variables.newTemp());const a=yield*Et.Blocks.create("call_cont");return yield*Et.Blocks.terminate({kind:"call",function:n,arguments:o,dest:i,continuation:a,operationDebug:yield*Et.Debug.forAstNode(t)}),yield*Et.Blocks.switchTo(a),i?x.temp(i,r):x.constant(0n,v.Scalar.uint256)}return yield*Et.Errors.report(new dt("Complex function call expressions not yet supported",t.loc??void 0,L.Error)),x.constant(0n,v.Scalar.uint256)})(zt),Vt=(e=>function*(t,n){const s=yield*e(t.expression,{kind:"rvalue"}),o=yield*Et.Types.nodeType(t);if(!o)return yield*Et.Errors.report(new dt("Cannot determine target type for cast expression",t.loc??void 0,L.Error)),s;const r=Nt(o),i=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"cast",value:s,targetType:r,dest:i,operationDebug:yield*Et.Debug.forAstNode(t)}),x.temp(i,r)})(zt);function*zt(e,t){switch(e.kind){case"expression:identifier":return yield*function*(e){const t=yield*Et.Variables.lookup(e.name);if(t){const n=yield*Et.Variables.checkAndInsertPhi(e.name,t);return n?x.temp(n,t.type):x.temp(t.currentTempId,t.type)}const n=yield*Et.Storage.findSlot(e.name);if(n){const t=yield*Et.Types.nodeType(n.declaration),s=t?Nt(t):v.Scalar.uint256,o=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"read",location:"storage",slot:x.constant(BigInt(n.slot),v.Scalar.uint256),offset:x.constant(0n,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),type:s,dest:o,operationDebug:yield*Et.Debug.forAstNode(e)}),x.temp(o,s)}return yield*Et.Errors.report(new dt(ut(e.name),e.loc??void 0,L.Error)),x.constant(0n,v.Scalar.uint256)}(e);case"expression:literal:number":case"expression:literal:string":case"expression:literal:boolean":case"expression:literal:address":case"expression:literal:hex":return yield*function*(e){const t=yield*Et.Types.nodeType(e);if(!t)return yield*Et.Errors.report(new dt(`Cannot determine type for literal: ${e.value}`,e.loc??void 0,L.Error)),x.constant(0n,v.Scalar.uint256);const n=Nt(t);let s;switch(e.kind){case"expression:literal:number":s=BigInt(e.value);break;case"expression:literal:hex":s=(e.value.startsWith("0x")?e.value.slice(2):e.value).length>64?e.value.startsWith("0x")?e.value:`0x${e.value}`:BigInt(e.value);break;case"expression:literal:address":case"expression:literal:string":s=e.value;break;case"expression:literal:boolean":s="true"===e.value;break;default:pt()}const o=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"const",dest:o,value:s,type:n,operationDebug:yield*Et.Debug.forAstNode(e)}),x.temp(o,n)}(e);case"expression:operator":return yield*_t(e,t);case"expression:access:member":case"expression:access:slice":case"expression:access:index":return yield*Bt(e,t);case"expression:call":return yield*Rt(e,t);case"expression:cast":return yield*Vt(e,t);case"expression:special:msg.sender":case"expression:special:msg.value":case"expression:special:msg.data":case"expression:special:block.timestamp":case"expression:special:block.number":return yield*function*(e){const t=yield*Et.Types.nodeType(e);if(!t)return yield*Et.Errors.report(new dt(`Cannot determine type for special expression: ${e.kind}`,e.loc??void 0,L.Error)),x.constant(0n,v.Scalar.uint256);const n=Nt(t),s=yield*Et.Variables.newTemp();let o;switch(e.kind){case"expression:special:msg.sender":o="msg_sender";break;case"expression:special:msg.value":o="msg_value";break;case"expression:special:msg.data":o="msg_data";break;case"expression:special:block.timestamp":o="block_timestamp";break;case"expression:special:block.number":o="block_number";break;default:pt()}return yield*Et.Instructions.emit({kind:"env",op:o,dest:s,operationDebug:yield*Et.Debug.forAstNode(e)}),x.temp(s,n)}(e);case"expression:array":return yield*function*(e,t){switch(t.kind){case"lvalue-storage":{const n=x.constant(BigInt(e.elements.length),v.Scalar.uint256);yield*Et.Instructions.emit({kind:"write",location:"storage",slot:x.constant(BigInt(t.slot),v.Scalar.uint256),offset:x.constant(0n,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),value:n,operationDebug:yield*Et.Debug.forAstNode(e)});for(let s=0;s<e.elements.length;s++){const n=yield*zt(e.elements[s],{kind:"rvalue"}),o=x.constant(BigInt(s),v.Scalar.uint256),r=yield*Et.Variables.newTemp();yield*Et.Instructions.emit(w.ComputeSlot.array(x.constant(BigInt(t.slot),v.Scalar.uint256),r,yield*Et.Debug.forAstNode(e)));const i=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"binary",op:"add",left:x.temp(r,v.Scalar.uint256),right:o,dest:i,operationDebug:yield*Et.Debug.forAstNode(e)}),yield*Et.Instructions.emit({kind:"write",location:"storage",slot:x.temp(i,v.Scalar.uint256),offset:x.constant(0n,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),value:n,operationDebug:yield*Et.Debug.forAstNode(e.elements[s])})}return x.constant(0n,v.Scalar.uint256)}case"lvalue-memory":case"rvalue":{const n="lvalue-memory"===t.kind?t.type:yield*Et.Types.nodeType(e);if(!n||!k.isArray(n)){const t=BigInt(e.elements.length),n=32n+32n*t,s=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"allocate",location:"memory",size:x.constant(n,v.Scalar.uint256),dest:s,operationDebug:yield*Et.Debug.forAstNode(e)}),yield*Et.Instructions.emit({kind:"write",location:"memory",offset:x.temp(s,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),value:x.constant(t,v.Scalar.uint256),operationDebug:yield*Et.Debug.forAstNode(e)});const o=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"binary",op:"add",left:x.temp(s,v.Scalar.uint256),right:x.constant(32n,v.Scalar.uint256),dest:o,operationDebug:yield*Et.Debug.forAstNode(e)});for(let r=0;r<e.elements.length;r++){const t=yield*zt(e.elements[r],{kind:"rvalue"}),n=yield*Et.Variables.newTemp();yield*Et.Instructions.emit(w.ComputeOffset.array("memory",x.temp(o,v.Scalar.uint256),x.constant(BigInt(r),v.Scalar.uint256),32,n,yield*Et.Debug.forAstNode(e.elements[r]))),yield*Et.Instructions.emit({kind:"write",location:"memory",offset:x.temp(n,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),value:t,operationDebug:yield*Et.Debug.forAstNode(e.elements[r])})}return x.temp(s,v.Scalar.uint256)}const s=BigInt(e.elements.length),o=32n+32n*s,r=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"allocate",location:"memory",size:x.constant(o,v.Scalar.uint256),dest:r,operationDebug:yield*Et.Debug.forAstNode(e)}),yield*Et.Instructions.emit({kind:"write",location:"memory",offset:x.temp(r,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),value:x.constant(s,v.Scalar.uint256),operationDebug:yield*Et.Debug.forAstNode(e)});const i=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"binary",op:"add",left:x.temp(r,v.Scalar.uint256),right:x.constant(32n,v.Scalar.uint256),dest:i,operationDebug:yield*Et.Debug.forAstNode(e)});for(let t=0;t<e.elements.length;t++){const n=yield*zt(e.elements[t],{kind:"rvalue"}),s=yield*Et.Variables.newTemp();yield*Et.Instructions.emit(w.ComputeOffset.array("memory",x.temp(i,v.Scalar.uint256),x.constant(BigInt(t),v.Scalar.uint256),32,s,yield*Et.Debug.forAstNode(e.elements[t]))),yield*Et.Instructions.emit({kind:"write",location:"memory",offset:x.temp(s,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),value:n,operationDebug:yield*Et.Debug.forAstNode(e.elements[t])})}return x.temp(r,v.Scalar.uint256)}}}(e,t);case"expression:struct":throw new Error("Struct expressions not yet implemented in IR generation");default:pt()}}function*Ft(e){const t=e.declaration;switch(t.kind){case"declaration:variable":return yield*function*(e){const t=yield*Et.Types.nodeType(e),n=t?Nt(t):v.Scalar.uint256;if("ref"===n.kind){let t;if(e.initializer)if(f.isLiteral(e.initializer)&&f.Literal.isHex(e.initializer)){const n=e.initializer,s=(n.value.startsWith("0x")?n.value.slice(2):n.value).length/2;t=x.constant(BigInt(s+32),v.Scalar.uint256)}else t=x.constant(64n,v.Scalar.uint256);else t=x.constant(64n,v.Scalar.uint256);const s=yield*Et.Variables.newTemp();if(yield*Et.Instructions.emit({kind:"allocate",location:"memory",size:t,dest:s,operationDebug:yield*Et.Debug.forAstNode(e)}),yield*Et.Variables.declareWithExistingTemp(e.name,n,s),e.initializer){const t=yield*zt(e.initializer,{kind:"rvalue"});if(f.isLiteral(e.initializer)){const n=e.initializer;if(f.Literal.isHex(n)){const o=(n.value.startsWith("0x")?n.value.slice(2):n.value).length/2;yield*Et.Instructions.emit({kind:"write",location:"memory",offset:x.temp(s,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),value:x.constant(BigInt(o),v.Scalar.uint256),operationDebug:yield*Et.Debug.forAstNode(e)});const r=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"binary",op:"add",left:x.temp(s,v.Scalar.uint256),right:x.constant(32n,v.Scalar.uint256),dest:r,operationDebug:yield*Et.Debug.forAstNode(e)}),yield*Et.Instructions.emit({kind:"write",location:"memory",offset:x.temp(r,v.Scalar.uint256),length:x.constant(BigInt(o),v.Scalar.uint256),value:t,operationDebug:yield*Et.Debug.forAstNode(e)})}}else"temp"===t.kind?yield*Et.Variables.updateSsaToExistingTemp(e.name,t.id,n):yield*Et.Instructions.emit({kind:"binary",op:"add",left:t,right:x.constant(0n,v.Scalar.uint256),dest:s,operationDebug:yield*Et.Debug.forAstNode(e)})}}else if(e.initializer){const t=yield*zt(e.initializer,{kind:"rvalue"}),s=yield*Et.Variables.declare(e.name,n);"temp"===t.kind?t.id!==s.currentTempId&&(yield*Et.Variables.updateSsaToExistingTemp(e.name,t.id,n)):"const"===t.kind&&(yield*Et.Instructions.emit({kind:"const",value:t.value,type:n,dest:s.currentTempId,operationDebug:yield*Et.Debug.forAstNode(e)}))}else{const t=yield*Et.Variables.declare(e.name,n);yield*Et.Instructions.emit({kind:"const",value:0n,type:n,dest:t.currentTempId,operationDebug:yield*Et.Debug.forAstNode(e)})}}(t);case"declaration:function":case"declaration:parameter":case"declaration:struct":case"declaration:storage":return;default:return yield*Et.Errors.report(new dt(`Unsupported declaration kind: ${t.kind}`,e.loc??void 0,L.Error))}}const Ht=e=>{const t=At(e);return function*(e){const n=yield*Et.Blocks.create("then"),s=e.alternate?yield*Et.Blocks.create("else"):yield*Et.Blocks.create("merge"),o=e.alternate?yield*Et.Blocks.create("merge"):s,r=yield*zt(e.condition,{kind:"rvalue"});yield*Et.Blocks.terminate({kind:"branch",condition:r,trueTarget:n,falseTarget:s,operationDebug:yield*Et.Debug.forAstNode(e)}),yield*Et.Blocks.switchTo(n),yield*t(e.body);(yield*Et.Blocks.currentTerminator())||(yield*Et.Blocks.terminate({kind:"jump",target:o,operationDebug:yield*Et.Debug.forAstNode(e)}));if(e.alternate){yield*Et.Blocks.switchTo(s),yield*t(e.alternate);(yield*Et.Blocks.currentTerminator())||(yield*Et.Blocks.terminate({kind:"jump",target:o,operationDebug:yield*Et.Debug.forAstNode(e)}))}yield*Et.Blocks.switchTo(o)}},qt=e=>function*(t){const n=At(e);t.init&&(yield*e(t.init));const s=yield*Et.Blocks.create(`${t.prefix}_header`),o=yield*Et.Blocks.create(`${t.prefix}_body`),r=yield*Et.Blocks.create(`${t.prefix}_exit`),i=t.update?yield*Et.Blocks.create(`${t.prefix}_update`):null,a=yield*Et.Variables.captureCurrentVariables();yield*Et.Blocks.terminate({kind:"jump",target:s,operationDebug:t.node?yield*Et.Debug.forAstNode(t.node):{}}),yield*Et.Blocks.switchTo(s);const c=yield*Et.Variables.createAndInsertLoopPhis(a,s),l=t.condition?yield*zt(t.condition,{kind:"rvalue"}):x.constant(1n,v.Scalar.bool);yield*Et.Blocks.terminate({kind:"branch",condition:l,trueTarget:o,falseTarget:r,operationDebug:t.node?yield*Et.Debug.forAstNode(t.node):{}}),yield*Et.Blocks.switchTo(o);const u=i||s;yield*Et.ControlFlow.enterLoop(u,r),yield*n(t.body),yield*Et.ControlFlow.exitLoop();(yield*Et.Blocks.currentTerminator())||(yield*Et.Blocks.terminate({kind:"jump",target:u,operationDebug:t.node?yield*Et.Debug.forAstNode(t.node):{}}));if(i&&t.update){yield*Et.Blocks.switchTo(i),yield*e(t.update),yield*Et.Variables.updateLoopPhis(c,i,s);(yield*Et.Blocks.currentTerminator())||(yield*Et.Blocks.terminate({kind:"jump",target:s,operationDebug:t.node?yield*Et.Debug.forAstNode(t.node):{}}))}else if(!t.update){const e=(yield{type:"peek"}).block.id;yield*Et.Variables.updateLoopPhis(c,e,s)}yield*Et.Blocks.switchTo(r)},Wt=e=>{const t=qt(e);return function*(e){yield*t({condition:e.condition,body:e.body,prefix:"while",node:e})}},Kt=e=>{const t=qt(e);return function*(e){yield*t({init:e.init,condition:e.condition,update:e.update,body:e.body,prefix:"for",node:e})}};function*Yt(e){yield*function*(e,t){let n={kind:"rvalue"};if("expression:identifier"===e.kind){const t=e.name,s=yield*Et.Storage.findSlot(t);if(s){const t=yield*Et.Types.nodeType(e);t&&(n={kind:"lvalue-storage",slot:s.slot,type:t})}else{if(yield*Et.Variables.lookup(t)){const t=yield*Et.Types.nodeType(e);t&&(n={kind:"lvalue-memory",type:t})}}}const s=yield*zt(t,n);if("lvalue-storage"===n.kind&&"expression:array"===t.kind)return;yield*function*(e,t){if("expression:identifier"===e.kind){const n=e.name,s=yield*Et.Variables.lookup(n);if(s){if("temp"===t.kind)yield*Et.Variables.updateSsaToExistingTemp(n,t.id,s.type);else{const o=yield*Et.Variables.assignSsa(n,s.type);yield*Et.Instructions.emit({kind:"binary",op:"add",left:t,right:x.constant(0n,s.type),dest:o.currentTempId,operationDebug:yield*Et.Debug.forAstNode(e)})}return}const o=yield*Et.Storage.findSlot(n);return o?void(yield*Et.Instructions.emit({kind:"write",location:"storage",slot:x.constant(BigInt(o.slot),v.Scalar.uint256),offset:x.constant(0n,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),value:t,operationDebug:yield*Et.Debug.forAstNode(e)})):void(yield*Et.Errors.report(new dt(`Unknown identifier: ${n}`,e.loc||void 0,L.Error)))}if("expression:access:member"===e.kind||"expression:access:slice"===e.kind||"expression:access:index"===e.kind){const n=e;if("expression:access:member"===n.kind){const s=yield*$t(e);if(s)return void(yield*Ot(s,t,n));const o=yield*zt(n.object,{kind:"rvalue"}),r=yield*Et.Types.nodeType(n.object);if(r&&k.isStruct(r)){const e=n.property;if(r.fields.get(e)){let s=0;for(const[t]of r.fields){if(t===e)break;s++}const i=yield*Et.Variables.newTemp(),a=32*s;return yield*Et.Instructions.emit({kind:"compute_offset",location:"memory",base:o,field:e,fieldOffset:a,dest:i,operationDebug:yield*Et.Debug.forAstNode(n)}),void(yield*Et.Instructions.emit({kind:"write",location:"memory",offset:x.temp(i,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),value:t,operationDebug:yield*Et.Debug.forAstNode(n)}))}}}else if("expression:access:index"===n.kind){const s=yield*Et.Types.nodeType(n.object);if(s&&k.isElementary(s)&&k.Elementary.isBytes(s)){const s=yield*zt(n.object,{kind:"rvalue"}),o=yield*zt(n.index,{kind:"rvalue"}),r=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"compute_offset",location:"memory",base:s,index:o,stride:1,dest:r,operationDebug:yield*Et.Debug.forAstNode(e)}),void(yield*Et.Instructions.emit({kind:"write",location:"memory",offset:x.temp(r,v.Scalar.uint256),length:x.constant(1n,v.Scalar.uint256),value:t,operationDebug:yield*Et.Debug.forAstNode(e)}))}const o=yield*$t(e);if(o)return void(yield*Ot(o,t,n));const r=yield*zt(n.object,{kind:"rvalue"}),i=yield*zt(n.index,{kind:"rvalue"});if(s&&k.isArray(s)){const n=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"compute_offset",location:"memory",base:r,index:i,stride:32,dest:n,operationDebug:yield*Et.Debug.forAstNode(e)}),void(yield*Et.Instructions.emit({kind:"write",location:"memory",offset:x.temp(n,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),value:t,operationDebug:yield*Et.Debug.forAstNode(e)}))}}}yield*Et.Errors.report(new dt("Invalid lvalue",e.loc||void 0,L.Error))}(e,s)}(e.target,e.value)}const Gt=(e=>{const t=Ht(e),n=Wt(e),s=Kt(e);return function*(e){switch(e.kind){case"statement:control-flow:if":return yield*t(e);case"statement:control-flow:while":return yield*n(e);case"statement:control-flow:for":return yield*s(e);case"statement:control-flow:return":return yield*function*(e){const t=e.value?yield*zt(e.value,{kind:"rvalue"}):void 0;yield*Et.Blocks.terminate({kind:"return",value:t,operationDebug:yield*Et.Debug.forAstNode(e)})}(e);case"statement:control-flow:break":return yield*function*(e){const t=yield*Et.ControlFlow.currentLoop();if(!t)return void(yield*Et.Errors.report(new dt("Break outside loop",e.loc??void 0,L.Error)));yield*Et.Blocks.terminate({kind:"jump",target:t.breakTarget,operationDebug:yield*Et.Debug.forAstNode(e)})}(e);case"statement:control-flow:continue":return yield*function*(e){const t=yield*Et.ControlFlow.currentLoop();if(!t)return void(yield*Et.Errors.report(new dt("Continue outside loop",e.loc??void 0,L.Error)));yield*Et.Blocks.terminate({kind:"jump",target:t.continueTarget,operationDebug:yield*Et.Debug.forAstNode(e)})}(e);default:pt()}}})(Zt),Jt=At(Zt);function*Zt(e){switch(e.kind){case"statement:declare":return yield*Ft(e);case"statement:assign":return yield*Yt(e);case"statement:control-flow:if":case"statement:control-flow:for":case"statement:control-flow:while":case"statement:control-flow:return":case"statement:control-flow:break":case"statement:control-flow:continue":return yield*Gt(e);case"statement:express":return yield*function*(e){yield*zt(e.expression,{kind:"rvalue"})}(e);default:pt()}}function*Xt(e,t,n){yield*Et.Functions.initialize(e,t),yield*Jt(n);(yield*Et.Blocks.currentTerminator())||(yield*Et.Blocks.terminate({kind:"return",value:void 0,operationDebug:{}}));yield*Et.Blocks.syncCurrent();const s=function(e){const t=new Map;for(const[n,s]of e)t.set(n,{...s,predecessors:new Set});for(const[n,s]of e){const e=s.terminator;if(e)switch(e.kind){case"jump":{const s=t.get(e.target);s&&s.predecessors.add(n);break}case"branch":{const s=t.get(e.trueTarget);s&&s.predecessors.add(n);const o=t.get(e.falseTarget);o&&o.predecessors.add(n);break}}}return t}(yield*Et.Functions.currentBlocks()),o=yield*Et.Functions.currentParameters(),r=yield*Et.Functions.collectSsaMetadata();return{name:e,parameters:o,entry:"entry",blocks:s,ssaVariables:r.size>0?r:void 0}}function*Qt(e){const t=yield*Et.Errors.count(),n=yield*e;if(!((yield*Et.Errors.count())>t))return n}function en(e,t){const n=function(e,t){const n=[],s={name:e.name,functions:new Map,storageDeclarations:e.storage??[]},o={id:"",parameters:[],blocks:new Map},r={id:"entry",instructions:[],terminator:void 0,predecessors:new Set,phis:[]},i={stack:[{ssaVars:new Map,usedNames:new Map}]};return{module:s,function:o,block:r,scopes:i,loops:{stack:[]},counters:{temp:0,block:1},types:t,errors:n,warnings:[]}}(e,t),s=Et.run(function*(e,t){if(e.create){const t=yield*Qt(Xt("create",[],e.create));t&&!function(e){const{blocks:t}=e,n=t.get("entry");return 1===t.size&&!!n&&0===n.instructions.length&&"return"===n.terminator.kind&&!n.terminator.value}(t)&&(yield*Et.Functions.addToModule(mt.Module.create,t))}if(e.body){const t=yield*Qt(Xt("main",[],e.body));t&&(yield*Et.Functions.addToModule(mt.Module.main,t))}for(const a of e.definitions?.items??[])if("declaration:function"===a.kind){const e=a,n=t.get(e.id);if(!n||!k.isFunction(n)){yield*Et.Errors.report(new dt(`Missing type information for function: ${e.name}`,e.loc??void 0,L.Error));continue}const s=e.parameters.map(((e,t)=>({name:e.name,type:Nt(n.parameters[t])}))),o=yield*Qt(Xt(e.name,s,e.body));o&&(yield*Et.Functions.addToModule(e.name,o))}if((yield*Et.Errors.count())>0)return;const n=yield*Et.Modules.current(),s=wt(yield{type:"peek"},"0"),o=s.length>0?{variables:s.map(Tt)}:void 0,r={name:n.name,functions:n.functions,main:n.main||(i="main",{name:i,parameters:[],entry:"entry",blocks:new Map([["entry",{id:"entry",instructions:[],phis:[],terminator:{kind:"return",value:void 0,operationDebug:{}},predecessors:new Set,debug:{}}]])}),debugContext:o};var i;return n.create&&(r.create=n.create),r}(e,t),n),{state:o,value:r}=s,i=o.errors.length>0,a={};return o.errors.length>0&&(a[L.Error]=o.errors),o.warnings.length>0&&(a[L.Warning]=o.warnings),i||!r?{success:!1,messages:a}:{success:!0,value:r,messages:a}}class tn{constructor(){this.transformations=[],this.analysisCache=new Map}trackTransformation(e){this.transformations.push(e)}getTransformations(){return this.transformations}getAnalysis(e){return this.analysisCache.get(e)}setAnalysis(e,t){this.analysisCache.set(e,t)}}class nn{constructor(e){this.steps=e}optimize(e){const t=new tn,n=[];let s=e;for(const o of this.steps){const e=this.countInstructions(s),r=this.countBlocks(s),i=t.getTransformations().length;s=o.run(s,t);const a=this.countInstructions(s),c=this.countBlocks(s),l=t.getTransformations().length;n.push({passName:o.name,instructionsRemoved:Math.max(0,e-a),instructionsAdded:Math.max(0,a-e),blocksRemoved:Math.max(0,r-c),blocksAdded:Math.max(0,c-r),transformations:l-i})}return{module:s,stats:n,transformations:t.getTransformations()}}countInstructions(e){let t=0;for(const n of e.main.blocks.values())t+=n.instructions.length,t+=1;if(e.create)for(const n of e.create.blocks.values())t+=n.instructions.length,t+=1;if(e.functions)for(const n of e.functions.values())for(const e of n.blocks.values())t+=e.instructions.length,t+=1;return t}countBlocks(e){let t=e.main.blocks.size;if(e.create&&(t+=e.create.blocks.size),e.functions)for(const n of e.functions.values())t+=n.blocks.size;return t}}class sn{processAllFunctions(e,t){if(t(e.main,"main"),e.create&&t(e.create,"create"),e.functions)for(const[n,s]of e.functions.entries())t(s,n)}cloneModule(e){const t=this.cloneFunction(e.main);let n;e.create&&(n=this.cloneFunction(e.create));const s=new Map;if(e.functions)for(const[o,r]of e.functions.entries())s.set(o,this.cloneFunction(r));return{name:e.name,functions:s,create:n,main:t,loc:e.loc}}cloneFunction(e){const t=new Map;for(const[n,s]of e.blocks.entries())t.set(n,{id:s.id,phis:s.phis?[...s.phis]:[],instructions:[...s.instructions],terminator:{...s.terminator},predecessors:new Set(s.predecessors),debug:s.debug});return{name:e.name,parameters:[...e.parameters],entry:e.entry,blocks:t}}replaceInstruction(e,t,n,s,o){const r=[...e],i=e[t];return null===n?(r.splice(t,1),s.trackTransformation({type:"delete",pass:this.name,original:I(i),result:[],reason:o})):(r[t]=n,s.trackTransformation({type:"replace",pass:this.name,original:I(i),result:I(n),reason:o})),r}}var on=n(51329);class rn extends sn{constructor(){super(...arguments),this.name="constant-folding"}run(e,t){const n=this.cloneModule(e);return this.processAllFunctions(n,(e=>{const n=new Map;for(const s of e.blocks.values()){const e=[];for(let o=0;o<s.instructions.length;o++){const r=s.instructions[o];if("const"===r.kind)"dest"in r&&n.set(r.dest,r.value),e.push(r);else if("binary"===r.kind&&this.canFoldBinary(r,n)){const s=this.foldBinary(r,n);s?(e.push(s),"const"===s.kind&&n.set(s.dest,s.value),t.trackTransformation({type:"replace",pass:this.name,original:I(r),result:I(s),reason:`Folded ${r.op} operation on constants`})):e.push(r)}else if("hash"===r.kind&&this.canFoldHash(r,n)){const s=this.foldHash(r,n);s?(e.push(s),"const"===s.kind&&n.set(s.dest,s.value),t.trackTransformation({type:"replace",pass:this.name,original:I(r),result:I(s),reason:"Evaluated keccak256 on constant"})):e.push(r)}else if("length"===r.kind&&this.canFoldLength(r)){const s=this.foldLength(r);s?(e.push(s),"const"===s.kind&&n.set(s.dest,s.value),t.trackTransformation({type:"replace",pass:this.name,original:I(r),result:I(s),reason:"Evaluated length of fixed-size array"})):e.push(r)}else e.push(r)}s.instructions=e}})),n}canFoldBinary(e,t){if("binary"!==e.kind)return!1;const n=this.getConstantValue(e.left,t),s=this.getConstantValue(e.right,t);return void 0!==n&&void 0!==s}foldBinary(e,t){const n=this.getConstantValue(e.left,t),s=this.getConstantValue(e.right,t);if(void 0===n||void 0===s)return null;const o=this.evaluateBinary(e.op,n,s);return void 0===o?null:{kind:"const",value:o,type:this.getResultType(e.op,typeof o),dest:e.dest,operationDebug:j(e)}}getConstantValue(e,t){return"const"===e.kind?e.value:"temp"===e.kind?t.get(e.id):void 0}evaluateBinary(e,t,n){if("bigint"==typeof t&&"bigint"==typeof n)switch(e){case"add":return t+n;case"sub":return t-n;case"mul":return t*n;case"div":return 0n!==n?t/n:void 0;case"mod":return 0n!==n?t%n:void 0;case"shl":return t<<n;case"shr":return t>>n;case"lt":return t<n;case"gt":return t>n;case"le":return t<=n;case"ge":return t>=n;case"eq":return t===n;case"ne":return t!==n}if("boolean"==typeof t&&"boolean"==typeof n)switch(e){case"and":return t&&n;case"or":return t||n;case"eq":return t===n;case"ne":return t!==n}if("or"===e||"shl"===e||"shr"===e){const s="boolean"==typeof t?t?1n:0n:t,o="boolean"==typeof n?n?1n:0n:n;if("bigint"==typeof s&&"bigint"==typeof o)switch(e){case"or":return s|o;case"shl":return s<<o;case"shr":return s>>o}}}getResultType(e,t){return"boolean"===t?v.Scalar.bool:"bigint"===t?v.Scalar.uint256:v.Scalar.bool}canFoldHash(e,t){if("hash"!==e.kind)return!1;return"string"==typeof this.getConstantValue(e.value,t)}foldHash(e,t){const n=this.getConstantValue(e.value,t);if("string"!=typeof n)return null;const s=(new TextEncoder).encode(n),o=(0,on.So)(s);let r=0n;for(let i=0;i<o.length;i++)r=r<<8n|BigInt(o[i]);return{kind:"const",value:r,type:v.Scalar.bytes32,dest:e.dest,operationDebug:j(e)}}canFoldLength(e){return e.kind,!1}foldLength(e){return null}}class an extends sn{constructor(){super(...arguments),this.name="dead-code-elimination"}run(e,t){const n=this.cloneModule(e);return this.processAllFunctions(n,(e=>{const n=new Set;for(const t of e.blocks.values()){if(t.phis)for(const e of t.phis)this.collectUsedValues(e,n);for(const e of t.instructions)this.collectUsedValues(e,n);if("branch"===t.terminator.kind)this.collectValueUse(t.terminator.condition,n);else if("return"===t.terminator.kind&&t.terminator.value)this.collectValueUse(t.terminator.value,n);else if("call"===t.terminator.kind)for(const e of t.terminator.arguments)this.collectValueUse(e,n)}for(const s of e.blocks.values()){if(s.phis){const e=s.phis.filter((e=>!!n.has(e.dest)||(t.trackTransformation({type:"delete",pass:this.name,original:I(e),result:[],reason:`Removed unused phi node: ${e.dest}`}),!1)));s.phis=e}const e=[];for(const o of s.instructions)this.hasSideEffects(o)?e.push(o):"dest"in o&&o.dest&&!n.has(o.dest)?t.trackTransformation({type:"delete",pass:this.name,original:I(o),result:[],reason:`Removed unused instruction: ${o.kind} -> ${o.dest}`}):e.push(o);s.instructions=e}})),n}collectUsedValues(e,t){switch(e.kind){case"binary":this.collectValueUse(e.left,t),this.collectValueUse(e.right,t);break;case"unary":this.collectValueUse(e.operand,t);break;case"write":e.slot&&this.collectValueUse(e.slot,t),e.value&&this.collectValueUse(e.value,t),e.offset&&this.collectValueUse(e.offset,t),e.length&&this.collectValueUse(e.length,t);break;case"read":e.slot&&this.collectValueUse(e.slot,t),e.offset&&this.collectValueUse(e.offset,t),e.length&&this.collectValueUse(e.length,t);break;case"compute_slot":this.collectValueUse(e.base,t),w.ComputeSlot.isMapping(e)?this.collectValueUse(e.key,t):w.ComputeSlot.isArray(e);break;case"hash":case"cast":this.collectValueUse(e.value,t);break;case"length":this.collectValueUse(e.object,t);break;case"compute_offset":this.collectValueUse(e.base,t),w.ComputeOffset.isArray(e)?this.collectValueUse(e.index,t):w.ComputeOffset.isByte(e)&&this.collectValueUse(e.offset,t);break;case"allocate":this.collectValueUse(e.size,t);break;case"phi":for(const n of e.sources.values())this.collectValueUse(n,t)}}collectValueUse(e,t){"temp"===e.kind&&t.add(e.id)}hasSideEffects(e){switch(e.kind){case"write":case"allocate":return!0;default:return!1}}}class cn extends sn{constructor(){super(...arguments),this.name="common-subexpression-elimination"}run(e,t){const n=this.cloneModule(e);return this.processAllFunctions(n,(n=>{const s=(new T.Analyzer).analyze({...e,main:n}).dominatorTree,o=new Map,r=new Map,i=this.topologicalSort(n);for(const e of i){const i=n.blocks.get(e);if(!i)continue;const a=new Map,c=[];for(const n of i.instructions){const i=this.applyReplacements(n,o);if("binary"===i.kind||"unary"===i.kind||"compute_slot"===i.kind||"env"===i.kind){const n=this.getExpressionKey(i),l="compute_slot"===i.kind||"env"===i.kind;let u;if(l){const t=r.get(n);u=t&&this.dominates(t.block,e,s)?t.instruction:a.get(n)}else u=a.get(n);u&&"dest"in i&&"dest"in u?(u.operationDebug=A(u.operationDebug,i.operationDebug),o.set(i.dest,u.dest),t.trackTransformation({type:"delete",pass:this.name,original:I(i),result:[],reason:`Eliminated duplicate computation: ${n}`})):("dest"in i&&n&&(a.set(n,i),l&&r.set(n,{instruction:i,block:e})),c.push(i))}else this.hasSideEffects(i)?(a.clear(),c.push(i)):c.push(i)}i.instructions=c}for(const e of n.blocks.values()){for(const t of e.phis)if(t.sources)for(const[e,n]of t.sources){const s=this.applyValueReplacement(n,o);t.sources.set(e,s)}"branch"===e.terminator.kind?e.terminator.condition=this.applyValueReplacement(e.terminator.condition,o):"return"===e.terminator.kind&&e.terminator.value&&(e.terminator.value=this.applyValueReplacement(e.terminator.value,o))}})),n}applyValueReplacement(e,t){return"temp"===e.kind&&t.has(e.id)?{kind:"temp",id:t.get(e.id),type:e.type}:e}applyReplacements(e,t){const n={...e},s=e=>"temp"===e.kind&&t.has(e.id)?{kind:"temp",id:t.get(e.id),type:e.type}:e;switch(n.kind){case"binary":n.left=s(n.left),n.right=s(n.right);break;case"unary":n.operand=s(n.operand);break;case"write":n.slot&&(n.slot=s(n.slot)),n.value&&(n.value=s(n.value)),n.offset&&(n.offset=s(n.offset)),n.length&&(n.length=s(n.length));break;case"read":n.slot&&(n.slot=s(n.slot)),n.offset&&(n.offset=s(n.offset)),n.length&&(n.length=s(n.length));break;case"compute_slot":n.base=s(n.base),w.ComputeSlot.isMapping(n)?n.key=s(n.key):w.ComputeSlot.isArray(n);break;case"hash":n.value=s(n.value);break;case"length":n.object=s(n.object)}return n}getExpressionKey(e){if("binary"===e.kind){const t=this.getValueKey(e.left),n=this.getValueKey(e.right),s=this.getTypeKey(e.left.type),o=this.getTypeKey(e.right.type);return this.isCommutative(e.op)&&t>n?`${e.op}(${n}:${o},${t}:${s})`:`${e.op}(${t}:${s},${n}:${o})`}if("unary"===e.kind){const t=this.getValueKey(e.operand),n=this.getTypeKey(e.operand.type);return`${e.op}(${t}:${n})`}if("compute_slot"===e.kind){const t=this.getValueKey(e.base);if("field"===e.slotKind)return`compute_slot:field(${t},${e.fieldOffset})`;if("mapping"===e.slotKind){return`compute_slot:mapping(${t},${this.getValueKey(e.key)}:${e.keyType?this.getTypeKey(e.keyType):"unknown"})`}if("array"===e.slotKind)return`compute_slot:array(${t})`}else if("env"===e.kind)return`env:${e.op}`;return""}getValueKey(e){return"const"===e.kind?`const:${e.value}`:"temp"===e.kind?`temp:${e.id}`:"unknown"}getTypeKey(e){if(!e)return"unknown";switch(e.kind){case"scalar":return`scalar:${e.size}`;case"ref":return`ref:${e.location}`;default:return"unknown"}}isCommutative(e){return["add","mul","eq","ne","and","or"].includes(e)}hasSideEffects(e){return"write"===e.kind}topologicalSort(e){const t=new Set,n=[],s=o=>{if(t.has(o))return;t.add(o),n.push(o);const r=e.blocks.get(o);if(!r)return;const i=this.getSuccessors(r);for(const e of i)s(e)};s(e.entry);for(const o of e.blocks.keys())s(o);return n}getSuccessors(e){switch(e.terminator.kind){case"jump":return[e.terminator.target];case"branch":return[e.terminator.trueTarget,e.terminator.falseTarget];case"call":return[e.terminator.continuation];default:return[]}}dominates(e,t,n){let s=t;for(;null!==s;){if(s===e)return!0;s=n[s]||null}return!1}}class ln extends sn{constructor(){super(...arguments),this.name="constant-propagation"}run(e,t){const n=this.cloneModule(e);return this.processAllFunctions(n,(e=>{const n=new Map,s=new Map;for(const o of e.blocks.values()){const e=[];for(const r of o.instructions){let o=r;if("const"===r.kind&&"dest"in r)n.set(r.dest,r.value),r.operationDebug&&s.set(r.dest,r.operationDebug);else{const e=this.propagateConstantsIntoInstruction(r,n,s);e!==r&&(o=e,t.trackTransformation({type:"replace",pass:this.name,original:I(r),result:I(o),reason:"Propagated constants into instruction operands"})),this.hasSideEffects(r)&&(n.clear(),s.clear())}e.push(o)}o.instructions=e}})),n}propagateConstantsIntoInstruction(e,t,n){const s={...e},o=[],r=e=>{if("temp"===e.kind){const s=t.get(e.id);if(void 0!==s){const t=n.get(e.id);return t&&o.push(t),{kind:"const",value:s,type:e.type||this.getTypeForValue(s)}}}return e};switch(s.kind){case"binary":s.left=r(s.left),s.right=r(s.right);break;case"unary":s.operand=r(s.operand);break;case"write":s.slot&&(s.slot=r(s.slot)),s.value&&(s.value=r(s.value)),s.offset&&(s.offset=r(s.offset)),s.length&&(s.length=r(s.length));break;case"read":s.slot&&(s.slot=r(s.slot)),s.offset&&(s.offset=r(s.offset)),s.length&&(s.length=r(s.length));break;case"compute_slot":s.base=r(s.base),w.ComputeSlot.isMapping(s)?s.key=r(s.key):w.ComputeSlot.isArray(s);break;case"hash":case"cast":s.value=r(s.value);break;case"compute_offset":s.base=r(s.base),w.ComputeOffset.isArray(s)?s.index=r(s.index):w.ComputeOffset.isByte(s)&&(s.offset=r(s.offset));break;case"allocate":s.size=r(s.size);break;case"length":s.object=r(s.object)}const i=o.length>0;return i&&(s.operationDebug=A(e.operationDebug,...o)),i?s:e}getTypeForValue(e){return"boolean"==typeof e?v.Scalar.bool:"bigint"==typeof e?v.Scalar.uint256:v.Ref.memory()}hasSideEffects(e){return"write"===e.kind}}class un extends sn{constructor(){super(...arguments),this.name="jump-optimization"}run(e,t){const n=this.cloneModule(e);return this.processAllFunctions(n,(e=>{const n=new Map;for(const[t,i]of e.blocks)0===i.instructions.length&&"jump"===i.terminator.kind&&n.set(t,i.terminator.target);const s=new Map;for(const[i,a]of e.blocks)if("jump"===a.terminator.kind){const e=a.terminator.target,o=this.resolveJumpChain(e,n);o!==e&&(s.has(o)||s.set(o,new Map),s.get(o).set(i,e),t.trackTransformation({type:"replace",pass:this.name,original:I(a),result:I(a),reason:`Optimized jump chain: ${e} -> ${o}`}),a.terminator.target=o)}else if("branch"===a.terminator.kind){const e=a.terminator.trueTarget,o=this.resolveJumpChain(e,n),r=a.terminator.falseTarget,c=this.resolveJumpChain(r,n);o!==e&&(s.has(o)||s.set(o,new Map),s.get(o).set(i,e),t.trackTransformation({type:"replace",pass:this.name,original:I(a),result:I(a),reason:`Optimized true branch jump chain: ${e} -> ${o}`}),a.terminator.trueTarget=o),c!==r&&(s.has(c)||s.set(c,new Map),s.get(c).set(i,r),t.trackTransformation({type:"replace",pass:this.name,original:I(a),result:I(a),reason:`Optimized false branch jump chain: ${r} -> ${c}`}),a.terminator.falseTarget=c)}this.updatePhisForRedirections(e,s,n);const o=this.findReachableBlocks(e),r=[];for(const i of e.blocks.keys())if(!o.has(i)){r.push(i);const n=e.blocks.get(i);t.trackTransformation({type:"delete",pass:this.name,original:I(n),result:[],reason:`Removed unreachable block ${i}`})}for(const t of r)e.blocks.delete(t)})),n}resolveJumpChain(e,t){const n=new Set;let s=e;for(;t.has(s)&&!n.has(s);)n.add(s),s=t.get(s);return s}updatePhisForRedirections(e,t,n){for(const[s,o]of t){const t=e.blocks.get(s);if(!t)continue;for(const s of t.phis){const t=new Map(s.sources);for(const[r,i]of o)if(s.sources.has(i)){const o=s.sources.get(i),a=e.blocks.get(i);a&&a.phis.length,t.set(r,o),n.has(i)&&t.delete(i)}s.sources=t}const r=new Set;for(const e of t.predecessors){let t=!1;for(const[n,s]of o)s===e&&(r.add(n),t=!0);t||n.has(e)||r.add(e)}for(const e of o.keys())r.add(e);t.predecessors=r}}findReachableBlocks(e){const t=new Set,n=[e.entry];for(;n.length>0;){const s=n.pop();if(t.has(s))continue;t.add(s);const o=e.blocks.get(s);o&&("jump"===o.terminator.kind?n.push(o.terminator.target):"branch"===o.terminator.kind?(n.push(o.terminator.trueTarget),n.push(o.terminator.falseTarget)):"call"===o.terminator.kind&&n.push(o.terminator.continuation))}return t}}class dn extends sn{constructor(){super(...arguments),this.name="block-merging"}run(e,t){const n=this.cloneModule(e);return this.processAllFunctions(n,(e=>{const n=new Map;for(const[t,s]of e.blocks)if("jump"===s.terminator.kind&&1===s.predecessors.size){const o=e.blocks.get(s.terminator.target);o&&1===o.predecessors.size&&n.set(s.terminator.target,t)}for(const[s,o]of n){const n=e.blocks.get(s),r=e.blocks.get(o);if(n&&r){n.phis&&r.phis&&r.phis.push(...n.phis),r.instructions.push(...n.instructions),r.terminator=n.terminator,r.debug=A(r.debug,n.debug),t.trackTransformation({type:"merge",pass:this.name,original:I(r,n),result:I(r),reason:`Merged block ${s} into ${o}`}),e.blocks.delete(s);for(const t of e.blocks.values())t.predecessors.has(s)&&(t.predecessors.delete(s),t.predecessors.add(o)),"jump"===t.terminator.kind&&t.terminator.target===s?t.terminator.target=o:"branch"===t.terminator.kind&&(t.terminator.trueTarget===s&&(t.terminator.trueTarget=o),t.terminator.falseTarget===s&&(t.terminator.falseTarget=o))}}})),n}}class pn extends sn{constructor(){super(...arguments),this.name="return-merging"}run(e,t){const n=this.cloneModule(e);return this.processAllFunctions(n,(e=>{const n=new Map;for(const[t,s]of e.blocks)if("return"===s.terminator.kind){const e=this.getReturnSignature(s.terminator.value);n.has(e)||n.set(e,[]),n.get(e).push(t)}for(const[,s]of n)if(s.length>1){const n=s[0],o=e.blocks.get(n);for(let r=1;r<s.length;r++){const i=s[r],a=e.blocks.get(i);if(0===a.instructions.length){for(const[,s]of e.blocks)"jump"===s.terminator.kind&&s.terminator.target===i?(s.terminator.target=n,t.trackTransformation({type:"replace",pass:this.name,original:I(s),result:I(s),reason:`Redirected jump from ${i} to ${n} (return merging)`})):"branch"===s.terminator.kind&&(s.terminator.trueTarget===i&&(s.terminator.trueTarget=n,t.trackTransformation({type:"replace",pass:this.name,original:I(s),result:I(s),reason:`Redirected true branch from ${i} to ${n} (return merging)`})),s.terminator.falseTarget===i&&(s.terminator.falseTarget=n,t.trackTransformation({type:"replace",pass:this.name,original:I(s),result:I(s),reason:`Redirected false branch from ${i} to ${n} (return merging)`})));for(const e of a.predecessors)o.predecessors.add(e);o.predecessors.delete(i);for(const[,t]of e.blocks)t.predecessors.has(i)&&(t.predecessors.delete(i),t.predecessors.add(n));e.blocks.delete(i),t.trackTransformation({type:"delete",pass:this.name,original:I(a),result:[],reason:`Merged return block ${i} into ${n}`})}}}})),n}getReturnSignature(e){return e?"const"===e.kind?`const:${e.type.kind}:${e.value}`:"temp"===e.kind?`temp:${e.id}`:"unknown":"void"}}class mn extends sn{constructor(){super(...arguments),this.name="read-write-merging",this.nextTempCounter=0}run(e,t){const n=this.cloneModule(e);return this.nextTempCounter=this.findHighestTempNumber(n)+1,this.processAllFunctions(n,(e=>{for(const n of e.blocks.values()){const e=[];let s=0;for(;s<n.instructions.length;){const o=n.instructions[s];if("write"===o.kind){const r=this.findMergeableWrites(n.instructions,s);if(r.length>1){const n=this.mergeWrites(r,t);e.push(...n),s+=r.length}else e.push(o),s++}else e.push(o),s++}n.instructions=e}})),n}findHighestTempNumber(e){let t=-1;const n=e=>{if("temp"===e.kind){const n=e.id.match(/^t(\d+)$/);n&&(t=Math.max(t,parseInt(n[1],10)))}},s=e=>{if("dest"in e&&"string"==typeof e.dest){const n=e.dest.match(/^t(\d+)$/);n&&(t=Math.max(t,parseInt(n[1],10)))}"left"in e&&e.left&&"object"==typeof e.left&&n(e.left),"right"in e&&e.right&&"object"==typeof e.right&&n(e.right),"value"in e&&e.value&&"object"==typeof e.value&&n(e.value),"operand"in e&&e.operand&&"object"==typeof e.operand&&n(e.operand),"slot"in e&&e.slot&&"object"==typeof e.slot&&n(e.slot),"offset"in e&&e.offset&&"object"==typeof e.offset&&n(e.offset),"length"in e&&e.length&&"object"==typeof e.length&&n(e.length),"base"in e&&e.base&&"object"==typeof e.base&&n(e.base),"key"in e&&e.key&&"object"==typeof e.key&&n(e.key),"index"in e&&e.index&&"object"==typeof e.index&&n(e.index),"size"in e&&e.size&&"object"==typeof e.size&&n(e.size),"object"in e&&e.object&&"object"==typeof e.object&&n(e.object)};return this.processAllFunctions(e,(e=>{for(const o of e.blocks.values()){if(o.phis)for(const e of o.phis){const s=e.dest.match(/^t(\d+)$/);s&&(t=Math.max(t,parseInt(s[1],10)));for(const t of e.sources.values())n(t)}for(const e of o.instructions)s(e);"condition"in o.terminator&&o.terminator.condition&&n(o.terminator.condition),"value"in o.terminator&&o.terminator.value&&n(o.terminator.value)}})),t}findMergeableWrites(e,t){const n=[],s=e[t];if("write"!==s.kind)return n;n.push(s);for(let o=t+1;o<e.length;o++){const t=e[o];if("write"!==t.kind)break;if(!this.canMergeWith(s,t))break;n.push(t)}return n}canMergeWith(e,t){return e.location===t.location&&(("storage"===e.location||"transient"===e.location)&&(!(!e.slot||!t.slot)&&(!!this.isSameValue(e.slot,t.slot)&&("const"===e.offset?.kind&&"const"===e.length?.kind&&"const"===t.offset?.kind&&"const"===t.length?.kind))))}isSameValue(e,t){return e.kind===t.kind&&("const"===e.kind&&"const"===t.kind?e.value===t.value:"temp"===e.kind&&"temp"===t.kind&&e.id===t.id)}mergeWrites(e,t){if(1===e.length)return e;const n=e.map((e=>({write:e,offset:"const"===e.offset?.kind?BigInt(e.offset.value):0n,length:"const"===e.length?.kind?BigInt(e.length.value):32n})));n.sort(((e,t)=>Number(e.offset-t.offset)));if(!this.areWritesAdjacent(n))return e;const s=[];let o=this.nextTempCounter,r=null,i={};for(let u=0;u<n.length;u++){const e=n[u],t=8n*e.offset;if(i=A(i,e.write.operationDebug),t>0n){const n="t"+o++;s.push({kind:"binary",op:"shl",left:e.write.value,right:{kind:"const",value:t,type:v.Scalar.uint256},dest:n,operationDebug:i});const a={kind:"temp",id:n,type:v.Scalar.uint256};if(null===r)r=a;else{const e="t"+o++;s.push({kind:"binary",op:"or",left:r,right:a,dest:e,operationDebug:i}),r={kind:"temp",id:e,type:v.Scalar.uint256}}}else if(null===r)r=e.write.value;else{const t="t"+o++;s.push({kind:"binary",op:"or",left:r,right:e.write.value,dest:t,operationDebug:i}),r={kind:"temp",id:t,type:v.Scalar.uint256}}}const a=n[0].offset,c=n.reduce(((e,t)=>{const n=t.offset+t.length;return n>e?n:e}),a+n[0].length)-a,l={kind:"write",location:e[0].location,slot:e[0].slot,offset:a>0n?{kind:"const",value:a,type:v.Scalar.uint256}:void 0,length:{kind:"const",value:c,type:v.Scalar.uint256},value:r,operationDebug:i};return s.push(l),this.nextTempCounter=o,t.trackTransformation({type:"merge",pass:this.name,original:I(...e),result:I(...s),reason:`Merged ${e.length} writes to same location`}),s}areWritesAdjacent(e){for(let t=1;t<e.length;t++){const n=e[t-1];if(e[t].offset>n.offset+n.length)return!1}return!0}}class fn extends sn{constructor(){super(...arguments),this.name="tail-call-optimization"}run(e,t){const n=this.cloneModule(e);return this.processAllFunctions(n,((e,n)=>{const s=new Set,o=[];for(const[t,r]of e.blocks){if("call"!==r.terminator.kind)continue;const s=r.terminator;if(s.function!==n)continue;const i=e.blocks.get(s.continuation);if(!i)continue;if(i.phis.length>0||i.instructions.length>0||"return"!==i.terminator.kind)continue;const a=i.terminator;(void 0===s.dest&&void 0===a.value||void 0!==s.dest&&void 0!==a.value&&"temp"===a.value.kind&&a.value.id===s.dest)&&o.push(t)}if(o.length>0){const r=`${e.entry}_loop`;if(!e.blocks.get(e.entry))return;const i=[];for(let t=0;t<e.parameters.length;t++){const n=e.parameters[t],s=new Map;s.set(e.entry,{kind:"temp",id:n.tempId,type:n.type}),i.push({kind:"phi",sources:s,dest:`${n.tempId}_loop`,type:n.type,operationDebug:{context:void n.loc}})}const a={id:r,phis:i,instructions:[],terminator:{kind:"jump",target:e.entry,operationDebug:{}},predecessors:new Set([e.entry,...o]),debug:{}};e.blocks.set(r,a);for(const c of o){const o=e.blocks.get(c),a=o.terminator,l=e.blocks.get(a.continuation);for(let t=0;t<e.parameters.length;t++)t<a.arguments.length&&i[t].sources.set(c,a.arguments[t]);o.terminator={kind:"jump",target:r,operationDebug:a.operationDebug},t.trackTransformation({type:"replace",pass:this.name,original:[...I(o),...I(l)],result:I(o),reason:`Optimized tail-recursive call to ${n} into loop`});0===Array.from(l.predecessors).filter((e=>e!==c)).length?(s.add(a.continuation),t.trackTransformation({type:"delete",pass:this.name,original:I(l),result:[],reason:`Removed unused continuation block ${a.continuation}`})):l.predecessors.delete(c)}}for(const t of s)e.blocks.delete(t);for(const t of e.blocks.values())for(const e of s)t.predecessors.delete(e)})),n}}function hn(e,t){if(0===t)return e;const n=function(e){const t=[];if(0===e)return t;e>=1&&t.push(new rn,new ln,new an);e>=2&&t.push(new cn,new fn,new un);e>=3&&t.push(new dn,new pn,new mn);return t}(t),s=new nn(n);let o=e,r="";do{const e=JSON.stringify(o);if(e===r)break;r=e;o=s.optimize(o).module}while(t>=2);return o}const gn={async run({source:e}){const t=z(e);return _.map(t,(e=>({ast:e})))}},yn={run:async({ast:e})=>_.map(ct(e),(({types:e,bindings:t})=>({types:e,bindings:t})))},bn={run:async({ast:e,types:t})=>_.map(en(e,t),(e=>({ir:e})))},kn={run:async({ir:e,optimizer:{level:t=0}={}})=>_.ok({ir:hn(e,t)})},vn=E.makeControls({slice:(e,...t)=>({...e,stack:e.stack.slice(...t),brands:e.brands.slice(...t)}),prepend:(e,t)=>({...e,stack:[{id:t.id},...e.stack],brands:[t.brand,...e.brands]}),create:(e,t)=>({id:e,brand:t}),duplicate:(e,t)=>({...e,id:t}),rebrand:(e,t)=>({...e,brand:t}),readTop:(e,t)=>{const n=[];for(let s=0;s<t&&s<e.stack.length;s++)n.push({...e.stack[s],brand:e.brands[s]});return n},generateId:(e,t="id")=>({id:`${t}_${e.nextId}`,state:{...e,nextId:e.nextId+1}}),emit:(e,t)=>({...e,instructions:[...e.instructions,t]})}),xn=O(vn),wn=xn.rebrand,Tn=xn.rebrandTop,En=(e=>()=>new U(e,(e=>e)))(vn),Sn=(e=>{const{mapInstruction:t,makeOperationForInstruction:n,makeOperationWithImmediatesForInstruction:s}=S.makeUsing(e);return{...t({opcode:0,mnemonic:"STOP"},n({consumes:[],produces:[]})),...t({opcode:1,mnemonic:"ADD"},n({consumes:["a","b"],produces:["a + b"]})),...t({opcode:2,mnemonic:"MUL"},n({consumes:["a","b"],produces:["a * b"]})),...t({opcode:3,mnemonic:"SUB"},n({consumes:["a","b"],produces:["a - b"]})),...t({opcode:4,mnemonic:"DIV"},n({consumes:["a","b"],produces:["a // b"]})),...t({opcode:5,mnemonic:"SDIV"},n({consumes:["a","b"],produces:["a // b"]})),...t({opcode:6,mnemonic:"MOD"},n({consumes:["a","b"],produces:["a % b"]})),...t({opcode:7,mnemonic:"SMOD"},n({consumes:["a","b"],produces:["a % b"]})),...t({opcode:8,mnemonic:"ADDMOD"},n({consumes:["a","b","N"],produces:["(a + b) % N"]})),...t({opcode:9,mnemonic:"MULMOD"},n({consumes:["a","b","N"],produces:["(a * b) % N"]})),...t({opcode:10,mnemonic:"EXP"},n({consumes:["a","exponent"],produces:["a ** exponent"]})),...t({opcode:11,mnemonic:"SIGNEXTEND"},n({consumes:["b","x"],produces:["y"]})),...t({opcode:16,mnemonic:"LT"},n({consumes:["a","b"],produces:["a < b"]})),...t({opcode:17,mnemonic:"GT"},n({consumes:["a","b"],produces:["a > b"]})),...t({opcode:18,mnemonic:"SLT"},n({consumes:["a","b"],produces:["a < b"]})),...t({opcode:19,mnemonic:"SGT"},n({consumes:["a","b"],produces:["a > b"]})),...t({opcode:20,mnemonic:"EQ"},n({consumes:["a","b"],produces:["a == b"]})),...t({opcode:21,mnemonic:"ISZERO"},n({consumes:["a"],produces:["a == 0"]})),...t({opcode:22,mnemonic:"AND"},n({consumes:["a","b"],produces:["a & b"]})),...t({opcode:23,mnemonic:"OR"},n({consumes:["a","b"],produces:["a | b"]})),...t({opcode:24,mnemonic:"XOR"},n({consumes:["a","b"],produces:["a ^ b"]})),...t({opcode:25,mnemonic:"NOT"},n({consumes:["a"],produces:["~a"]})),...t({opcode:26,mnemonic:"BYTE"},n({consumes:["i","x"],produces:["y"]})),...t({opcode:27,mnemonic:"SHL"},n({consumes:["shift","value"],produces:["value << shift"]})),...t({opcode:28,mnemonic:"SHR"},n({consumes:["shift","value"],produces:["value >> shift"]})),...t({opcode:29,mnemonic:"SAR"},n({consumes:["shift","value"],produces:["value >> shift"]})),...t({opcode:32,mnemonic:"KECCAK256"},n({consumes:["offset","size"],produces:["hash"]})),...t({opcode:48,mnemonic:"ADDRESS"},n({consumes:[],produces:["address"]})),...t({opcode:49,mnemonic:"BALANCE"},n({consumes:["address"],produces:["balance"]})),...t({opcode:50,mnemonic:"ORIGIN"},n({consumes:[],produces:["address"]})),...t({opcode:51,mnemonic:"CALLER"},n({consumes:[],produces:["address"]})),...t({opcode:52,mnemonic:"CALLVALUE"},n({consumes:[],produces:["value"]})),...t({opcode:53,mnemonic:"CALLDATALOAD"},n({consumes:["i"],produces:["data[i]"]})),...t({opcode:54,mnemonic:"CALLDATASIZE"},n({consumes:[],produces:["size"]})),...t({opcode:55,mnemonic:"CALLDATACOPY"},n({consumes:["destOffset","offset","size"],produces:[]})),...t({opcode:56,mnemonic:"CODESIZE"},n({consumes:[],produces:["size"]})),...t({opcode:57,mnemonic:"CODECOPY"},n({consumes:["destOffset","offset","size"],produces:[]})),...t({opcode:58,mnemonic:"GASPRICE"},n({consumes:[],produces:["price"]})),...t({opcode:59,mnemonic:"EXTCODESIZE"},n({consumes:["address"],produces:["size"]})),...t({opcode:60,mnemonic:"EXTCODECOPY"},n({consumes:["address","destOffset","offset","size"],produces:[]})),...t({opcode:61,mnemonic:"RETURNDATASIZE"},n({consumes:[],produces:["size"]})),...t({opcode:62,mnemonic:"RETURNDATACOPY"},n({consumes:["destOffset","offset","size"],produces:[]})),...t({opcode:63,mnemonic:"EXTCODEHASH"},n({consumes:["address"],produces:["hash"]})),...t({opcode:64,mnemonic:"BLOCKHASH"},n({consumes:["blockNumber"],produces:["hash"]})),...t({opcode:65,mnemonic:"COINBASE"},n({consumes:[],produces:["address"]})),...t({opcode:66,mnemonic:"TIMESTAMP"},n({consumes:[],produces:["timestamp"]})),...t({opcode:67,mnemonic:"NUMBER"},n({consumes:[],produces:["blockNumber"]})),...t({opcode:68,mnemonic:"PREVRANDAO"},n({consumes:[],produces:["difficulty"]})),...t({opcode:69,mnemonic:"GASLIMIT"},n({consumes:[],produces:["gasLimit"]})),...t({opcode:70,mnemonic:"CHAINID"},n({consumes:[],produces:["chainId"]})),...t({opcode:71,mnemonic:"SELFBALANCE"},n({consumes:[],produces:["balance"]})),...t({opcode:72,mnemonic:"BASEFEE"},n({consumes:[],produces:["baseFee"]})),...t({opcode:73,mnemonic:"BLOBHASH"},n({consumes:["index"],produces:["blobVersionedHashesAtIndex"]})),...t({opcode:74,mnemonic:"BLOBBASEFEE"},n({consumes:[],produces:["blobBaseFee"]})),...t({opcode:80,mnemonic:"POP"},n({consumes:["y"],produces:[]})),...t({opcode:81,mnemonic:"MLOAD"},n({consumes:["offset"],produces:["value"]})),...t({opcode:82,mnemonic:"MSTORE"},n({consumes:["offset","value"],produces:[]})),...t({opcode:83,mnemonic:"MSTORE8"},n({consumes:["offset","value"],produces:[]})),...t({opcode:84,mnemonic:"SLOAD"},n({consumes:["key"],produces:["value"]})),...t({opcode:85,mnemonic:"SSTORE"},n({consumes:["key","value"],produces:[]})),...t({opcode:86,mnemonic:"JUMP"},n({consumes:["counter"],produces:[]})),...t({opcode:87,mnemonic:"JUMPI"},n({consumes:["counter","b"],produces:[]})),...t({opcode:88,mnemonic:"PC"},n({consumes:[],produces:["counter"]})),...t({opcode:89,mnemonic:"MSIZE"},n({consumes:[],produces:["size"]})),...t({opcode:90,mnemonic:"GAS"},n({consumes:[],produces:["gas"]})),...t({opcode:91,mnemonic:"JUMPDEST"},n({consumes:[],produces:[]})),...t({opcode:92,mnemonic:"TLOAD"},n({consumes:["key"],produces:["value"]})),...t({opcode:93,mnemonic:"TSTORE"},n({consumes:["key","value"],produces:[]})),...t({opcode:94,mnemonic:"MCOPY"},n({consumes:["destOffset","offset","size"],produces:[]})),...t({opcode:95,mnemonic:"PUSH0"},n({consumes:[],produces:["value"]})),...t({opcode:96,mnemonic:"PUSH1"},s({consumes:[],produces:["value"]})),...t({opcode:97,mnemonic:"PUSH2"},s({consumes:[],produces:["value"]})),...t({opcode:98,mnemonic:"PUSH3"},s({consumes:[],produces:["value"]})),...t({opcode:99,mnemonic:"PUSH4"},s({consumes:[],produces:["value"]})),...t({opcode:100,mnemonic:"PUSH5"},s({consumes:[],produces:["value"]})),...t({opcode:101,mnemonic:"PUSH6"},s({consumes:[],produces:["value"]})),...t({opcode:102,mnemonic:"PUSH7"},s({consumes:[],produces:["value"]})),...t({opcode:103,mnemonic:"PUSH8"},s({consumes:[],produces:["value"]})),...t({opcode:104,mnemonic:"PUSH9"},s({consumes:[],produces:["value"]})),...t({opcode:105,mnemonic:"PUSH10"},s({consumes:[],produces:["value"]})),...t({opcode:106,mnemonic:"PUSH11"},s({consumes:[],produces:["value"]})),...t({opcode:107,mnemonic:"PUSH12"},s({consumes:[],produces:["value"]})),...t({opcode:108,mnemonic:"PUSH13"},s({consumes:[],produces:["value"]})),...t({opcode:109,mnemonic:"PUSH14"},s({consumes:[],produces:["value"]})),...t({opcode:110,mnemonic:"PUSH15"},s({consumes:[],produces:["value"]})),...t({opcode:111,mnemonic:"PUSH16"},s({consumes:[],produces:["value"]})),...t({opcode:112,mnemonic:"PUSH17"},s({consumes:[],produces:["value"]})),...t({opcode:113,mnemonic:"PUSH18"},s({consumes:[],produces:["value"]})),...t({opcode:114,mnemonic:"PUSH19"},s({consumes:[],produces:["value"]})),...t({opcode:115,mnemonic:"PUSH20"},s({consumes:[],produces:["value"]})),...t({opcode:116,mnemonic:"PUSH21"},s({consumes:[],produces:["value"]})),...t({opcode:117,mnemonic:"PUSH22"},s({consumes:[],produces:["value"]})),...t({opcode:118,mnemonic:"PUSH23"},s({consumes:[],produces:["value"]})),...t({opcode:119,mnemonic:"PUSH24"},s({consumes:[],produces:["value"]})),...t({opcode:120,mnemonic:"PUSH25"},s({consumes:[],produces:["value"]})),...t({opcode:121,mnemonic:"PUSH26"},s({consumes:[],produces:["value"]})),...t({opcode:122,mnemonic:"PUSH27"},s({consumes:[],produces:["value"]})),...t({opcode:123,mnemonic:"PUSH28"},s({consumes:[],produces:["value"]})),...t({opcode:124,mnemonic:"PUSH29"},s({consumes:[],produces:["value"]})),...t({opcode:125,mnemonic:"PUSH30"},s({consumes:[],produces:["value"]})),...t({opcode:126,mnemonic:"PUSH31"},s({consumes:[],produces:["value"]})),...t({opcode:127,mnemonic:"PUSH32"},s({consumes:[],produces:["value"]})),...t({opcode:128,mnemonic:"DUP1"},(t=>n=>s=>{const[o]=e.topN(s,1),{id:r,state:i}=e.generateId(s,"dup"),a=e.push(i,e.duplicate(o,r));return e.emit(a,{...t,...n})})),...t({opcode:129,mnemonic:"DUP2"},(t=>n=>s=>{const[o,r]=e.topN(s,2),{id:i,state:a}=e.generateId(s,"dup"),c=e.push(a,e.duplicate(r,i));return e.emit(c,{...t,...n})})),...t({opcode:130,mnemonic:"DUP3"},(t=>n=>s=>{const[o,r,i]=e.topN(s,3),{id:a,state:c}=e.generateId(s,"dup"),l=e.push(c,e.duplicate(i,a));return e.emit(l,{...t,...n})})),...t({opcode:131,mnemonic:"DUP4"},(t=>n=>s=>{const[o,r,i,a]=e.topN(s,4),{id:c,state:l}=e.generateId(s,"dup"),u=e.push(l,e.duplicate(a,c));return e.emit(u,{...t,...n})})),...t({opcode:132,mnemonic:"DUP5"},(t=>n=>s=>{const[o,r,i,a,c]=e.topN(s,5),{id:l,state:u}=e.generateId(s,"dup"),d=e.push(u,e.duplicate(c,l));return e.emit(d,{...t,...n})})),...t({opcode:133,mnemonic:"DUP6"},(t=>n=>s=>{const[o,r,i,a,c,l]=e.topN(s,6),{id:u,state:d}=e.generateId(s,"dup"),p=e.push(d,e.duplicate(l,u));return e.emit(p,{...t,...n})})),...t({opcode:134,mnemonic:"DUP7"},(t=>n=>s=>{const[o,r,i,a,c,l,u]=e.topN(s,7),{id:d,state:p}=e.generateId(s,"dup"),m=e.push(p,e.duplicate(u,d));return e.emit(m,{...t,...n})})),...t({opcode:135,mnemonic:"DUP8"},(t=>n=>s=>{const[o,r,i,a,c,l,u,d]=e.topN(s,8),{id:p,state:m}=e.generateId(s,"dup"),f=e.push(m,e.duplicate(d,p));return e.emit(f,{...t,...n})})),...t({opcode:136,mnemonic:"DUP9"},(t=>n=>s=>{const[o,r,i,a,c,l,u,d,p]=e.topN(s,9),{id:m,state:f}=e.generateId(s,"dup"),h=e.push(f,e.duplicate(p,m));return e.emit(h,{...t,...n})})),...t({opcode:137,mnemonic:"DUP10"},(t=>n=>s=>{const[o,r,i,a,c,l,u,d,p,m]=e.topN(s,10),{id:f,state:h}=e.generateId(s,"dup"),g=e.push(h,e.duplicate(m,f));return e.emit(g,{...t,...n})})),...t({opcode:138,mnemonic:"DUP11"},(t=>n=>s=>{const[o,r,i,a,c,l,u,d,p,m,f]=e.topN(s,11),{id:h,state:g}=e.generateId(s,"dup"),y=e.push(g,e.duplicate(f,h));return e.emit(y,{...t,...n})})),...t({opcode:139,mnemonic:"DUP12"},(t=>n=>s=>{const[o,r,i,a,c,l,u,d,p,m,f,h]=e.topN(s,12),{id:g,state:y}=e.generateId(s,"dup"),b=e.push(y,e.duplicate(h,g));return e.emit(b,{...t,...n})})),...t({opcode:140,mnemonic:"DUP13"},(t=>n=>s=>{const[o,r,i,a,c,l,u,d,p,m,f,h,g]=e.topN(s,13),{id:y,state:b}=e.generateId(s,"dup"),k=e.push(b,e.duplicate(g,y));return e.emit(k,{...t,...n})})),...t({opcode:141,mnemonic:"DUP14"},(t=>n=>s=>{const[o,r,i,a,c,l,u,d,p,m,f,h,g,y]=e.topN(s,14),{id:b,state:k}=e.generateId(s,"dup"),v=e.push(k,e.duplicate(y,b));return e.emit(v,{...t,...n})})),...t({opcode:142,mnemonic:"DUP15"},(t=>n=>s=>{const[o,r,i,a,c,l,u,d,p,m,f,h,g,y,b]=e.topN(s,15),{id:k,state:v}=e.generateId(s,"dup"),x=e.push(v,e.duplicate(b,k));return e.emit(x,{...t,...n})})),...t({opcode:143,mnemonic:"DUP16"},(t=>n=>s=>{const[o,r,i,a,c,l,u,d,p,m,f,h,g,y,b,k]=e.topN(s,16),{id:v,state:x}=e.generateId(s,"dup"),w=e.push(x,e.duplicate(k,v));return e.emit(w,{...t,...n})})),...t({opcode:144,mnemonic:"SWAP1"},(t=>n=>s=>{const[o,r]=e.topN(s,2);let i=e.popN(s,2);return i=e.push(i,o),i=e.push(i,r),e.emit(i,{...t,...n})})),...t({opcode:145,mnemonic:"SWAP2"},(t=>n=>s=>{const[o,r,i]=e.topN(s,3);let a=e.popN(s,3);return a=e.push(a,o),a=e.push(a,r),a=e.push(a,i),e.emit(a,{...t,...n})})),...t({opcode:146,mnemonic:"SWAP3"},(t=>n=>s=>{const[o,r,i,a]=e.topN(s,4);let c=e.popN(s,4);return c=e.push(c,o),c=e.push(c,i),c=e.push(c,r),c=e.push(c,a),e.emit(c,{...t,...n})})),...t({opcode:147,mnemonic:"SWAP4"},(t=>n=>s=>{const[o,r,i,a,c]=e.topN(s,5);let l=e.popN(s,5);return l=e.push(l,o),l=e.push(l,a),l=e.push(l,i),l=e.push(l,r),l=e.push(l,c),e.emit(l,{...t,...n})})),...t({opcode:148,mnemonic:"SWAP5"},(t=>n=>s=>{const[o,r,i,a,c,l]=e.topN(s,6);let u=e.popN(s,6);return u=e.push(u,o),u=e.push(u,c),u=e.push(u,a),u=e.push(u,i),u=e.push(u,r),u=e.push(u,l),e.emit(u,{...t,...n})})),...t({opcode:149,mnemonic:"SWAP6"},(t=>n=>s=>{const[o,r,i,a,c,l,u]=e.topN(s,7);let d=e.popN(s,7);return d=e.push(d,o),d=e.push(d,l),d=e.push(d,c),d=e.push(d,a),d=e.push(d,i),d=e.push(d,r),d=e.push(d,u),e.emit(d,{...t,...n})})),...t({opcode:150,mnemonic:"SWAP7"},(t=>n=>s=>{const[o,r,i,a,c,l,u,d]=e.topN(s,8);let p=e.popN(s,8);return p=e.push(p,o),p=e.push(p,u),p=e.push(p,l),p=e.push(p,c),p=e.push(p,a),p=e.push(p,i),p=e.push(p,r),p=e.push(p,d),e.emit(p,{...t,...n})})),...t({opcode:151,mnemonic:"SWAP8"},(t=>n=>s=>{const[o,r,i,a,c,l,u,d,p]=e.topN(s,9);let m=e.popN(s,9);return m=e.push(m,o),m=e.push(m,d),m=e.push(m,u),m=e.push(m,l),m=e.push(m,c),m=e.push(m,a),m=e.push(m,i),m=e.push(m,r),m=e.push(m,p),e.emit(m,{...t,...n})})),...t({opcode:152,mnemonic:"SWAP9"},(t=>n=>s=>{const[o,r,i,a,c,l,u,d,p,m]=e.topN(s,10);let f=e.popN(s,10);return f=e.push(f,o),f=e.push(f,p),f=e.push(f,d),f=e.push(f,u),f=e.push(f,l),f=e.push(f,c),f=e.push(f,a),f=e.push(f,i),f=e.push(f,r),f=e.push(f,m),e.emit(f,{...t,...n})})),...t({opcode:153,mnemonic:"SWAP10"},(t=>n=>s=>{const[o,r,i,a,c,l,u,d,p,m,f]=e.topN(s,11);let h=e.popN(s,11);return h=e.push(h,o),h=e.push(h,m),h=e.push(h,p),h=e.push(h,d),h=e.push(h,u),h=e.push(h,l),h=e.push(h,c),h=e.push(h,a),h=e.push(h,i),h=e.push(h,r),h=e.push(h,f),e.emit(h,{...t,...n})})),...t({opcode:154,mnemonic:"SWAP11"},(t=>n=>s=>{const[o,r,i,a,c,l,u,d,p,m,f,h]=e.topN(s,12);let g=e.popN(s,12);return g=e.push(g,o),g=e.push(g,f),g=e.push(g,m),g=e.push(g,p),g=e.push(g,d),g=e.push(g,u),g=e.push(g,l),g=e.push(g,c),g=e.push(g,a),g=e.push(g,i),g=e.push(g,r),g=e.push(g,h),e.emit(g,{...t,...n})})),...t({opcode:155,mnemonic:"SWAP12"},(t=>n=>s=>{const[o,r,i,a,c,l,u,d,p,m,f,h,g]=e.topN(s,13);let y=e.popN(s,13);return y=e.push(y,o),y=e.push(y,h),y=e.push(y,f),y=e.push(y,m),y=e.push(y,p),y=e.push(y,d),y=e.push(y,u),y=e.push(y,l),y=e.push(y,c),y=e.push(y,a),y=e.push(y,i),y=e.push(y,r),y=e.push(y,g),e.emit(y,{...t,...n})})),...t({opcode:156,mnemonic:"SWAP13"},(t=>n=>s=>{const[o,r,i,a,c,l,u,d,p,m,f,h,g,y]=e.topN(s,14);let b=e.popN(s,14);return b=e.push(b,o),b=e.push(b,g),b=e.push(b,h),b=e.push(b,f),b=e.push(b,m),b=e.push(b,p),b=e.push(b,d),b=e.push(b,u),b=e.push(b,l),b=e.push(b,c),b=e.push(b,a),b=e.push(b,i),b=e.push(b,r),b=e.push(b,y),e.emit(b,{...t,...n})})),...t({opcode:157,mnemonic:"SWAP14"},(t=>n=>s=>{const[o,r,i,a,c,l,u,d,p,m,f,h,g,y,b]=e.topN(s,15);let k=e.popN(s,15);return k=e.push(k,o),k=e.push(k,y),k=e.push(k,g),k=e.push(k,h),k=e.push(k,f),k=e.push(k,m),k=e.push(k,p),k=e.push(k,d),k=e.push(k,u),k=e.push(k,l),k=e.push(k,c),k=e.push(k,a),k=e.push(k,i),k=e.push(k,r),k=e.push(k,b),e.emit(k,{...t,...n})})),...t({opcode:158,mnemonic:"SWAP15"},(t=>n=>s=>{const[o,r,i,a,c,l,u,d,p,m,f,h,g,y,b,k]=e.topN(s,16);let v=e.popN(s,16);return v=e.push(v,o),v=e.push(v,b),v=e.push(v,y),v=e.push(v,g),v=e.push(v,h),v=e.push(v,f),v=e.push(v,m),v=e.push(v,p),v=e.push(v,d),v=e.push(v,u),v=e.push(v,l),v=e.push(v,c),v=e.push(v,a),v=e.push(v,i),v=e.push(v,r),v=e.push(v,k),e.emit(v,{...t,...n})})),...t({opcode:159,mnemonic:"SWAP16"},(t=>n=>s=>{const[o,r,i,a,c,l,u,d,p,m,f,h,g,y,b,k,v]=e.topN(s,17);let x=e.popN(s,17);return x=e.push(x,o),x=e.push(x,k),x=e.push(x,b),x=e.push(x,y),x=e.push(x,g),x=e.push(x,h),x=e.push(x,f),x=e.push(x,m),x=e.push(x,p),x=e.push(x,d),x=e.push(x,u),x=e.push(x,l),x=e.push(x,c),x=e.push(x,a),x=e.push(x,i),x=e.push(x,r),x=e.push(x,v),e.emit(x,{...t,...n})})),...t({opcode:160,mnemonic:"LOG0"},n({consumes:["offset","size"],produces:[]})),...t({opcode:161,mnemonic:"LOG1"},n({consumes:["offset","size","topic"],produces:[]})),...t({opcode:162,mnemonic:"LOG2"},n({consumes:["offset","size","topic1","topic2"],produces:[]})),...t({opcode:163,mnemonic:"LOG3"},n({consumes:["offset","size","topic1","topic2","topic3"],produces:[]})),...t({opcode:164,mnemonic:"LOG4"},n({consumes:["offset","size","topic1","topic2","topic3","topic4"],produces:[]})),...t({opcode:240,mnemonic:"CREATE"},n({consumes:["value","offset","size"],produces:["address"]})),...t({opcode:241,mnemonic:"CALL"},n({consumes:["gas","address","value","argsOffset","argsSize","retOffset","retSize"],produces:["success"]})),...t({opcode:242,mnemonic:"CALLCODE"},n({consumes:["gas","address","value","argsOffset","argsSize","retOffset","retSize"],produces:["success"]})),...t({opcode:243,mnemonic:"RETURN"},n({consumes:["offset","size"],produces:[]})),...t({opcode:244,mnemonic:"DELEGATECALL"},n({consumes:["gas","address","argsOffset","argsSize","retOffset","retSize"],produces:["success"]})),...t({opcode:245,mnemonic:"CREATE2"},n({consumes:["value","offset","size","salt"],produces:["address"]})),...t({opcode:250,mnemonic:"STATICCALL"},n({consumes:["gas","address","argsOffset","argsSize","retOffset","retSize"],produces:["success"]})),...t({opcode:253,mnemonic:"REVERT"},n({consumes:["offset","size"],produces:[]})),...t({opcode:254,mnemonic:"INVALID"},n({consumes:[],produces:[]})),...t({opcode:255,mnemonic:"SELFDESTRUCT"},n({consumes:["address"],produces:[]}))}})(vn),Nn={...Sn,DUPn:(e,t)=>{if(e<1||e>16)throw new Error(`Cannot reach stack position ${e}`);const n=Sn[`DUP${e}`];return En().peek(((t,n)=>{if(t.stack.length<e)throw new Error("Stack too short");return n})).then(n(t),{as:"value"}).done()},PUSHn:(e,t)=>{if(0n===e)return Sn.PUSH0(t);const n=function(e){if(0n===e)return[];const t=e.toString(16),n=t.length%2?"0"+t:t,s=[];for(let o=0;o<n.length;o+=2)s.push(parseInt(n.substr(o,2),16));return s}(e);return(0,Sn[`PUSH${n.length}`])(n,t)}};function An(e){if("const"===e.kind)return`$const_${e.value}`;if("temp"===e.kind)return e.id;throw new Error(`Unknown value kind: ${e.kind}`)}const jn=e=>t=>{if(0===t.stack.length)throw new Error("Cannot annotate empty stack");const n=[...t.stack];return n[0]={...n[0],irValue:e},{...t,stack:n}},In=(e,t)=>{const{PUSHn:n,DUPn:s,MLOAD:o}=Nn,r=An(e);return"const"===e.kind?En().then(n(BigInt(e.value),t)).then(jn(r)).done():En().peek(((e,i)=>{const a=e.stack.findIndex((({irValue:e})=>e===r))+1;if(a>0&&a<=16)return i.then(s(a,t),{as:"value"});if(r in e.memory.allocations){const s=e.memory.allocations[r].offset;return i.then(n(BigInt(s),t),{as:"offset"}).then(o(t)).then(jn(r))}throw new Error(`Cannot load value ${r} - not in stack or memory`)})).done()},Dn=(e,t)=>{const{PUSHn:n,DUP2:s,SWAP1:o,MSTORE:r}=Nn;return En().then(jn(e)).peek(((i,a)=>{const c=i.memory.allocations[e];return void 0===c?a:a.then(n(BigInt(c.offset),t),{as:"offset"}).then(s(t)).then(o(t)).then(r(t))})).done()},{ADD:$n,SUB:Mn,MUL:Cn,DIV:On,MOD:Un,EQ:Ln,LT:Pn,GT:_n,AND:Bn,OR:Rn,ISZERO:Vn,SHL:zn,SHR:Fn}=Nn;const{NOT:Hn,PUSHn:qn,SUB:Wn}=Nn;var Kn;!function(e){e.STACK_TOO_DEEP="MEMORY_STACK_TOO_DEEP",e.ALLOCATION_FAILED="MEMORY_ALLOCATION_FAILED",e.INVALID_LAYOUT="MEMORY_INVALID_LAYOUT"}(Kn||(Kn={}));class Yn extends B{constructor(e,t,n){super(t,e,n,L.Error)}}const Gn=64,Jn=128;var Zn,Xn,Qn,es,ts,ns;function ss(e,t){const n=[...e];switch(t.kind){case"binary":case"hash":n.pop(),n.pop();break;case"compute_slot":n.pop(),"compute_slot"===t.kind&&w.ComputeSlot.isMapping(t)&&n.pop();break;case"unary":case"cast":case"length":n.pop();break;case"read":t.slot&&n.pop(),t.offset&&n.pop(),t.length&&n.pop();break;case"write":t.slot&&n.pop(),t.offset&&n.pop(),t.length&&n.pop(),n.pop();break;case"compute_offset":n.pop(),(w.ComputeOffset.isArray(t)||w.ComputeOffset.isByte(t))&&n.pop()}return"dest"in t&&t.dest&&n.push(t.dest),n}function os(e){if("const"===e.kind)return`$const_${e.value}`;if("temp"===e.kind)return e.id;throw new Error(`Unknown value kind: ${e.kind}`)}function rs(e){const t=new Set,n=e=>{e&&"const"!==e.kind&&t.add(os(e))};switch(e.kind){case"binary":n(e.left),n(e.right);break;case"unary":n(e.operand);break;case"compute_slot":n(e.base),w.ComputeSlot.isMapping(e)&&n(e.key);break;case"cast":case"hash":n(e.value);break;case"length":n(e.object)}return t}function is(e,t){const n=e.lastIndexOf(t);return-1===n?-1:e.length-1-n}function as(e){return"scalar"===e.kind?e.size:32}function cs(e,t){for(const n of t.parameters||[])if(n.tempId===e)return n.type;for(const[n,s]of t.blocks){for(const t of s.phis)if(t.dest===e)return t.type;for(const t of s.instructions)if("dest"in t&&t.dest===e){if("type"in t&&t.type)return t.type;if("binary"===t.kind||"unary"===t.kind)return v.Scalar.uint256;if("env"===t.kind)return"msg_sender"===t.op?v.Scalar.address:v.Scalar.uint256}}}function ls(e){if("const"===e.kind)return`$const_${e.value}`;if("temp"===e.kind)return e.id;throw new Error(`Unknown value kind: ${e.kind}`)}function us(e){const t=new Set,n=e=>{e&&"const"!==e.kind&&t.add(ls(e))};switch(e.kind){case"binary":n(e.left),n(e.right);break;case"unary":n(e.operand);break;case"compute_slot":n(e.base),w.ComputeSlot.isMapping(e)&&n(e.key);break;case"hash":case"cast":n(e.value);break;case"length":n(e.object);break;case"allocate":n(e.size);break;case"read":n(e.slot),n(e.offset),n(e.length);break;case"write":n(e.slot),n(e.offset),n(e.length),n(e.value);break;case"compute_offset":n(e.base),w.ComputeOffset.isArray(e)?n(e.index):w.ComputeOffset.isByte(e)&&n(e.offset)}return t}function ds(e){switch(e.kind){case"const":case"binary":case"unary":case"read":case"compute_slot":case"compute_offset":case"env":case"hash":case"cast":case"length":case"allocate":return e.dest;case"write":return}}function ps(e,t,n=new Set){if(n.has(t))return[];n.add(t);const s=e.blocks.get(t);if(!s)return[];const o=s.terminator;if("jump"===o.kind)return[t,...ps(e,o.target,n)];if("branch"===o.kind){return[t,...ps(e,o.trueTarget,n),...ps(e,o.falseTarget,n)]}return[t]}!function(e){e.plan=function(e,t){const n={main:{},functions:{}};if(e.create&&t.create){const s=Xn.plan(e.create,t.create);if(!s.success)return s;n.create=s.value}if(!t.main)return _.err(new Yn(Kn.INVALID_LAYOUT,"Missing liveness info for main function"));const s=Xn.plan(e.main,t.main);if(!s.success)return s;n.main=s.value;for(const[o,r]of e.functions){const e=t.functions[o];if(!e)return _.err(new Yn(Kn.INVALID_LAYOUT,`Missing liveness info for function ${o}`));const s=Xn.plan(r,e);if(!s.success)return s;n.functions[o]=s.value}return _.ok(n)}}(Zn||(Zn={})),function(e){e.plan=function(e,t){try{const n={};let s=Jn;const o=function(e,t){const n=new Map;for(const s of t.crossBlockValues){const t=cs(s,e);t&&n.set(s,t)}for(const[s,o]of e.blocks)for(const e of o.phis)n.set(e.dest,e.type);for(const s of e.blocks.keys()){const o=e.blocks.get(s),r=t.liveIn.get(s)||new Set;let i=Array.from(r);for(const t of o.instructions){for(const s of rs(t)){const t=is(i,s);if(t>16||-1===t){const t=cs(s,e);t&&n.set(s,t)}}if("compute_slot"===t.kind&&"array"===t.slotKind){const s=os(t.base);if(r.has(s)){const t=cs(s,e);t&&n.set(s,t)}}if(i=ss(i,t),i.length>14)for(let t=0;t<i.length-14;t++){const s=cs(i[t],e);s&&n.set(i[t],s)}}const a=o.terminator;if("branch"===a.kind&&"const"!==a.condition.kind){const t=os(a.condition),s=is(i,t);if(s>16||-1===s){const s=cs(t,e);s&&n.set(t,s)}}}return n}(e,t);for(const t of e.parameters||[])o.set(t.tempId,t.type);if(o.size>1e3)return _.err(new Yn(Kn.ALLOCATION_FAILED,`Too many values need memory allocation: ${o.size}`));const r=Array.from(o.entries()).sort((([e,t],[n,s])=>as(s)-as(t)));let i=s,a=0;const c=32;for(const[e,t]of r){const s=as(t);(s>=c||a+s>c)&&a>0&&(i+=c,a=0),n[e]={offset:i+a,size:s},a+=s,a>=c&&(i+=c,a=0)}return s=a>0?i+c:i,_.ok({allocations:n,nextStaticOffset:s})}catch(n){return _.err(new Yn(Kn.ALLOCATION_FAILED,n instanceof Error?n.message:"Unknown error"))}}}(Xn||(Xn={})),function(e){e.analyze=function(e){const t=new Map,n=new Map,s=new Map,o=new Set;for(const c of e.blocks.keys())t.set(c,new Set),n.set(c,new Set);const r=new Map,i=new Map;for(const[c,l]of e.blocks){const e=new Set,t=new Set;for(const s of l.phis)t.add(s.dest);for(const o of l.instructions){for(const r of us(o))t.has(r)||e.add(r),s.set(r,`${c}:${o.kind}`);const n=ds(o);n&&t.add(n)}const n=l.terminator;if("branch"===n.kind){const o=ls(n.condition);t.has(o)||e.add(o),s.set(o,`${c}:branch`)}else if("return"===n.kind&&n.value){const o=ls(n.value);t.has(o)||e.add(o),s.set(o,`${c}:return`)}r.set(c,e),i.set(c,t)}let a=!0;for(;a;){a=!1;for(const[s,c]of e.blocks){const l=t.get(s).size,u=n.get(s).size,d=new Set,p=c.terminator;if("jump"===p.kind){const n=t.get(p.target);if(n)for(const e of n)d.add(e);const r=e.blocks.get(p.target);if(r)for(const e of r.phis){const t=e.sources.get(s);t&&"const"!==t.kind&&(d.add(ls(t)),o.add(ls(t)))}}else if("branch"===p.kind){const n=t.get(p.trueTarget),r=t.get(p.falseTarget);if(n)for(const e of n)d.add(e);if(r)for(const e of r)d.add(e);for(const t of[p.trueTarget,p.falseTarget]){const n=e.blocks.get(t);if(n)for(const e of n.phis){const t=e.sources.get(s);t&&"const"!==t.kind&&(d.add(ls(t)),o.add(ls(t)))}}}n.set(s,d);const m=new Set(d),f=i.get(s),h=r.get(s);for(const e of f)m.delete(e);for(const e of h)m.add(e);t.set(s,m),m.size===l&&d.size===u||(a=!0)}}for(const c of n.values())for(const e of c)o.add(e);return{liveIn:t,liveOut:n,lastUse:s,crossBlockValues:o}}}(Qn||(Qn={})),function(e){e.analyze=function(e){const t={functions:{}};e.create&&(t.create=Qn.analyze(e.create)),t.main=Qn.analyze(e.main);for(const[n,s]of e.functions)t.functions[n]=Qn.analyze(s);return t}}(es||(es={})),function(e){e.perform=function(e){const t={main:{},functions:{}};if(e.create){const n=ns.perform(e.create);if(!n.success)return n;t.create=n.value}const n=ns.perform(e.main);if(!n.success)return n;t.main=n.value;for(const[s,o]of e.functions){const e=ns.perform(o);if(!e.success)return e;t.functions[s]=e.value}return _.ok(t)}}(ts||(ts={})),function(e){e.perform=function(e){try{const t=new Set,n=ps(e,e.entry,t),s=Array.from(e.blocks.keys()).filter((e=>!t.has(e)));return _.ok({order:[...n,...s],offsets:new Map})}catch(t){return _.err(new Yn(Kn.INVALID_LAYOUT,t instanceof Error?t.message:"Unknown error"))}}}(ns||(ns={}));function ms(e){const{PUSHn:t,SWAP1:n,DUP2:s,MLOAD:o,ADD:r,MSTORE:i}=Nn;return En().then(t(BigInt(Gn),e),{as:"offset"}).then(o(e),{as:"offset"}).then(n(e),{as:"b"}).then(s(e),{as:"a"}).then(r(e),{as:"value"}).then(t(BigInt(Gn),e),{as:"offset"}).then(i(e)).done()}const{PUSHn:fs,DUP2:hs,MSTORE:gs,ADD:ys}=Nn;function bs(e){const t=e.operationDebug;if("scalar"===e.type.kind){let n;return n="string"==typeof e.value&&e.value.startsWith("0x")?BigInt(e.value):"bigint"==typeof e.value?e.value:BigInt(e.value),En().then(fs(n,{debug:t})).then(Dn(e.dest,{debug:t})).done()}if("ref"===e.type.kind&&"memory"===e.type.location){let n,s;if("string"==typeof e.value&&e.value.startsWith("0x")){const t=e.value.slice(2),o=[];for(let e=0;e<t.length;e+=2)o.push(parseInt(t.substr(e,2),16));n=new Uint8Array(o),s=BigInt(n.length)}else{const t=String(e.value),o=new TextEncoder;n=o.encode(t),s=BigInt(n.length)}const o=(s+31n)/32n,r=32n+32n*o;return En().then(function(e,t){const{PUSHn:n}=Nn;return En().then(n(e,t),{as:"size"}).then(ms(t)).done()}(r,{debug:t}),{as:"offset"}).then(fs(BigInt(s),{debug:t}),{as:"value"}).then(hs({debug:t}),{as:"offset"}).then(gs({debug:t})).peek(((r,i)=>{let a=i;for(let e=0n;e<o;e++){const o=32n*e,r=s<o+32n?s:o+32n;let i=0n;for(let e=o;e<r;e++)i=i<<8n|BigInt(n[Number(e)]);i<<=8n*(32n-(r-o));const c=32n+32n*e;a=a.then(fs(i,{debug:t}),{as:"value"}).then(hs({debug:t}),{as:"b"}).then(fs(c,{debug:t}),{as:"a"}).then(ys({debug:t}),{as:"offset"}).then(gs({debug:t}))}return a.then(Tn("value")).then(Dn(e.dest,{debug:t}))})).done()}return En().then(fs(BigInt(e.value),{debug:t})).then(Dn(e.dest,{debug:t})).done()}const{CALLER:ks,CALLVALUE:vs,PUSH0:xs,TIMESTAMP:ws,NUMBER:Ts}=Nn;const{PUSHn:Es,MSTORE:Ss,KECCAK256:Ns}=Nn;var As;!function(e){e.STACK_OVERFLOW="EVM001",e.STACK_UNDERFLOW="EVM002",e.INVALID_STACK_ACCESS="EVM003",e.MEMORY_ALLOCATION_FAILED="EVM004",e.JUMP_TARGET_NOT_FOUND="EVM005",e.PHI_NODE_UNRESOLVED="EVM006",e.UNSUPPORTED_INSTRUCTION="EVM007",e.INTERNAL_ERROR="EVM999"}(As||(As={}));const js={[As.STACK_OVERFLOW]:"Stack depth exceeds EVM limit of 1024",[As.STACK_UNDERFLOW]:"Stack underflow: attempted to access non-existent stack item",[As.INVALID_STACK_ACCESS]:"Invalid stack access: position out of range",[As.MEMORY_ALLOCATION_FAILED]:"Failed to allocate memory for value",[As.JUMP_TARGET_NOT_FOUND]:"Jump target block not found",[As.PHI_NODE_UNRESOLVED]:"Phi node value not resolved for predecessor",[As.UNSUPPORTED_INSTRUCTION]:"Unsupported IR instruction",[As.INTERNAL_ERROR]:"Internal code generation error"};class Is extends B{constructor(e,t,n,s=L.Error){const o=js[e];super(t?`${o}: ${t}`:o,e,n,s)}}const{PUSHn:Ds,CALLDATASIZE:$s,SLOAD:Ms,MLOAD:Cs,SUB:Os,SHR:Us}=Nn;const{SWAP1:Ls,PUSHn:Ps,SLOAD:_s,SSTORE:Bs,MLOAD:Rs,MSTORE:Vs,SHL:zs,SHR:Fs,AND:Hs,OR:qs,NOT:Ws,SUB:Ks,DUP1:Ys}=Nn;const{PUSHn:Gs,MSTORE:Js,KECCAK256:Zs,ADD:Xs}=Nn;const{MUL:Qs,ADD:eo}=Nn;function to(e){const t=e.operationDebug;if(w.ComputeOffset.isArray(e))return En().then(In(e.base,{debug:t}),{as:"base"}).then(In(e.index,{debug:t}),{as:"index"}).then(In(x.constant(BigInt(e.stride),v.Scalar.uint256),{debug:t}),{as:"stride"}).then(wn({1:"a",2:"b"})).then(Qs({debug:t}),{as:"scaled_index"}).then(wn({1:"a",2:"b"})).then(eo({debug:t}),{as:"value"}).then(Dn(e.dest,{debug:t})).done();if(w.ComputeOffset.isField(e))return 0===e.fieldOffset?En().then(In(e.base,{debug:t}),{as:"value"}).then(Dn(e.dest,{debug:t})).done():En().then(In(e.base,{debug:t}),{as:"base"}).then(In(x.constant(BigInt(e.fieldOffset),v.Scalar.uint256),{debug:t}),{as:"field_offset"}).then(wn({1:"a",2:"b"})).then(eo({debug:t}),{as:"value"}).then(Dn(e.dest,{debug:t})).done();if(w.ComputeOffset.isByte(e))return En().then(In(e.base,{debug:t}),{as:"base"}).then(In(e.offset,{debug:t}),{as:"byte_offset"}).then(wn({1:"a",2:"b"})).then(eo({debug:t}),{as:"value"}).then(Dn(e.dest,{debug:t})).done();throw function(e){throw new Is(As.INTERNAL_ERROR,"Unexpected code path; expected exhaustive conditionals",void 0,L.Error)}(),new Error("Unknown compute_offset type")}function no(e){switch(e.kind){case"const":return bs(e);case"binary":return function(e){const t=e.operationDebug,n={add:$n({debug:t}),sub:Mn({debug:t}),mul:Cn({debug:t}),div:On({debug:t}),mod:Un({debug:t}),shl:En().then(wn({1:"shift",2:"value"})).then(zn({debug:t})).done(),shr:En().then(wn({1:"shift",2:"value"})).then(Fn({debug:t})).done(),eq:Ln({debug:t}),ne:En().then(Ln({debug:t}),{as:"a"}).then(Vn({debug:t})).done(),lt:_n({debug:t}),le:En().then(Pn({debug:t}),{as:"a"}).then(Vn({debug:t})).done(),gt:Pn({debug:t}),ge:En().then(_n({debug:t}),{as:"a"}).then(Vn({debug:t})).done(),and:Bn({debug:t}),or:Rn({debug:t})};return En().then(In(e.left,{debug:t}),{as:"b"}).then(In(e.right,{debug:t}),{as:"a"}).then(n[e.op],{as:"value"}).then(Dn(e.dest,{debug:t})).done()}(e);case"unary":return function(e){const t=e.operationDebug,n={not:Hn({debug:t}),neg:En().then(Tn("b")).then(qn(0n,{debug:t}),{as:"a"}).then(Wn({debug:t})).done()};return En().then(In(e.operand,{debug:t}),{as:"a"}).then(n[e.op],{as:"value"}).then(Dn(e.dest,{debug:t})).done()}(e);case"read":return function(e){const t=e.operationDebug;if("storage"===e.location&&e.slot){const n="const"===e.offset?.kind?e.offset.value:0n,s="const"===e.length?.kind?e.length.value:32n;return 0n===n&&32n===s?En().then(In(e.slot,{debug:t}),{as:"key"}).then(_s({debug:t}),{as:"value"}).then(Dn(e.dest,{debug:t})).done():En().then(In(e.slot,{debug:t}),{as:"key"}).then(_s({debug:t}),{as:"value"}).then(Ps(8n*(32n-BigInt(n)-BigInt(s)),{debug:t}),{as:"shift"}).then(Fs({debug:t}),{as:"shiftedValue"}).then(Ps(1n,{debug:t}),{as:"b"}).then(Ps(1n,{debug:t}),{as:"value"}).then(Ps(8n*BigInt(s),{debug:t}),{as:"shift"}).then(zs({debug:t}),{as:"a"}).then(Ks({debug:t}),{as:"mask"}).then(wn({1:"a",2:"b"})).then(Hs({debug:t}),{as:"value"}).then(Dn(e.dest,{debug:t})).done()}return"memory"===e.location&&e.offset?En().then(In(e.offset,{debug:t}),{as:"offset"}).then(Rs({debug:t}),{as:"value"}).then(Dn(e.dest,{debug:t})).done():En().then(Ps(0n,{debug:t}),{as:"value"}).done()}(e);case"write":return function(e){const t=e.operationDebug;if("storage"===e.location&&e.slot&&e.value){const n="const"===e.offset?.kind?e.offset.value:0n,s="const"===e.length?.kind?e.length.value:32n;return 0n===n&&32n===s?En().then(In(e.value,{debug:t}),{as:"value"}).then(In(e.slot,{debug:t}),{as:"key"}).then(Bs({debug:t})).done():En().then(In(e.slot,{debug:t}),{as:"key"}).then(Ys({debug:t})).then(_s({debug:t}),{as:"current"}).then(Ps(1n,{debug:t}),{as:"b"}).then(Ps(1n,{debug:t}),{as:"value"}).then(Ps(8n*BigInt(s),{debug:t}),{as:"shift"}).then(zs({debug:t}),{as:"a"}).then(Ks({debug:t}),{as:"lengthMask"}).then(Ps(8n*BigInt(n),{debug:t}),{as:"bitOffset"}).then(wn({1:"shift",2:"value"})).then(zs({debug:t}),{as:"a"}).then(Ws({debug:t}),{as:"clearMask"}).then(wn({1:"a",2:"b"})).then(Hs({debug:t}),{as:"clearedCurrent"}).then(In(e.value,{debug:t}),{as:"value"}).then(Ps(8n*BigInt(n),{debug:t}),{as:"shift"}).then(zs({debug:t}),{as:"shiftedValue"}).then(wn({1:"a",2:"b"})).then(qs({debug:t}),{as:"value"}).then(Ls({debug:t})).then(Bs({debug:t})).done()}return"memory"===e.location&&e.offset&&e.value?En().then(In(e.value,{debug:t}),{as:"value"}).then(In(e.offset,{debug:t}),{as:"offset"}).then(Vs({debug:t})).done():e=>e}(e);case"env":return function(e){const t=e.operationDebug,n={msg_sender:ks({debug:t}),msg_value:vs({debug:t}),msg_data:xs({debug:t}),block_timestamp:ws({debug:t}),block_number:Ts({debug:t})};return En().then(n[e.op],{as:"value"}).then(Dn(e.dest,{debug:t})).done()}(e);case"hash":return function(e){const t=e.operationDebug;return En().then(In(e.value,{debug:t})).then(Es(0n,{debug:t}),{as:"offset"}).then(Ss({debug:t})).then(Es(32n,{debug:t}),{as:"size"}).then(Es(0n,{debug:t}),{as:"offset"}).then(Ns({debug:t}),{as:"value"}).then(Dn(e.dest,{debug:t})).done()}(e);case"length":return function(e){const t=e.operationDebug,n=An(e.object);if(n.includes("calldata")||n.includes("msg_data")||n.includes("msg.data"))return En().then($s({debug:t}),{as:"value"}).then(Dn(e.dest,{debug:t})).done();const s=e.object.type;if("ref"===s.kind)return En().peek(((o,r)=>n in o.memory.allocations||o.stack.findIndex((({irValue:e})=>e===n))>-1||"memory"===s.location?r.then(In(e.object,{debug:t}),{as:"offset"}).then(Cs({debug:t}),{as:"value"}).then(Dn(e.dest,{debug:t})):r.then(In(e.object,{debug:t}),{as:"key"}).then(Ms({debug:t}),{as:"b"}).then(Ds(1n,{debug:t}),{as:"a"}).then(Os({debug:t}),{as:"value"}).then(Ds(1n,{debug:t}),{as:"shift"}).then(Us({debug:t}),{as:"value"}).then(Dn(e.dest,{debug:t})))).done();if("scalar"===s.kind)return En().then(Ds(BigInt(s.size),{debug:t})).then(Dn(e.dest,{debug:t})).done();throw new Is(As.UNSUPPORTED_INSTRUCTION,"length operation not supported for type")}(e);case"compute_slot":return function(e){const t=e.operationDebug;if(w.ComputeSlot.isMapping(e)){if(!e.key)throw new Error("Mapping compute_slot requires key");return En().then(In(e.key,{debug:t})).then(Gs(0n,{debug:t}),{as:"offset"}).then(Js({debug:t})).then(In(e.base,{debug:t})).then(Gs(32n,{debug:t}),{as:"offset"}).then(Js({debug:t})).then(Gs(64n,{debug:t}),{as:"size"}).then(Gs(0n,{debug:t}),{as:"offset"}).then(Zs({debug:t}),{as:"value"}).then(Dn(e.dest,{debug:t})).done()}if(w.ComputeSlot.isArray(e))return En().then(In(e.base,{debug:t})).then(Gs(0n,{debug:t}),{as:"offset"}).then(Js({debug:t})).then(Gs(32n,{debug:t}),{as:"size"}).then(Gs(0n,{debug:t}),{as:"offset"}).then(Zs({debug:t}),{as:"value"}).then(Dn(e.dest,{debug:t})).done();if(w.ComputeSlot.isField(e)){if(void 0===e.fieldOffset)throw new Error("Field compute_slot requires fieldOffset");const n=Math.floor(e.fieldOffset/32);return En().then(In(e.base,{debug:t}),{as:"b"}).then(Gs(BigInt(n),{debug:t}),{as:"a"}).then(Xs({debug:t}),{as:"value"}).then(Dn(e.dest,{debug:t})).done()}throw new Error("Unknown compute_slot kind")}(e);case"cast":return function(e){const t=e.operationDebug;return En().then(In(e.value,{debug:t}),{as:"value"}).then(Dn(e.dest,{debug:t})).done()}(e);case"allocate":return function(e){const t=e.operationDebug;return En().then(In(e.size,{debug:t}),{as:"size"}).then(ms({debug:t}),{as:"value"}).then(Dn(e.dest,{debug:t})).done()}(e);case"compute_offset":return to(e);default:return e}}function so(e){const t=[];for(const n of e)t.push(n.opcode),n.immediates&&t.push(...n.immediates);return t}function oo(e){return e.reduce(((e,t)=>e+function(e){let t=1;return e.immediates&&(t+=e.immediates.length),t}(t)),0)}function ro(e,t,n=!1,s=!1,o=!1,r){const{JUMPDEST:i}=Nn;return En().peek(((a,c)=>{const l=oo(a.instructions);let u=c.then((t=>({...t,blockOffsets:{...t.blockOffsets,[e.id]:l}})));if(s&&(u=u.then(function(e){const{PUSHn:t,MSTORE:n}=Nn;return En().then(t(BigInt(e)),{as:"value"}).then(t(BigInt(Gn)),{as:"offset"}).then(n()).done()}(a.memory.nextStaticOffset))),!s){let n=!1,s="";if(r&&t){const o=r.blocks.get(t);"call"===o?.terminator.kind&&o.terminator.continuation===e.id&&(n=!0,s=o.terminator.function)}if(n){const e={context:{remark:`call-continuation: resume after call to ${s}`}};u=u.then(i({debug:e}))}else u=u.then(i());if(r&&t){const n=r.blocks.get(t);"call"===n?.terminator.kind&&n.terminator.continuation===e.id&&n.terminator.dest&&(u=u.then(jn(n.terminator.dest)))}}t&&e.phis.length>0&&(u=u.then(function(e,t){return e.reduce(((e,n)=>e.then(function(e,t){const{PUSHn:n,MSTORE:s}=Nn,o=e.sources.get(t);if(!o)throw new Is(As.PHI_NODE_UNRESOLVED,`Phi ${e.dest} missing source from ${t}`);return En().then(In(o)).peek(((t,o)=>{const r=t.memory.allocations[e.dest];if(void 0===r)throw new Is(As.MEMORY_ALLOCATION_FAILED,`Phi destination ${e.dest} not allocated`);return o.then(n(BigInt(r.offset)),{as:"offset"}).then(s())})).done()}(n,t))),En()).done()}(e.phis,t)));for(const t of e.instructions)u=u.then(no(t));return u="call"===e.terminator.kind?u.then(function(e){const t=e.function,n=e.arguments,s=e.continuation;return e=>{let o=e;const r=o.instructions.length,i={context:{remark:`call-preparation: store return address for ${t}`}};o={...o,instructions:[...o.instructions,{mnemonic:"PUSH2",opcode:97,immediates:[0,0],debug:i},{mnemonic:"PUSH1",opcode:96,immediates:[96]},{mnemonic:"MSTORE",opcode:82}],patches:[...o.patches,{type:"continuation",index:r,target:s}]};const a={context:{remark:`call-arguments: push ${n.length} argument(s) for ${t}`}};for(const t of n)o=In(t,{debug:a})(o);const c=o.instructions.length,l={context:{remark:`call-invocation: jump to function ${t}`}};return o={...o,instructions:[...o.instructions,{mnemonic:"PUSH2",opcode:97,immediates:[0,0],debug:l},{mnemonic:"JUMP",opcode:86}],patches:[...o.patches,{type:"function",index:c,target:t}]},o}}(e.terminator)):u.then(function(e,t=!1,n=!1){const{PUSHn:s,PUSH2:o,MSTORE:r,MLOAD:i,RETURN:a,STOP:c,JUMP:l,JUMPI:u}=Nn;switch(e.kind){case"return":if(n){const t={context:{remark:e.value?"function-return: return with value":"function-return: void return"}};return e.value,En().then(s(0x60n,{debug:t}),{as:"offset"}).then(i({debug:t}),{as:"counter"}).then(l({debug:t})).done()}if(e.value){const t=e.value,n=An(t);return En().peek(((e,o)=>{const i=e.memory.allocations[n];if(void 0===i){const n=e.memory.nextStaticOffset;return o.then(In(t)).then(s(BigInt(n)),{as:"offset"}).then(r()).then(s(32n),{as:"size"}).then(s(BigInt(n)),{as:"offset"}).then(a())}{const e=i.offset;return o.then(s(32n),{as:"size"}).then(s(BigInt(e)),{as:"offset"}).then(a())}})).done()}return t?e=>e:En().then(c()).done();case"jump":return En().peek(((t,n)=>{const s=t.instructions.length;return n.then(o([0,0]),{as:"counter"}).then(l()).then((t=>({...t,patches:[...t.patches,{index:s,target:e.target}]})))})).done();case"branch":return En().then(In(e.condition),{as:"b"}).peek(((t,n)=>{const s=t.instructions.length;return n.then(o([0,0]),{as:"counter"}).then(u()).peek(((t,n)=>{const r=t.instructions.length;return n.then(o([0,0]),{as:"counter"}).then(l()).then((t=>({...t,patches:[...t.patches,{index:s,target:e.trueTarget},{index:r,target:e.falseTarget}]})))}))})).done();case"call":throw new Error("Call terminator should be handled by generateCallTerminator")}}(e.terminator,n,o)),u})).done()}function io(e,t,n,s={}){const o={brands:[],stack:[],instructions:[],memory:t,nextId:0,patches:[],blockOffsets:{},warnings:[],functionRegistry:{},callStackPointer:96};let r=o;if(s.isUserFunction){const t=function(e){const t=e.parameters||[];return n=>{let s=n;const o={context:{remark:`function-entry: ${e.name||"anonymous"}`}};s={...s,instructions:[...s.instructions,{mnemonic:"JUMPDEST",opcode:91,debug:o}]};const r={context:{remark:`prologue: store ${t.length} parameter(s) to memory`}};for(let e=t.length-1;e>=0;e--){const n=t[e],o=s.memory.allocations[n.tempId];if(!o)continue;const i=o.offset>>8&255,a=255&o.offset;s={...s,instructions:[...s.instructions,{mnemonic:"PUSH2",opcode:97,immediates:[i,a],debug:r}]},s={...s,instructions:[...s.instructions,{mnemonic:"MSTORE",opcode:82}]}}return{...s,stack:[],brands:[]}}}(e);r=t(o)}const i=n.order.reduce(((t,o,r)=>{const i=e.blocks.get(o);if(!i)return t;const a=0===r;return ro(i,r>0?n.order[r-1]:void 0,r===n.order.length-1,a,s.isUserFunction||!1,e)(t)}),r),a=function(e){const t=[...e.instructions];for(const n of e.patches){if("function"===n.type)continue;const s=e.blockOffsets[n.target];if(void 0===s)throw new Error(`Jump target ${n.target} not found`);const o=s>>8&255,r=255&s,i=t[n.index];i&&i.immediates&&(i.immediates=[o,r])}return{...e,instructions:t}}(i),c=so(a.instructions);return{instructions:a.instructions,bytecode:c,warnings:a.warnings,patches:i.patches}}function ao(e,t,n,s){const o=[...t],r=[...e];for(const i of n){if("function"!==i.type)continue;const e=s[i.target];if(void 0===e)throw new Error(`Function ${i.target} not found in registry`);const n=e>>8&255,a=255&e,c=o[i.index];c&&c.immediates&&(c.immediates=[n,a]);let l=0;for(let s=0;s<i.index;s++){const e=t[s];l+=1,e.immediates&&(l+=e.immediates.length)}l+=1,r[l]=n,r[l+1]=a}return{bytecode:r,instructions:o}}function co(e,t,n){const s=io(e.main,t.main,n.main);let o=[...s.warnings];const r=[];for(const[g,y]of e.functions.entries()){const e=t.functions?.[g],s=n.functions?.[g];if(e&&s){const t=io(y,e,s,{isUserFunction:!0});r.push({name:g,bytecode:t.bytecode,instructions:t.instructions,patches:t.patches}),o=[...o,...t.warnings]}}const i={};let a=s.bytecode.length;for(const g of r)i[g.name]=a,a+=g.bytecode.length;const c=ao(s.bytecode,s.instructions,s.patches,i),l=r.map((e=>ao(e.bytecode,e.instructions,e.patches,i))),u=[...c.bytecode,...l.flatMap((e=>e.bytecode))],d=[...c.instructions,...l.flatMap((e=>e.instructions))];let p=[],m=[];if(e.create&&t.create&&n.create){const s=io(e.create,t.create,n.create);p=s.bytecode,m=[...s.instructions],o=[...o,...s.warnings]}const{deployBytes:f,deploymentWrapperInstructions:h}=function(e,t){const n={brands:[],stack:[],instructions:[],memory:{allocations:{},nextStaticOffset:128},nextId:0,patches:[],blockOffsets:{},warnings:[],functionRegistry:{},callStackPointer:96},s=function(e,t){const n={brands:[],stack:[],instructions:[],memory:{allocations:{},nextStaticOffset:128},nextId:0,patches:[],blockOffsets:{},warnings:[],functionRegistry:{},callStackPointer:96};let s=0,o=-1;for(;s!==o;){o=s;s=oo(lo(BigInt(e+s),BigInt(t))(n).instructions)}return e+s}(e.length,t.length),o=BigInt(s),r=BigInt(t.length),i=lo(o,r)(n),a=so(i.instructions),c=[...e,...a,...t];return{deployBytes:c,deploymentWrapperInstructions:i.instructions}}(p,u);return{create:f,runtime:u,createInstructions:m.length>0||h.length>0?[...m,...h]:void 0,runtimeInstructions:d,warnings:o}}function lo(e,t){const{PUSHn:n,CODECOPY:s,RETURN:o}=Nn;return En().then(n(t),{as:"size"}).then(n(e),{as:"offset"}).then(n(0n),{as:"destOffset"}).then(s()).then(n(t),{as:"size"}).then(n(0n),{as:"offset"}).then(o()).done()}function uo(e,t,n){const s=function(e){const t=[];let n=0;for(const s of e)t.push(n),n+=1+(s.immediates?.length??0);return t}(e),o=e.map(((e,t)=>function(e,t){const n={offset:t};if(e.mnemonic){const t={mnemonic:e.mnemonic};if(e.immediates&&e.immediates.length>0){const n="0x"+e.immediates.map((e=>e.toString(16).padStart(2,"0"))).join("");t.arguments=[n]}n.operation=t}return e.debug?.context&&(n.context=e.debug.context),n}(e,s[t]))),r={contract:{name:n.name,definition:{source:{id:"0"},range:n.loc??{offset:0,length:0}}},environment:t,instructions:o};return n.debugContext&&(r.context=n.debugContext),r}const po={async run({ir:e}){try{const t=es.analyze(e),n=Zn.plan(e,t);if(!n.success)return _.err(new Is(As.INTERNAL_ERROR,n.messages.error?.[0]?.message??"Memory analysis failed"));const s=ts.perform(e);if(!s.success)return _.err(new Is(As.INTERNAL_ERROR,s.messages.error?.[0]?.message??"Block layout analysis failed"));const o=co(e,n.value,s.value),r=new Uint8Array(o.runtime),i=o.create?new Uint8Array(o.create):void 0,a=uo(o.runtimeInstructions,"call",e),c=o.createInstructions?uo(o.createInstructions,"create",e):void 0;return _.okWith({bytecode:{runtime:r,create:i,runtimeInstructions:o.runtimeInstructions,createInstructions:o.createInstructions,runtimeProgram:a,createProgram:c}},o.warnings)}catch(t){return t instanceof Is?_.err(t):_.err(new Is(As.INTERNAL_ERROR,t instanceof Error?t.message:String(t)))}}},mo=[gn,yn,bn,kn],fo={ast:[gn],types:[gn,yn],ir:mo,bytecode:[...mo,po]};async function ho(e){const{to:t,...n}=e,s=(o=fo[t],{async run(e){let t=e,n={};for(const s of o){const e=await s.run(t);if(n=_.mergeMessages(n,e.messages),!e.success)return{success:!1,messages:n};t={...t,...e.value}}return{success:!0,value:t,messages:n}}});var o;return await s.run(n)}},26330(e,t,n){n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>u,default:()=>f,frontMatter:()=>l,metadata:()=>s,toc:()=>p});const s=JSON.parse('{"id":"core-schemas/programs/tracing","title":"Tracing execution","description":"Tracing brings together programs, pointers, and types to show what\'s happening","source":"@site/docs/core-schemas/programs/tracing.mdx","sourceDirName":"core-schemas/programs","slug":"/core-schemas/programs/tracing","permalink":"/format/pr-preview/pr-168/docs/core-schemas/programs/tracing","draft":false,"unlisted":false,"editUrl":"https://github.com/ethdebug/format/tree/main/packages/web/docs/core-schemas/programs/tracing.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"Variables","permalink":"/format/pr-preview/pr-168/docs/core-schemas/programs/variables"},"next":{"title":"Info","permalink":"/format/pr-preview/pr-168/docs/core-schemas/info/"}}');var o=n(31085),r=n(71184),i=n(792),a=n(87270),c=n(79170);const l={sidebar_position:4},u="Tracing execution",d={},p=[{value:"What tracing provides",id:"what-tracing-provides",level:2},{value:"The tracing process",id:"the-tracing-process",level:2},{value:"Try it yourself",id:"try-it-yourself",level:2},{value:"Simple counter increment",id:"simple-counter-increment",level:3},{value:"Storage with threshold check",id:"storage-with-threshold-check",level:3},{value:"Multiple storage slots",id:"multiple-storage-slots",level:3},{value:"Trace data structure",id:"trace-data-structure",level:2},{value:"Mapping trace to program",id:"mapping-trace-to-program",level:2},{value:"Variable resolution during tracing",id:"variable-resolution-during-tracing",level:2},{value:"Building a trace viewer",id:"building-a-trace-viewer",level:2},{value:"1. Trace source",id:"1-trace-source",level:3},{value:"2. Program loader",id:"2-program-loader",level:3},{value:"3. Pointer resolver",id:"3-pointer-resolver",level:3},{value:"4. Type decoder",id:"4-type-decoder",level:3},{value:"Learn more",id:"learn-more",level:2}];function m(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"tracing-execution",children:"Tracing execution"})}),"\n",(0,o.jsx)(i.A,{schema:"ethdebug/format/program",href:"/spec/program/overview"}),"\n",(0,o.jsxs)(c.bO,{children:[(0,o.jsxs)(t.p,{children:["Tracing brings together programs, pointers, and types to show what's happening\nat each step of EVM execution. Click ",(0,o.jsx)(t.strong,{children:'"Try it"'})," on any example to open the\nTrace Playground, where you can compile and step through real BUG code."]}),(0,o.jsx)(t.h2,{id:"what-tracing-provides",children:"What tracing provides"}),(0,o.jsxs)(t.p,{children:["With ",(0,o.jsx)(t.strong,{children:"ethdebug/format"})," data, a trace viewer can show:"]}),(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Current source location"}),": Which line of source code corresponds to the\ncurrent bytecode instruction"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Variables in scope"}),": What identifiers are valid and their current values"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Call context"}),": Function name, parameters, and return expectations"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Data inspection"}),": Drill into complex types (structs, arrays, mappings)"]}),"\n"]}),(0,o.jsx)(t.h2,{id:"the-tracing-process",children:"The tracing process"}),(0,o.jsx)(t.p,{children:"At each instruction in a transaction trace:"}),(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Look up the program counter"}),": Find the instruction record for the current\nPC"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Read the context"}),": Get variables, source ranges, and other metadata"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Resolve pointers"}),": For each variable, resolve its pointer to get the\ncurrent value"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Decode values"}),": Use the type information to interpret raw bytes"]}),"\n"]}),(0,o.jsx)(t.h2,{id:"try-it-yourself",children:"Try it yourself"}),(0,o.jsxs)(t.p,{children:["Click ",(0,o.jsx)(t.strong,{children:'"Try it"'})," on any example below to load it into the Trace Playground.\nThe drawer will open at the bottom of the screen where you can compile the\ncode and step through the execution trace."]}),(0,o.jsx)(t.h3,{id:"simple-counter-increment",children:"Simple counter increment"}),(0,o.jsx)(t.p,{children:"This example shows a basic counter that increments a storage variable:"}),(0,o.jsx)(c.QX,{title:"Counter increment",description:"Increments count from 0 to 1, storing the result",source:"name Counter;\n\nstorage {\n[0] count: uint256;\n}\n\ncreate {\ncount = 0;\n}\n\ncode {\ncount = count + 1;\n}"}),(0,o.jsx)(t.h3,{id:"storage-with-threshold-check",children:"Storage with threshold check"}),(0,o.jsx)(t.p,{children:"This example demonstrates conditional logic with storage variables:"}),(0,o.jsx)(c.QX,{title:"Threshold check",description:"Increments counter and resets when reaching threshold",source:"name ThresholdCounter;\n\nstorage {\n[0] count: uint256;\n[1] threshold: uint256;\n}\n\ncreate {\ncount = 0;\nthreshold = 5;\n}\n\ncode {\ncount = count + 1;\n\nif (count >= threshold) {\ncount = 0;\n}\n}"}),(0,o.jsx)(t.h3,{id:"multiple-storage-slots",children:"Multiple storage slots"}),(0,o.jsx)(t.p,{children:"This example shows working with multiple storage locations:"}),(0,o.jsx)(c.QX,{title:"Multiple storage slots",description:"Updates multiple storage values in sequence",source:"name MultiSlot;\n\nstorage {\n[0] a: uint256;\n[1] b: uint256;\n[2] sum: uint256;\n}\n\ncreate {\na = 10;\nb = 20;\nsum = 0;\n}\n\ncode {\nsum = a + b;\na = a + 1;\nb = b + 1;\n}"}),(0,o.jsx)(t.h2,{id:"trace-data-structure",children:"Trace data structure"}),(0,o.jsx)(t.p,{children:"A trace step captures the EVM state at a single point:"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:"interface TraceStep {\n  pc: number; // Program counter\n  opcode: string; // Mnemonic (SLOAD, ADD, etc.)\n  stack: bigint[]; // Stack contents (top first)\n  memory?: Uint8Array; // Memory contents\n  storage?: Record<string, string>; // Changed slots\n}\n"})}),(0,o.jsx)(t.p,{children:"Combined with the program annotation, this gives us complete visibility."}),(0,o.jsx)(t.h2,{id:"mapping-trace-to-program",children:"Mapping trace to program"}),(0,o.jsx)(t.p,{children:"The program's instruction list maps each PC to its context:"}),(0,o.jsx)(a.A,{schema:"program/instruction",href:"/spec/program/instruction",title:"Instruction with context",children:'{\n  "offset": 18,\n  "operation": { "mnemonic": "SLOAD" },\n  "context": {\n    "gather": [\n      {\n        "code": {\n          "source": { "id": "main" },\n          "range": { "offset": 120, "length": 5 }\n        }\n      },\n      {\n        "variables": [\n          {\n            "identifier": "count",\n            "type": { "kind": "uint", "bits": 256 },\n            "pointer": { "location": "storage", "slot": 0 }\n          }\n        ]\n      }\n    ]\n  }\n}'}),(0,o.jsx)(t.p,{children:"This tells us:"}),(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"The SLOAD at PC 18 corresponds to source at offset 120"}),"\n",(0,o.jsxs)(t.li,{children:["The variable ",(0,o.jsx)(t.code,{children:"count"})," is in scope"]}),"\n",(0,o.jsx)(t.li,{children:"We can resolve its value using the pointer"}),"\n"]}),(0,o.jsx)(t.h2,{id:"variable-resolution-during-tracing",children:"Variable resolution during tracing"}),(0,o.jsx)(t.p,{children:"To show variable values, trace viewers:"}),(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Get the variable's pointer"})," from the program context"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Create machine state"})," from the trace step (stack, storage, memory)"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Resolve the pointer"})," to get concrete byte regions"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Decode using the type"})," to get the display value"]}),"\n"]}),(0,o.jsx)(t.h2,{id:"building-a-trace-viewer",children:"Building a trace viewer"}),(0,o.jsx)(t.p,{children:"The key components for trace integration:"}),(0,o.jsx)(t.h3,{id:"1-trace-source",children:"1. Trace source"}),(0,o.jsx)(t.p,{children:"Get transaction traces from:"}),(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["JSON-RPC ",(0,o.jsx)(t.code,{children:"debug_traceTransaction"})]}),"\n",(0,o.jsx)(t.li,{children:"Local simulation (Ganache, Anvil, Hardhat)"}),"\n",(0,o.jsx)(t.li,{children:"Historical archive nodes"}),"\n"]}),(0,o.jsx)(t.h3,{id:"2-program-loader",children:"2. Program loader"}),(0,o.jsx)(t.p,{children:"Load compiled program data containing:"}),(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Instruction list with contexts"}),"\n",(0,o.jsx)(t.li,{children:"Source materials"}),"\n",(0,o.jsx)(t.li,{children:"Type definitions"}),"\n"]}),(0,o.jsx)(t.h3,{id:"3-pointer-resolver",children:"3. Pointer resolver"}),(0,o.jsxs)(t.p,{children:["Use ",(0,o.jsx)(t.code,{children:"@ethdebug/pointers"})," to resolve variable locations:"]}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:'import { dereference } from "@ethdebug/pointers";\n\n// For each variable in scope\nconst cursor = await dereference(variable.pointer, { state: machineState });\nconst view = await cursor.view(machineState);\nconst value = await view.read(view.regions[0]);\n'})}),(0,o.jsx)(t.h3,{id:"4-type-decoder",children:"4. Type decoder"}),(0,o.jsx)(t.p,{children:"Interpret raw bytes according to type:"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:'function decodeValue(bytes: Data, type: Type): string {\n  switch (type.kind) {\n    case "uint":\n      return bytes.asUint().toString();\n    case "bool":\n      return bytes.asUint() !== 0n ? "true" : "false";\n    case "address":\n      return "0x" + bytes.toHex().slice(-40);\n    // ... other types\n  }\n}\n'})}),(0,o.jsx)(t.h2,{id:"learn-more",children:"Learn more"}),(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.a,{href:"./instructions",children:"Instructions documentation"})," for understanding instruction\nrecords"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.a,{href:"./variables",children:"Variables documentation"})," for variable structure and lifetime"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.a,{href:"../pointers",children:"Pointers"})," for resolving variable locations"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.a,{href:"/docs/examples/bug-playground",children:"BUG Playground"})," for more interactive examples"]}),"\n"]})]})]})}function f(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(m,{...e})}):m(e)}},39612(e,t,n){n.d(t,{yZ:()=>u,dV:()=>l,MT:()=>D,KE:()=>_,TE:()=>E,sH:()=>a});var s=n(14041);function o(){const[e,t]=(0,s.useState)(null),n=(0,s.useCallback)(((e,n)=>{const s=e.currentTarget.getBoundingClientRect();t({content:n,x:s.left,y:s.bottom,pinned:!1})}),[]),o=(0,s.useCallback)(((e,n)=>{const s=e.currentTarget.getBoundingClientRect();t({content:n,x:s.left,y:s.bottom,pinned:!0})}),[]),r=(0,s.useCallback)((()=>{t((e=>e?.pinned?e:null))}),[]),i=(0,s.useCallback)((()=>{t(null)}),[]);return{tooltip:e,setTooltip:t,showTooltip:n,pinTooltip:o,hideTooltip:r,closeTooltip:i}}var r=n(31085);function i({tooltip:e,onUpdate:t,onClose:n}){const o=(0,s.useRef)(null);return(0,s.useEffect)((()=>{if(e&&o.current){const n=o.current.getBoundingClientRect(),s=window.innerWidth,r=window.innerHeight;let{x:i,y:a}=e;i+n.width>s&&(i=s-n.width-10),i<10&&(i=10),a+n.height>r&&(a=r-n.height-10),a<10&&(a=10),i===e.x&&a===e.y||t?.({...e,x:i,y:a})}}),[e,t]),e?(0,r.jsxs)("div",{ref:o,className:"ethdebug-tooltip "+(e.pinned?"pinned":""),style:{left:`${e.x}px`,top:`${e.y}px`},children:[e.pinned&&(0,r.jsx)("button",{className:"tooltip-close-btn",onClick:n,title:"Close (Esc)",children:"\xd7"}),(0,r.jsx)("pre",{children:e.content})]}):null}function a(e){if(!e||"object"!=typeof e)return[];const t=e;if(t.code&&"object"==typeof t.code){const e=t.code;if(e.range&&"object"==typeof e.range){const t=e.range;if("number"==typeof t.offset&&"number"==typeof t.length)return[{offset:t.offset,length:t.length}]}}if(t.gather&&Array.isArray(t.gather)){const e=[];for(const n of t.gather)e.push(...a(n));return e}if(t.pick&&Array.isArray(t.pick)){const e=[];for(const n of t.pick)e.push(...a(n));return e}return t.frame&&"object"==typeof t.frame?a(t.frame):t.context?a(t.context):[]}function c({instructions:e,onOpcodeHover:t}){const{tooltip:n,setTooltip:s,showTooltip:c,pinTooltip:l,hideTooltip:u,closeTooltip:d}=o();let p=0;const m=()=>{t?.([])};return(0,r.jsxs)("div",{className:"bytecode-disassembly-interactive",children:[e.map(((e,n)=>{const s=p;p+=1+(e.immediates?.length||0);const o=a(e.debug?.context),i=!!e.debug?.context;return(0,r.jsxs)("div",{className:"opcode-line "+(i?"has-debug-info":""),onMouseEnter:()=>(e=>{t?.(e)})(o),onMouseLeave:m,children:[i?(0,r.jsx)("span",{className:"debug-info-icon",onMouseEnter:t=>((e,t)=>{t.debug?.context&&c(e,JSON.stringify(t.debug.context,null,2))})(t,e),onMouseLeave:u,onClick:t=>((e,t)=>{t.debug?.context&&l(e,JSON.stringify(t.debug.context,null,2))})(t,e),children:"\u2139"}):(0,r.jsx)("span",{className:"debug-info-spacer"}),(0,r.jsx)("span",{className:"pc",children:s.toString().padStart(4,"0")}),(0,r.jsx)("span",{className:"opcode",children:e.mnemonic}),e.immediates&&e.immediates.length>0&&(0,r.jsxs)("span",{className:"immediates",children:["0x",e.immediates.map((e=>e.toString(16).padStart(2,"0"))).join("")]})]},n)})),(0,r.jsx)(i,{tooltip:n,onUpdate:s,onClose:d})]})}function l({bytecode:e,onOpcodeHover:t}){const n=Array.from(e.runtime).map((e=>e.toString(16).padStart(2,"0"))).join(""),s=e.create?Array.from(e.create).map((e=>e.toString(16).padStart(2,"0"))).join(""):null;return(0,r.jsxs)("div",{className:"bytecode-view",children:[e.create&&(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)("div",{className:"bytecode-header",children:[(0,r.jsx)("h3",{children:"Constructor Bytecode"}),(0,r.jsx)("div",{className:"bytecode-stats",children:(0,r.jsxs)("span",{children:["Size: ",e.create.length/2," bytes"]})})]}),(0,r.jsxs)("div",{className:"bytecode-content",children:[(0,r.jsxs)("div",{className:"bytecode-section",children:[(0,r.jsx)("h4",{children:"Hex"}),(0,r.jsx)("pre",{className:"bytecode-hex",children:s})]}),(0,r.jsxs)("div",{className:"bytecode-section",children:[(0,r.jsx)("h4",{children:"Instructions"}),e.createInstructions&&(0,r.jsx)(c,{instructions:e.createInstructions,onOpcodeHover:t})]})]}),(0,r.jsx)("hr",{className:"bytecode-separator"})]}),(0,r.jsxs)("div",{className:"bytecode-header",children:[(0,r.jsx)("h3",{children:e.create?"Runtime Bytecode":"EVM Bytecode"}),(0,r.jsx)("div",{className:"bytecode-stats",children:(0,r.jsxs)("span",{children:["Size: ",e.runtime.length/2," bytes"]})})]}),(0,r.jsxs)("div",{className:"bytecode-content",children:[(0,r.jsxs)("div",{className:"bytecode-section",children:[(0,r.jsx)("h4",{children:"Hex"}),(0,r.jsx)("pre",{className:"bytecode-hex",children:n})]}),(0,r.jsxs)("div",{className:"bytecode-section",children:[(0,r.jsx)("h4",{children:"Instructions"}),(0,r.jsx)(c,{instructions:e.runtimeInstructions,onOpcodeHover:t})]})]})]})}function u({ast:e}){const t=JSON.stringify(e,((e,t)=>{if("parent"!==e)return t}),2);return(0,r.jsx)("div",{className:"ast-view",children:(0,r.jsx)("pre",{className:"ast-json",children:t})})}var d=n(9921);function p(e){const t={};e.operation?.context&&(t.operation=e.operation.context);const n=e.operands.filter((e=>e.debug?.context));return n.length>0&&(t.operands=Object.fromEntries(n.map((e=>[e.label,e.debug.context])))),JSON.stringify(t,null,2)}function m(e){const t=[];e.operation?.context&&t.push(...a(e.operation.context));for(const n of e.operands)n.debug?.context&&t.push(...a(n.debug.context));return t}function f(e,t){const n=e.operands.find((e=>e.label===t));return n?.debug?.context?a(n.debug.context):[]}function h({part:e,onHover:t,onLeave:n,onDebugIconHover:s,showDebugIcon:o}){return(0,r.jsxs)("span",{className:`hoverable-part ${e.className||""} ${e.ranges.length>0?"has-debug":""}`,onMouseEnter:()=>t(e.ranges),onMouseLeave:n,children:[e.text,o&&e.ranges.length>0&&s&&(0,r.jsx)("span",{className:"debug-info-icon inline",onMouseEnter:s,children:"\u2139"})]})}function g(e){if("bigint"==typeof e)return e.toString();if("string"==typeof e)return e.startsWith("0x")?e:JSON.stringify(e);if("boolean"==typeof e)return e.toString();switch(e.kind){case"const":return g(e.value);case"temp":return`%${e.id}`;default:return"?"}}function y(e){return e.kind}function b(e,t){const n=`${e.startsWith("t")?"%":"^"}${e}`;return t?`${n}: ${y(t)}`:n}function k({instruction:e,onHover:t,onLeave:n,showTooltip:s,pinTooltip:o,hideTooltip:i}){const a=function(e){const t=[];switch(e.kind){case"read":e.slot&&t.push({label:"slot",debug:e.slotDebug}),e.offset&&t.push({label:"offset",debug:e.offsetDebug}),e.length&&t.push({label:"length",debug:e.lengthDebug});break;case"write":e.slot&&t.push({label:"slot",debug:e.slotDebug}),e.offset&&t.push({label:"offset",debug:e.offsetDebug}),e.length&&t.push({label:"length",debug:e.lengthDebug}),t.push({label:"value",debug:e.valueDebug});break;case"compute_offset":t.push({label:"base",debug:e.baseDebug}),"index"in e&&e.index&&t.push({label:"index",debug:e.indexDebug}),"offset"in e&&e.offset&&t.push({label:"offset",debug:e.offsetDebug});break;case"compute_slot":t.push({label:"base",debug:e.baseDebug}),"key"in e&&e.key&&t.push({label:"key",debug:e.keyDebug});break;case"const":case"hash":case"cast":t.push({label:"value",debug:e.valueDebug});break;case"allocate":t.push({label:"size",debug:e.sizeDebug});break;case"binary":t.push({label:"left",debug:e.leftDebug}),t.push({label:"right",debug:e.rightDebug});break;case"unary":t.push({label:"operand",debug:e.operandDebug});break;case"length":t.push({label:"object",debug:e.objectDebug})}return{operation:e.operationDebug,operands:t}}(e),c=a.operation?.context?m({operation:a.operation,operands:[]}):[],l=[],u=(e,t,n)=>{const s=f(a,e);l.push({text:t,ranges:s,className:n})},k=e=>{l.push(e)};switch(e.kind){case"const":k(`${b(e.dest,e.type)} = const `),u("value",g(e.value));break;case"allocate":k(`${b(e.dest,d.Ir.ZU.Scalar.uint256)} = allocate.${e.location}, size=`),u("size",g(e.size));break;case"binary":k(`${b(e.dest)} = ${e.op} `),u("left",g(e.left)),k(", "),u("right",g(e.right));break;case"unary":k(`${b(e.dest)} = ${e.op} `),u("operand",g(e.operand));break;case"env":k(`${b(e.dest)} = env ${e.op}`);break;case"hash":k(`${b(e.dest)} = hash `),u("value",g(e.value));break;case"cast":k(`${b(e.dest,e.targetType)} = cast `),u("value",g(e.value)),k(` to ${y(e.targetType)}`);break;case"length":k(`${b(e.dest)} = length `),u("object",g(e.object));break;case"compute_slot":{const t=g(e.base);k(`${b(e.dest,d.Ir.ZU.Scalar.uint256)} = slot[`),u("base",t),"key"in e&&e.key?(k("].mapping["),u("key",g(e.key)),k("]")):"slotKind"in e&&"array"===e.slotKind?k("].array"):k("fieldOffset"in e?`].field[${e.fieldOffset}]`:"]");break}case"compute_offset":{const t=g(e.base);k(`${e.dest.startsWith("t")?`%${e.dest}`:e.dest} = offset[`),u("base",t),"index"in e&&e.index?32===e.stride?(k("].array["),u("index",g(e.index)),k("]")):(k("].array[index: "),u("index",g(e.index)),k(`, stride: ${e.stride}]`)):"offset"in e&&e.offset?(k("].byte["),u("offset",g(e.offset)),k("]")):k("fieldOffset"in e?`].field[${e.fieldOffset}]`:"]");break}case"read":{const t=e.location,n=!e.offset||"const"===e.offset.kind&&0n===e.offset.value,s=!e.length||"const"===e.length.kind&&32n===e.length.value;if(k(`${b(e.dest,e.type)} = `),"storage"===t||"transient"===t){const o=e.slot?g(e.slot):"0";n&&s?(k(`${t}[`),u("slot",o),k("*]")):(k(`${t}[slot: `),u("slot",o),!n&&e.offset&&(k(", offset: "),u("offset",g(e.offset))),!s&&e.length&&(k(", length: "),u("length",g(e.length))),k("]"))}else if(e.offset){const n=g(e.offset);if(s)k(`${t}[`),u("offset",n),k("*]");else{k(`${t}[offset: `),u("offset",n);const s=e.length?g(e.length):"32";k(", length: "),u("length",s),k("]")}}else k(`${t}[]`);break}case"write":{const t=e.location,n=g(e.value),s=!e.offset||"const"===e.offset.kind&&0n===e.offset.value,o=!e.length||"const"===e.length.kind&&32n===e.length.value;if("storage"===t||"transient"===t){const n=e.slot?g(e.slot):"0";s&&o?(k(`${t}[`),u("slot",n),k("*] = ")):(k(`${t}[slot: `),u("slot",n),!s&&e.offset&&(k(", offset: "),u("offset",g(e.offset))),!o&&e.length&&(k(", length: "),u("length",g(e.length))),k("] = "))}else if(e.offset){const n=g(e.offset);if(o)k(`${t}[`),u("offset",n),k("*] = ");else{k(`${t}[offset: `),u("offset",n);const s=e.length?g(e.length):"32";k(", length: "),u("length",s),k("] = ")}}else k(`${t}[] = `);u("value",n);break}default:k(`; unknown instruction: ${e.kind}`)}const v=c.length>0||a.operands.some((e=>e.debug?.context));return(0,r.jsxs)("div",{className:"ir-instruction",children:[v&&(0,r.jsx)("span",{className:"debug-info-icon",onMouseEnter:e=>{const t=p(a);s(e,t)},onMouseLeave:i,onClick:e=>{const t=p(a);o(e,t)},children:"\u2139"}),!v&&(0,r.jsx)("span",{className:"debug-info-spacer"}),(0,r.jsx)("span",{className:"instruction-operation",onMouseEnter:()=>t(c),onMouseLeave:n,children:l.map(((e,s)=>"string"==typeof e?(0,r.jsx)("span",{children:e},s):(0,r.jsx)(h,{part:e,onHover:t,onLeave:n},s)))})]})}function v({terminator:e,onHover:t,onLeave:n,showTooltip:s,pinTooltip:o,hideTooltip:i}){const a=function(e){const t=[];switch(e.kind){case"branch":t.push({label:"condition",debug:e.conditionDebug});break;case"return":e.value&&t.push({label:"value",debug:e.valueDebug});break;case"call":e.argumentsDebug&&e.arguments.forEach(((n,s)=>{t.push({label:`arg[${s}]`,debug:e.argumentsDebug?.[s]})}))}return{operation:e.operationDebug,operands:t}}(e),c=a.operation?.context?m({operation:a.operation,operands:[]}):[],l=[],u=(e,t,n)=>{const s=f(a,e);l.push({text:t,ranges:s,className:n})},d=e=>{l.push(e)};switch(e.kind){case"jump":d(`jump ${e.target}`);break;case"branch":d("branch "),u("condition",g(e.condition)),d(` ? ${e.trueTarget} : ${e.falseTarget}`);break;case"return":e.value?(d("return "),u("value",g(e.value))):d("return void");break;case"call":e.dest&&d(`${e.dest} = `),d(`call ${e.function}(`),e.arguments.forEach(((e,t)=>{t>0&&d(", "),u(`arg[${t}]`,g(e))})),d(`) -> ${e.continuation}`)}const y=c.length>0||a.operands.some((e=>e.debug?.context));return(0,r.jsxs)("div",{className:"ir-terminator",children:[y&&(0,r.jsx)("span",{className:"debug-info-icon",onMouseEnter:e=>{const t=p(a);s(e,t)},onMouseLeave:i,onClick:e=>{const t=p(a);o(e,t)},children:"\u2139"}),!y&&(0,r.jsx)("span",{className:"debug-info-spacer"}),(0,r.jsx)("span",{className:"terminator-operation",onMouseEnter:()=>t(c),onMouseLeave:n,children:l.map(((e,s)=>"string"==typeof e?(0,r.jsx)("span",{children:e},s):(0,r.jsx)(h,{part:e,onHover:t,onLeave:n},s)))})]})}function x({phi:e,onHover:t,onLeave:n,showTooltip:s,pinTooltip:o,hideTooltip:i}){const a=function(e){const t=[];if(e.sourcesDebug)for(const n of e.sources.keys()){const s=e.sourcesDebug.get(n);t.push({label:`from ${n}`,debug:s})}return{operation:e.operationDebug,operands:t}}(e),c=a.operation?.context?m({operation:a.operation,operands:[]}):[],l=c.length>0||a.operands.some((e=>e.debug?.context)),u=[],d=e=>u.push(e),b=e.dest.startsWith("t")?`%${e.dest}`:`^${e.dest}`,k=e.type?`: ${y(e.type)}`:"";d(`${b}${k} = phi `);return Array.from(e.sources.entries()).forEach((([e,t],n)=>{n>0&&d(", ");const s=f(a,`from ${e}`);u.push({text:`[${e}: ${g(t)}]`,ranges:s})})),(0,r.jsxs)("div",{className:"ir-phi",children:[l&&(0,r.jsx)("span",{className:"debug-info-icon",onMouseEnter:e=>{const t=p(a);s(e,t)},onMouseLeave:i,onClick:e=>{const t=p(a);o(e,t)},children:"\u2139"}),!l&&(0,r.jsx)("span",{className:"debug-info-spacer"}),(0,r.jsx)("span",{className:"phi-operation",onMouseEnter:()=>t(c),onMouseLeave:n,children:u.map(((e,s)=>"string"==typeof e?(0,r.jsx)("span",{children:e},s):(0,r.jsx)(h,{part:e,onHover:t,onLeave:n},s)))})]})}function w({blockId:e,block:t,isEntry:n,onHover:s,onLeave:o,showTooltip:i,pinTooltip:a,hideTooltip:c}){return(0,r.jsxs)("div",{className:"ir-block",children:[(0,r.jsxs)("div",{className:"block-header",children:[(0,r.jsxs)("strong",{children:[e,":"]}),n&&(0,r.jsx)("span",{className:"entry-badge",children:"entry"})]}),(0,r.jsxs)("div",{className:"block-body",children:[t.phis.map(((e,t)=>(0,r.jsx)(x,{phi:e,onHover:s,onLeave:o,showTooltip:i,pinTooltip:a,hideTooltip:c},t))),t.instructions.map(((e,t)=>(0,r.jsx)(k,{instruction:e,onHover:s,onLeave:o,showTooltip:i,pinTooltip:a,hideTooltip:c},t))),(0,r.jsx)(v,{terminator:t.terminator,onHover:s,onLeave:o,showTooltip:i,pinTooltip:a,hideTooltip:c})]})]})}function T({name:e,func:t,onHover:n,onLeave:o,showTooltip:i,pinTooltip:a,hideTooltip:c}){const l=(0,s.useMemo)((()=>{const e=[],n=new Set,s=new Set,o=r=>{if(s.has(r))return;if(n.has(r))return;s.add(r);const i=t.blocks.get(r);if(!i)return;const a=i.terminator;"jump"===a.kind?o(a.target):"branch"===a.kind?(o(a.trueTarget),o(a.falseTarget)):"call"===a.kind&&o(a.continuation),s.delete(r),n.add(r),e.unshift([r,i])};o(t.entry);for(const[r,i]of t.blocks)n.has(r)||e.push([r,i]);return e}),[t]);return(0,r.jsxs)("div",{className:"ir-function",children:[(0,r.jsx)("div",{className:"function-header",children:(0,r.jsxs)("h4",{children:[e,":"]})}),l.map((([e,s])=>(0,r.jsx)(w,{blockId:e,block:s,isEntry:e===t.entry,onHover:n,onLeave:o,showTooltip:i,pinTooltip:a,hideTooltip:c},e)))]})}function E({ir:e,onOpcodeHover:t}){const{tooltip:n,setTooltip:s,showTooltip:a,pinTooltip:c,hideTooltip:l,closeTooltip:u}=o(),d=e=>{t?.(e)},p=()=>{t?.([])},m=e.main.blocks.size,f=e.create?.blocks.size||0,h=e.functions?.size||0;let g=0;if(e.functions)for(const o of e.functions.values())g+=o.blocks.size;return(0,r.jsxs)("div",{className:"ir-view",children:[(0,r.jsxs)("div",{className:"ir-header",children:[(0,r.jsx)("h3",{children:"IR"}),(0,r.jsxs)("div",{className:"ir-stats",children:[h>0&&(0,r.jsxs)("span",{children:["Functions: ",h," (",g," blocks)"]}),e.create&&(0,r.jsxs)("span",{children:["Create: ",f," blocks"]}),(0,r.jsxs)("span",{children:["Main: ",m," blocks"]})]})]}),(0,r.jsxs)("div",{className:"ir-content",children:[e.functions&&e.functions.size>0&&(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("div",{className:"section-label",children:"User Functions:"}),Array.from(e.functions.entries()).map((([e,t])=>(0,r.jsx)(T,{name:e,func:t,onHover:d,onLeave:p,showTooltip:a,pinTooltip:c,hideTooltip:l},e)))]}),e.create&&(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("div",{className:"section-label",children:"Constructor:"}),(0,r.jsx)(T,{name:"create",func:e.create,onHover:d,onLeave:p,showTooltip:a,pinTooltip:c,hideTooltip:l})]}),(0,r.jsx)("div",{className:"section-label",children:"Main (Runtime):"}),(0,r.jsx)(T,{name:"main",func:e.main,onHover:d,onLeave:p,showTooltip:a,pinTooltip:c,hideTooltip:l})]}),(0,r.jsx)(i,{tooltip:n,onUpdate:s,onClose:u})]})}let S,N,A=!1;function j(e){const{data:t,selected:n}=e;if(!S)return(0,r.jsx)("div",{children:"Loading..."});const{Handle:s,Position:o}=S;return(0,r.jsxs)("div",{className:`cfg-node ${t.isEntry?"entry":""} ${n?"selected":""}`,children:[(0,r.jsx)(s,{type:"target",position:o.Top,id:"top"}),(0,r.jsx)(s,{type:"target",position:o.Left,id:"left"}),(0,r.jsxs)("div",{className:"cfg-node-header",children:[(0,r.jsxs)("strong",{children:[t.functionName,"::",t.label]}),t.isEntry&&(0,r.jsx)("span",{className:"entry-badge",children:"entry"})]}),(0,r.jsxs)("div",{className:"cfg-node-stats",children:[t.instructionCount," instruction",1!==t.instructionCount?"s":""]}),(0,r.jsx)(s,{type:"source",position:o.Bottom,id:"bottom"}),(0,r.jsx)(s,{type:"source",position:o.Right,id:"right"})]})}function I({ir:e}){const[t,n]=(0,s.useState)(null);if(!S||!N)return(0,r.jsxs)("div",{className:"cfg-view",children:[(0,r.jsx)("div",{className:"cfg-header",children:(0,r.jsx)("h3",{children:"Control Flow Graph"})}),(0,r.jsx)("div",{className:"cfg-content",children:(0,r.jsx)("p",{children:"Loading dependencies..."})})]});const{default:o,Controls:i,Background:a,useNodesState:c,useEdgesState:l,useReactFlow:u,MarkerType:d}=S,p=N,m=u(),{initialNodes:f,initialEdges:h}=(0,s.useMemo)((()=>{const t=[],n=[],s=(e,s)=>{const o=Array.from(e.blocks.entries());o.forEach((([n,o])=>{const r=`${s}:${n}`;t.push({id:r,type:"block",position:{x:0,y:0},data:{label:n,block:o,isEntry:n===e.entry,instructionCount:o.instructions.length+1,functionName:s}})})),o.forEach((([e,t])=>{const o=`${s}:${e}`,r=t.terminator;if("jump"===r.kind){const e=`${s}:${r.target}`;n.push({id:`${o}-${e}`,source:o,target:e,sourceHandle:"bottom",targetHandle:"top",markerEnd:{type:d.ArrowClosed}})}else if("branch"===r.kind){const e=`${s}:${r.trueTarget}`,t=`${s}:${r.falseTarget}`;n.push({id:`${o}-${e}-true`,source:o,target:e,sourceHandle:"bottom",targetHandle:"top",label:"true",labelBgStyle:{fill:"#e8f5e9"},style:{stroke:"#4caf50"},markerEnd:{type:d.ArrowClosed,color:"#4caf50"}}),n.push({id:`${o}-${t}-false`,source:o,target:t,sourceHandle:"bottom",targetHandle:"top",label:"false",labelBgStyle:{fill:"#ffebee"},style:{stroke:"#f44336"},markerEnd:{type:d.ArrowClosed,color:"#f44336"}})}else if("call"===r.kind){const e=`${s}:${r.continuation}`;n.push({id:`${o}-${e}-call-cont`,source:o,target:e,sourceHandle:"bottom",targetHandle:"top",label:`after ${r.function}()`,labelBgStyle:{fill:"#f3e8ff"},style:{stroke:"#9333ea"},markerEnd:{type:d.ArrowClosed,color:"#9333ea"}})}}))};if(e.functions)for(const[r,i]of e.functions.entries())s(i,r);e.create&&s(e.create,"create"),s(e.main,"main");const o=new p.graphlib.Graph;o.setDefaultEdgeLabel((()=>({}))),o.setGraph({rankdir:"TB",nodesep:80,ranksep:120,edgesep:50}),t.forEach((e=>{o.setNode(e.id,{width:200,height:80})})),n.forEach((e=>{o.setEdge(e.source,e.target)})),p.layout(o);return{initialNodes:t.map((e=>{const t=o.node(e.id);return{...e,position:{x:t.x-100,y:t.y-40}}})),initialEdges:n}}),[e,d,p]),[g,y,b]=c(f),[k,v,x]=l(h);(0,s.useEffect)((()=>{y(f),v(h),setTimeout((()=>{m?.fitView?.({padding:.2,minZoom:.1,maxZoom:2})}),50)}),[f,h,y,v,m]);const w=(0,s.useCallback)(((e,t)=>{n(t.id)}),[]),T=(0,s.useMemo)((()=>{if(!t)return null;const e=g.find((e=>e.id===t));return e?.data.block??null}),[t,g]),E=(0,s.useMemo)((()=>!t||t.includes("-label")?null:t.replace(":","::")),[t]),A=(0,s.useCallback)((e=>{const t=e=>{if("bigint"==typeof e)return e.toString();if("string"==typeof e)return JSON.stringify(e);if("boolean"==typeof e)return e.toString();const t=e;if(!t.kind)return"?";switch(t.kind){case"const":return String(t.value||"?");case"temp":return`%${t.id||"?"}`;case"local":return`$${t.name||"?"}`;default:return"?"}};switch(e.kind){case"const":return`${e.dest} = ${e.value}`;case"binary":return`${e.dest} = ${t(e.left)} ${e.op} ${t(e.right)}`;case"unary":return`${e.dest} = ${e.op}${t(e.operand)}`;case"read":return"storage"===e.location&&e.slot?`${e.dest} = storage[${t(e.slot)}]`:`${e.dest} = read.${e.location}`;case"write":return"storage"===e.location&&e.slot?`storage[${t(e.slot)}] = ${t(e.value)}`:`write.${e.location} = ${t(e.value)}`;case"env":{const t=e;switch(t.op){case"msg_sender":return`${t.dest} = msg.sender`;case"msg_value":return`${t.dest} = msg.value`;case"msg_data":return`${t.dest} = msg.data`;case"block_timestamp":return`${t.dest} = block.timestamp`;case"block_number":return`${t.dest} = block.number`;default:return`${t.dest} = ${t.op}`}}case"hash":return`${e.dest} = keccak256(${t(e.value)})`;case"cast":return`${e.dest} = cast ${t(e.value)} to ${e.targetType.kind}`;case"compute_slot":if("mapping"===e.slotKind){const n=e;return`${n.dest} = compute_slot[mapping](${t(n.base)}, ${t(n.key)})`}if("array"===e.slotKind){const n=e;return`${n.dest} = compute_slot[array](${t(n.base)})`}if("field"===e.slotKind){const n=e;return`${n.dest} = compute_slot[field](${t(n.base)}, offset_${n.fieldOffset})`}return"unknown compute_slot";default:{const t=e;return`${t.dest||"?"} = ${t.kind||"unknown"}(...)`}}}),[]),I=(0,s.useCallback)((e=>{const t=e=>{if("bigint"==typeof e)return e.toString();if("string"==typeof e)return JSON.stringify(e);if("boolean"==typeof e)return e.toString();const t=e;if(!t.kind)return"?";switch(t.kind){case"const":return String(t.value||"?");case"temp":return`%${t.id||"?"}`;case"local":return`$${t.name||"?"}`;default:return"?"}};switch(e.kind){case"jump":return`jump ${e.target}`;case"branch":return`branch ${t(e.condition)} ? ${e.trueTarget} : ${e.falseTarget}`;case"return":return e.value?`return ${t(e.value)}`:"return void";case"call":{const n=e.arguments.map(t).join(", ");return`${e.dest?`${e.dest} = call ${e.function}(${n})`:`call ${e.function}(${n})`} -> ${e.continuation}`}default:return"unknown terminator"}}),[]),D=(0,s.useMemo)((()=>({block:j})),[]);return(0,r.jsxs)("div",{className:"cfg-view",children:[(0,r.jsx)("div",{className:"cfg-header",children:(0,r.jsx)("h3",{children:"Control Flow Graph"})}),(0,r.jsxs)("div",{className:"cfg-content",children:[(0,r.jsx)("div",{className:"cfg-graph",children:(0,r.jsxs)(o,{nodes:g,edges:k,onNodesChange:b,onEdgesChange:x,onNodeClick:w,nodeTypes:D,fitView:!0,fitViewOptions:{padding:.2,includeHiddenNodes:!1,minZoom:.1,maxZoom:2},minZoom:.05,maxZoom:4,children:[(0,r.jsx)(a,{}),(0,r.jsx)(i,{})]})}),T&&E&&(0,r.jsxs)("div",{className:"cfg-sidebar",children:[(0,r.jsxs)("h4",{children:["Block ",E,(0,r.jsx)("button",{className:"cfg-sidebar-close",onClick:()=>n(null),"aria-label":"Close sidebar",children:"\xd7"})]}),(0,r.jsxs)("div",{className:"block-instructions",children:[(0,r.jsx)("h5",{children:"Instructions:"}),(0,r.jsxs)("pre",{className:"instruction-list",children:[T.instructions.map(((e,t)=>(0,r.jsx)("div",{className:"instruction",children:A(e)},t))),(0,r.jsx)("div",{className:"instruction terminator",children:I(T.terminator)})]})]})]})]})]})}function D(e){const[t,o]=(0,s.useState)(A),[i,a]=(0,s.useState)(null);if((0,s.useEffect)((()=>{t||async function(){if(A)return!0;try{return S=await n.e(6780).then(n.bind(n,16780)),N=await Promise.all([n.e(4841),n.e(7991)]).then(n.t.bind(n,67991,19)),A=!0,!0}catch{return!1}}().then((e=>{e?o(!0):a("CfgView requires react-flow-renderer and dagre packages. Please install them: npm install react-flow-renderer dagre")})).catch((()=>{a("Failed to load CfgView dependencies")}))}),[t]),i)return(0,r.jsxs)("div",{className:"cfg-view",children:[(0,r.jsx)("div",{className:"cfg-header",children:(0,r.jsx)("h3",{children:"Control Flow Graph"})}),(0,r.jsx)("div",{className:"cfg-content",children:(0,r.jsx)("p",{style:{color:"var(--bugc-accent-red)",padding:"1rem"},children:i})})]});if(!t||!S)return(0,r.jsxs)("div",{className:"cfg-view",children:[(0,r.jsx)("div",{className:"cfg-header",children:(0,r.jsx)("h3",{children:"Control Flow Graph"})}),(0,r.jsx)("div",{className:"cfg-content",children:(0,r.jsx)("p",{style:{padding:"1rem"},children:"Loading..."})})]});const{ReactFlowProvider:c}=S;return(0,r.jsx)(c,{children:(0,r.jsx)(I,{...e})})}const $="bug",M={keywords:["contract","function","let","if","else","while","return","storage","memory","calldata","emit","event","mapping","struct","public","private","internal","external","view","pure","payable","constant","immutable"],typeKeywords:["uint256","uint128","uint64","uint32","uint16","uint8","int256","int128","int64","int32","int16","int8","bool","address","bytes32","bytes","string"],operators:["=",">","<","!","~","?",":","==","<=",">=","!=","&&","||","++","--","+","-","*","/","&","|","^","%","<<",">>","+=","-=","*=","/=","&=","|=","^=","%=","<<=",">>="],symbols:/[=><!~?:&|+\-*/^%]+/,escapes:/\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,tokenizer:{root:[[/[a-zA-Z_$][\w$]*/,{cases:{"@keywords":"keyword","@typeKeywords":"type","@default":"identifier"}}],{include:"@whitespace"},[/[{}()[\]]/,"@brackets"],[/[<>](?!@symbols)/,"@brackets"],[/@symbols/,{cases:{"@operators":"operator","@default":""}}],[/\d*\.\d+([eE][-+]?\d+)?/,"number.float"],[/0[xX][0-9a-fA-F]+/,"number.hex"],[/\d+/,"number"],[/[;,.]/,"delimiter"],[/"([^"\\]|\\.)*$/,"string.invalid"],[/"/,{token:"string.quote",bracket:"@open",next:"@string"}],[/'[^\\']'/,"string"],[/(')(@escapes)(')/,["string","string.escape","string"]],[/'/,"string.invalid"]],comment:[[/[^/*]+/,"comment"],[/\/\*/,"comment","@push"],["\\*/","comment","@pop"],[/[/*]/,"comment"]],string:[[/[^\\"]+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/"/,{token:"string.quote",bracket:"@close",next:"@pop"}]],whitespace:[[/[ \t\r\n]+/,"white"],[/\/\*/,"comment","@comment"],[/\/\/.*$/,"comment"]]}},C={comments:{lineComment:"//",blockComment:["/*","*/"]},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}]};let O,U,L=!1;async function P(){if(L)return!0;try{return O=await n.e(6952).then(n.bind(n,86952)),U=await Promise.all([n.e(1869),n.e(1720),n.e(5051)]).then(n.bind(n,91720)),(e=U).languages.register({id:$}),e.languages.setLanguageConfiguration($,C),e.languages.setMonarchTokensProvider($,M),L=!0,!0}catch{return!1}var e}function _({value:e,onChange:t,language:n="bug",highlightedRanges:o=[],theme:i="auto",height:a="100%"}){const c=(0,s.useRef)(null),l=(0,s.useRef)([]),[u,d]=(0,s.useState)(L),[p,m]=(0,s.useState)(null),[f,h]=(0,s.useState)("dark");(0,s.useEffect)((()=>{if("auto"===i){const e=()=>{const e=document.documentElement.getAttribute("data-theme");h("dark"===e?"dark":"light")};e();const t=new MutationObserver(e);return t.observe(document.documentElement,{attributes:!0,attributeFilter:["data-theme"]}),()=>t.disconnect()}}),[i]);const g="dark"===("auto"===i?f:i)?"vs-dark":"vs";(0,s.useEffect)((()=>{u||P().then((e=>{e?d(!0):m("Editor requires @monaco-editor/react package. Please install it: npm install @monaco-editor/react")})).catch((()=>{m("Failed to load Monaco editor")}))}),[u]),(0,s.useEffect)((()=>{const e=c.current;if(!e)return;const t=e.getModel();if(t&&(l.current=e.deltaDecorations(l.current,[]),o.length>0)){const n=o.map(((e,n)=>{const s=t.getPositionAt(e.offset),o=t.getPositionAt(e.offset+e.length),r=0===n,i=r?"opcode-hover-highlight":"opcode-hover-highlight-alternative",a=r?"opcode-hover-highlight-inline":"opcode-hover-highlight-alternative-inline";return{range:{startLineNumber:s.lineNumber,startColumn:s.column,endLineNumber:o.lineNumber,endColumn:o.column},options:{className:i,isWholeLine:!1,inlineClassName:a}}}));l.current=e.deltaDecorations([],n);const s=o[0],r=t.getPositionAt(s.offset),i=t.getPositionAt(s.offset+s.length);e.revealRangeInCenter({startLineNumber:r.lineNumber,startColumn:r.column,endLineNumber:i.lineNumber,endColumn:i.column})}}),[o]);if(p)return(0,r.jsx)("div",{style:{padding:"1rem",color:"var(--bugc-accent-red, #cf222e)"},children:p});if(!u||!O)return(0,r.jsx)("div",{style:{padding:"1rem"},children:"Loading editor..."});const y=O.default;return(0,r.jsx)(y,{height:a,language:n,theme:g,value:e,onChange:e=>t(e||""),onMount:e=>{c.current=e},options:{minimap:{enabled:!1},fontSize:14,lineNumbers:"on",scrollBeyondLastLine:!1,automaticLayout:!0,tabSize:2}})}},70396(e,t,n){var s;n.d(t,{B:()=>a,D:()=>f}),function(e){e.dereferencePointer=e=>({kind:"dereference-pointer",pointer:e}),e.saveRegions=e=>({kind:"save-regions",regions:e}),e.saveVariables=e=>({kind:"save-variables",variables:e}),e.pushRegionRenames=e=>({kind:"push-region-renames",mapping:e}),e.popRegionRenames=()=>({kind:"pop-region-renames"}),e.pushTemplates=e=>({kind:"push-templates",templates:e}),e.popTemplates=()=>({kind:"pop-templates"})}(s||(s={}));var o=n(31917),r=n(43568);const i=Symbol.for("nodejs.util.inspect.custom");class a extends Uint8Array{static zero(){return new a([])}static fromUint(e){if(0n===e)return this.zero();const t=Math.ceil(Number(e.toString(2).length)/8),n=new Uint8Array(t);for(let s=t-1;s>=0;s--)n[s]=Number(0xffn&e),e>>=8n;return new a(n)}static fromNumber(e){const t=Math.ceil(Math.log2(e+1)/8),n=new Uint8Array(t);for(let s=t-1;s>=0;s--)n[s]=255&e,e>>=8;return new a(n)}static fromHex(e){if(!e.startsWith("0x"))throw new Error('Invalid hex string format. Expected "0x" prefix.');const t=new Uint8Array((e.length-2)/2+.5);for(let n=2;n<e.length;n+=2)t[n/2-1]=parseInt(e.slice(n,n+2),16);return new a(t)}static fromBytes(e){return new a(e)}asUint(){const e=8n;let t=0n;for(const n of this.values()){t=(t<<e)+BigInt(n)}return t}toHex(){return`0x${(0,r.nj)(this)}`}padUntilAtLeast(e){if(this.length>=e)return this;const t=new Uint8Array(e);return t.set(this,e-this.length),a.fromBytes(t)}resizeTo(e){if(this.length===e)return this;const t=new Uint8Array(e);return this.length<e?t.set(this,e-this.length):t.set(this.slice(this.length-e)),a.fromBytes(t)}concat(...e){const t=[this,...e].map((e=>e.toHex().slice(2))).reduce(((e,t)=>`${e}${t}`),"0x");return a.fromHex(t)}inspect(e,t,n){return`Data[${t.stylize(this.toHex(),"number")}]`}[i](e,t,n){return this.inspect(e,t,n)}}async function c(e,t){const{location:n}=e,{state:s}=t;switch(n){case"stack":{const{slot:t,offset:n=0n,length:o=32n}=l(["slot","offset","length"],e);return await s.stack.peek({depth:t,slice:{offset:n,length:o}})}case"memory":{const{offset:t,length:n}=l(["offset","length"],e);return await s.memory.read({slice:{offset:t,length:n}})}case"storage":{const{slot:t}=e,{offset:n=0n,length:o=32n}=l(["offset","length"],e);return await s.storage.read({slot:t,slice:{offset:n,length:o}})}case"calldata":{const{offset:t,length:n}=l(["offset","length"],e);return await s.calldata.read({slice:{offset:t,length:n}})}case"returndata":{const{offset:t,length:n}=l(["offset","length"],e);return await s.returndata.read({slice:{offset:t,length:n}})}case"transient":{const{slot:t}=e,{offset:n=0n,length:o=32n}=l(["offset","length"],e);return await s.transient.read({slot:t,slice:{offset:n,length:o}})}case"code":{const{offset:t,length:n}=l(["offset","length"],e);return await s.code.read({slice:{offset:t,length:n}})}}}function l(e,t){const n={};for(const s of e){const e=t[s];void 0!==e&&(n[s]=e.asUint())}return n}var u=n(33688);async function d(e,t){if(o.gm.Expression.isLiteral(e))return async function(e){switch(typeof e){case"string":return a.fromHex(e);case"number":return a.fromNumber(e)}}(e);if(o.gm.Expression.isConstant(e))return async function(e){if("$wordsize"===e)return a.fromHex("0x20")}(e);if(o.gm.Expression.isVariable(e))return async function(e,{variables:t}){const n=t[e];if(void 0===n)throw new Error(`Unknown variable with identifier ${e}`);return n}(e,t);if(o.gm.Expression.isArithmetic(e)){if(o.gm.Expression.Arithmetic.isSum(e))return async function(e,t){const n=await Promise.all(e.$sum.map((async e=>await d(e,t)))),s=n.reduce(((e,{length:t})=>t>e?t:e),0);return a.fromUint(n.reduce(((e,t)=>e+t.asUint()),0n)).padUntilAtLeast(s)}(e,t);if(o.gm.Expression.Arithmetic.isDifference(e))return async function(e,t){const[n,s]=await Promise.all(e.$difference.map((async e=>await d(e,t)))),o=n.length>s.length?n.length:s.length,r=n.asUint()>s.asUint()?a.fromUint(n.asUint()-s.asUint()):a.fromNumber(0);return r.padUntilAtLeast(o)}(e,t);if(o.gm.Expression.Arithmetic.isProduct(e))return async function(e,t){const n=await Promise.all(e.$product.map((async e=>await d(e,t)))),s=n.reduce(((e,{length:t})=>t>e?t:e),0);return a.fromUint(n.reduce(((e,t)=>e*t.asUint()),1n)).padUntilAtLeast(s)}(e,t);if(o.gm.Expression.Arithmetic.isQuotient(e))return async function(e,t){const[n,s]=await Promise.all(e.$quotient.map((async e=>await d(e,t)))),o=n.length>s.length?n.length:s.length;return a.fromUint(n.asUint()/s.asUint()).padUntilAtLeast(o)}(e,t);if(o.gm.Expression.Arithmetic.isRemainder(e))return async function(e,t){const[n,s]=await Promise.all(e.$remainder.map((async e=>await d(e,t)))),o=n.length>s.length?n.length:s.length;return a.fromUint(n.asUint()%s.asUint()).padUntilAtLeast(o)}(e,t)}if(o.gm.Expression.isKeccak256(e))return async function(e,t){const n=await Promise.all(e.$keccak256.map((async e=>await d(e,t)))),s=a.zero().concat(...n);return a.fromBytes((0,u.So)(s))}(e,t);if(o.gm.Expression.isConcat(e))return async function(e,t){const n=await Promise.all(e.$concat.map((async e=>await d(e,t))));return a.zero().concat(...n)}(e,t);if(o.gm.Expression.isResize(e))return async function(e,t){const[[n,s]]=Object.entries(e),r=o.gm.Expression.Resize.isToNumber(e)?Number(n.match(/^\$sized([1-9]+[0-9]*)$/)[1]):32;return(await d(s,t)).resizeTo(r)}(e,t);if(o.gm.Expression.isLookup(e)){if(o.gm.Expression.Lookup.isOffset(e))return p(".offset",e,t);if(o.gm.Expression.Lookup.isLength(e))return p(".length",e,t);if(o.gm.Expression.Lookup.isSlot(e))return p(".slot",e,t)}if(o.gm.Expression.isRead(e))return async function(e,t){const{state:n,regions:s}=t,o=e.$read,r=s[o];if(!r)throw new Error(`Region not found: ${o}`);return await c(r,t)}(e,t);throw new Error(`Unexpected runtime failure to recognize kind of expression: ${JSON.stringify(e)}`)}async function p(e,t,n){const{regions:s}=n,r=t[e],i=s[r];if(!i)throw new Error(`Region not found: ${r}`);const a=o.gm.Expression.Lookup.propertyFrom(e),c=i[a];if(void 0===c)throw new Error(`Region named ${r} does not have ${a} needed by lookup`);return c}async function*m(e,t){if(o.gm.isRegion(e)){const n=e;return yield*async function*(e,{stackLengthChange:t,...n}){const r=await async function(e,t){const n={},s={},o=new Proxy({...e},{get(e,t){if(t in n)return n[t];throw new Error(`Property not evaluated yet: $this.${t.toString()}`)}}),r=["slot","offset","length"],i=r.filter((t=>t in e)).map((t=>[t,e[t]]));for(;i.length>0;){const[e,c]=i.shift();try{const s=await d(c,{...t,regions:{...t.regions,$this:o}});n[e]=s}catch(a){if(!(a instanceof Error&&a.message.startsWith("Property not evaluated yet: $this.")))throw a;{const t=s[e]||0;if(t>r.length-1)throw new Error(`Circular reference detected: $this.${e.toString()}`);s[e]=t+1,i.push([e,c])}}}return{...e,...n}}(function(e,t){if(o.gm.Region.isStack(e)){const n=0n===t?e.slot:t>0n?{$sum:[e.slot,`0x${t.toString(16)}`]}:{$difference:[e.slot,"0x"+-t.toString(16)]};return{...e,slot:n}}return e}(e,t),n);if(yield r,void 0!==e.name)return[s.saveRegions({[e.name]:r})];return[]}(n,t)}const n=e;if(o.gm.Collection.isGroup(n))return yield*async function*(e,t){const{group:n}=e;return n.map(s.dereferencePointer)}(n);if(o.gm.Collection.isList(n))return yield*async function*(e,t){const{list:n}=e,{count:o,each:r,is:i}=n,c=(await d(o,t)).asUint(),l=[];for(let u=0n;u<c;u++)l.push(s.saveVariables({[r]:a.fromUint(u)})),l.push(s.dereferencePointer(i));return l}(n,t);if(o.gm.Collection.isConditional(n))return yield*async function*(e,t){const{if:n,then:o,else:r}=e,i=(await d(n,t)).asUint();if(i)return[s.dereferencePointer(o)];return r?[s.dereferencePointer(r)]:[]}(n,t);if(o.gm.Collection.isScope(n))return yield*async function*(e,t){const{define:n,in:o}=e,r={...t.variables},i={};for(const[s,a]of Object.entries(n)){const e=await d(a,{...t,variables:r});r[s]=e,i[s]=e}return[s.saveVariables(i),s.dereferencePointer(o)]}(n,t);if(o.gm.Collection.isReference(n))return yield*async function*(e,t){const{template:n,yields:o}=e,{templates:r,variables:i}=t,a=r[n];if(!a)throw new Error(`Unknown pointer template named ${n}`);const{expect:c,for:l}=a,u=new Set(Object.keys(i)),d=c.filter((e=>!u.has(e)));if(d.length>0)throw new Error([`Invalid reference to template named ${n}; missing expected `,`variables with identifiers: ${d.join(", ")}. `,"Please ensure these variables are defined prior to this reference."].join(""));if(o&&Object.keys(o).length>0)return[s.pushRegionRenames(o),s.dereferencePointer(l),s.popRegionRenames()];return[s.dereferencePointer(l)]}(n,t);if(o.gm.Collection.isTemplates(n))return yield*async function*(e,t){const{templates:n,in:o}=e;return[s.pushTemplates(n),s.dereferencePointer(o),s.popTemplates()]}(n);throw console.error("%s",JSON.stringify(e,void 0,2)),new Error("Unexpected unknown kind of pointer")}async function f(e,t={}){const n=await async function({templates:e={},state:t}){const n=t?await t.stack.length:0n;return{templates:e,initialStackLength:n}}(t);return function(e){return{async view(t){const n=[];for await(const a of e(t))n.push(a);const s={},o={},r={writable:!1,enumerable:!1,configurable:!1},i=Object.create(Array.prototype,{length:{value:n.length,...r}});for(const[e,a]of n.entries())Object.defineProperty(i,e,{value:a,...r,enumerable:!0}),"string"==typeof a.name&&(a.name in s||(s[a.name]=[]),s[a.name].push(a),o[a.name]=a);for(const[e,a]of Object.entries(o))Object.defineProperty(i,e,{value:a,...r});return Object.defineProperties(i,{named:{value:e=>s[e]||[],...r},lookup:{value:{...o},...r}}),{regions:i,read:async e=>await c(e,{state:t})}}}}((t=>({async*[Symbol.asyncIterator](){yield*async function*(e,t){const n=await async function({templates:e,state:t,initialStackLength:n}){return{templates:e,state:t,stackLengthChange:await t.stack.length-n,regions:{},variables:{}}}(t),{regions:o,variables:r}=n,i=[],a=[],c=[s.dereferencePointer(e)];for(;c.length>0;){const e=c.pop();let t=[];switch(e.kind){case"dereference-pointer":{const s=a.reduce(((e,t)=>({...e,...t})),n.templates),o=m(e.pointer,{...n,templates:s});let r=await o.next();for(;!r.done;){let e=r.value;const t=i[i.length-1];if(t&&e.name){const n=t[e.name];n&&n!==e.name&&(e={...e,name:n})}yield e,r=await o.next()}t=r.value;break}case"save-regions":for(const[t,n]of Object.entries(e.regions))o[t]=n;break;case"save-variables":Object.assign(r,e.variables);break;case"push-region-renames":i.push(e.mapping);break;case"pop-region-renames":{const e=i.pop();if(e)for(const[t,n]of Object.entries(e))t in o&&n!==t&&(o[n]={...o[t],name:n});break}case"push-templates":a.push(e.templates);break;case"pop-templates":a.pop()}for(let n=t.length-1;n>=0;n--)c.push(t[n])}}(e,{...n,state:t})}})))}},79170(e,t,n){n.d(t,{BR:()=>c,QX:()=>Q,bO:()=>J,jM:()=>N});var s=n(31085),o=n(14041);function r(e,t){const n=function(e,{sources:t}){if("function"!=typeof e)return e;const n=(e,n={})=>{const s="source"in n&&n.source?t.find((e=>e.id===n.source?.id)):t[0];if(!s)return;const o=n.after||"",r=s.contents.indexOf(o);if(-1===r)throw new Error(`Unexpected could not find string ${n.after} as prior occurrence to ${e}`);const i=r+o.length,a=s.contents.indexOf(e,i);if(-1===a)throw new Error(`Unexpected could not find string ${e}`);const c=e.length;return{source:{id:s.id},range:{offset:a,length:c}}};return e({findSourceRange:n})}(e.context,t);return{...e,context:n}}const i=(0,o.createContext)(void 0);function a(){const e=(0,o.useContext)(i);if(void 0===e)throw new Error("useProgramExampleContext must be used within a ProgramExampleContextProvider");return e}function c({children:e,...t}){const{sources:n,instructions:a}=t,c=function(e){const{results:t}=e.reduce((({nextOffset:e,results:t},n)=>{const s={offset:e,...n};return{nextOffset:e+(1+Math.ceil((n.operation.arguments||[]).map((e=>"number"==typeof e?e.toString(16):e.slice(2))).join("").length/2)),results:[...t,s]}}),{nextOffset:0,results:[]});return t}(a),l=c.map((e=>r(e,{sources:n}))),[u,d]=(0,o.useState)(),[p,m]=(0,o.useState)(),[f,h]=(0,o.useState)("simple");return(0,o.useEffect)((()=>{if(void 0===u)return void m(void 0);const e=l.find((({offset:e})=>e===u));if(!e)throw new Error(`Unexpected could not find instruction with offset ${u}`);m(e)}),[u,m]),(0,s.jsx)(i.Provider,{value:{sources:n,instructions:l,highlightedInstruction:p,highlightInstruction:d,highlightMode:f,showDetails:()=>h("detailed"),hideDetails:()=>h("simple")},children:e})}function l(){const{instructions:e,highlightedInstruction:t,highlightInstruction:n,highlightMode:r,showDetails:i,hideDetails:c}=a(),[l,d]=(0,o.useState)(),[p,m]=(0,o.useState)();(0,o.useEffect)((()=>{if(void 0!==l)return t?.offset!==l&&n(l),void("simple"===r&&i());"detailed"===r&&c(),void 0===p?n(void 0):t?.offset!==p&&n(p)}),[l,p,t,r]);const f=()=>m(void 0),h=e.at(-1).offset.toString(16).length;return(0,s.jsx)("dl",{className:"opcodes",children:e.map((e=>(0,s.jsx)(u,{instruction:e,active:l===e.offset,paddingLength:h,onClick:()=>{return t=e.offset,d(t===l?void 0:t);var t},onMouseEnter:()=>{return t=e.offset,m(t);var t},onMouseLeave:f},e.offset)))})}function u(e){const{instruction:t,active:n,paddingLength:o,onClick:r,onMouseEnter:i,onMouseLeave:a}=e,{offset:c,operation:l,context:u}=t,d=(0,s.jsxs)(s.Fragment,{children:["0x",c.toString(16).padStart(o,"0")]}),p=u&&"remark"in u?(0,s.jsxs)(s.Fragment,{children:[" (",u.remark,")"]}):(0,s.jsx)(s.Fragment,{}),m=(0,s.jsxs)(s.Fragment,{children:[l&&(0,s.jsx)("code",{children:[l.mnemonic,...l.arguments||[]].join(" ")}),p]});return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("dt",{className:n?"active":"",onClick:r,onMouseEnter:i,onMouseLeave:a,title:"Click for more instruction details",children:d}),(0,s.jsx)("dd",{onMouseEnter:i,onMouseLeave:a,children:m})]})}var d=n(20994),p=n(29755);function m(){const[e,t]=(0,o.useState)();return(0,o.useEffect)((()=>{(async function(){const e=await d.tz({themes:[n.e(5965).then(n.bind(n,5965))],langs:[n.e(1147).then(n.bind(n,51147)),n.e(5065).then(n.bind(n,15065))],engine:(0,p.Mk)(n.e(999).then(n.bind(n,999)))}),t="github-light";return{highlight:(n,{language:s,decorations:o})=>e.codeToHtml(n,{lang:s||"text",theme:t,decorations:o})}})().then(t)}),[t]),e}function f({code:e,className:t,...n}){const o=m();if(!o)return(0,s.jsx)(s.Fragment,{children:"Loading..."});const r=o.highlight(e,n);return(0,s.jsx)("div",{className:t,dangerouslySetInnerHTML:{__html:r}})}var h=n(31917);function g(e){const{sources:t,highlightedInstruction:n,highlightMode:o}=a();if(1!==t.length)throw new Error("Multiple sources per example not currently supported");const r=t[0],i=n?.context,c=h.BP.Context.isCode(i)?y(i,r):h.BP.Context.isPick(i)?function({pick:e},t){if(!e.every(h.BP.Context.isCode))return console.warn("decoratePickContext encountered non-code contexts in pick array. These will be ignored."),[];return e.flatMap((e=>y(e,t,"highlighted-ambiguous-code")))}(i,r):[],l=[...c,...h.BP.Context.isVariables(i)?b(i,r):[]],u="detailed"===o?l:c;return(0,s.jsx)(f,{className:"source-contents",code:r.contents,language:"javascript",decorations:u,...e})}function y({code:e},t,n="highlighted-code"){const{offset:s,length:o}=k(e.range,t);return[{start:s,end:s+o,properties:{class:n}}]}function b({variables:e},t){return e.map((({declaration:e})=>{const{offset:n,length:s}=k(e?.range,t);return{start:n,end:n+s,properties:{class:"highlighted-variable-declaration"}}}))}function k(e,t){const{offset:n,length:s}=e?{offset:Number(e.offset),length:Number(e.length)}:{offset:0,length:t.contents.length};return{offset:n,length:s}}function v(){const{highlightedInstruction:e}=a();return(0,s.jsx)(s.Fragment,{children:(0,s.jsx)(f,{language:"javascript",code:JSON.stringify(e,void 0,2)})})}var x=n(42857),w=n(40665);function T(e){const{highlightedInstruction:t,highlightMode:n}=a();return"simple"!==n&&t?(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("h3",{children:"Details"}),(0,s.jsx)(E,{instruction:t}),(0,s.jsxs)("details",{children:[(0,s.jsxs)("summary",{children:["See full ",(0,s.jsx)("strong",{children:"ethdebug/format/program/instruction"})," object"]}),(0,s.jsx)(v,{})]})]}):(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("h3",{children:"Details"}),(0,s.jsx)(S,{})]})}function E({instruction:e}){return(0,s.jsxs)(x.A,{type:"info",children:[(0,s.jsxs)("p",{children:["The selected instruction provides the following"," ",(0,s.jsxs)(w.A,{to:"/spec/program/context",children:[(0,s.jsx)("strong",{children:"ethdebug/format"})," Program contexts"]}),":"]}),(0,s.jsxs)("ul",{children:[(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Code context"})," is highlighted"," ",(0,s.jsx)("span",{className:"highlighted-code",children:"in this style"})," above."]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"Variables context"})," is indicated by variable declarations highlighted"," ",(0,s.jsx)("span",{className:"highlighted-variable-declaration",children:"in this style"})," ","above."]})]})]})}function S(e){return(0,s.jsxs)(x.A,{type:"tip",children:["Select an instruction offset to see associated"," ",(0,s.jsx)("strong",{children:"ethdebug/format"})," debugging information."]})}function N(e){return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("h2",{children:"Interactive example"}),(0,s.jsxs)("div",{className:"viewer-row",children:[(0,s.jsxs)("div",{children:[(0,s.jsx)("h3",{id:"source-contents",children:"Source contents"}),(0,s.jsx)(g,{})]}),(0,s.jsxs)("div",{children:[(0,s.jsx)("h3",{id:"compiled-opcodes",children:"Compiled opcodes"}),(0,s.jsx)(l,{})]})]}),(0,s.jsx)(T,{})]})}const A=(0,o.createContext)(null);function j({children:e,initialExample:t=null,initialOpen:n=!1}){const[r,i]=(0,o.useState)(t),[a,c]=(0,o.useState)(n),l=(0,o.useCallback)((()=>c(!0)),[]),u=(0,o.useCallback)((()=>c(!1)),[]),d=(0,o.useCallback)((()=>c((e=>!e))),[]),p=(0,o.useCallback)((e=>{i(e),c(!0)}),[]),m=(0,o.useCallback)((e=>{i((t=>t?{...t,source:e}:{source:e}))}),[]);return(0,s.jsx)(A.Provider,{value:{example:r,isOpen:a,loadExample:p,setSource:m,openDrawer:l,closeDrawer:u,toggleDrawer:d},children:e})}var I=n(49499),D=n(9921),$=n(39612),M=n(91031),C=n(27898),O=n(22772),U=n(75045),L=n(22421),P=n(38628),_=n(1048).hp;class B{constructor(){const e=new O.y_({chain:O.DA,hardfork:"shanghai"});this.stateManager=new C.xH,this.evm=new M.ZM({common:e,stateManager:this.stateManager}),this.contractAddress=new U.pVw((0,L.aT)("1234567890123456789012345678901234567890")),this.deployerAddress=new U.pVw((0,L.aT)("0000000000000000000000000000000000000001"))}getDeployerAddress(){return this.deployerAddress}getContractAddress(){return this.contractAddress}async deploy(e){const t=(0,L.aT)(e),n=new U.gDM(0n,BigInt(10)**BigInt(18));await this.stateManager.putAccount(this.deployerAddress,n);const s=new U.gDM(0n,0n);await this.stateManager.putAccount(this.contractAddress,s);const o=await this.evm.runCall({caller:this.deployerAddress,origin:this.deployerAddress,to:void 0,data:t,gasLimit:10000000n,value:0n}),r=o.execResult?.exceptionError;if(r)throw new Error(`Deployment failed: ${JSON.stringify(r)}`);const i=o.createdAddress;i&&(this.contractAddress=i)}async execute(e={},t){const n={to:this.contractAddress,caller:e.caller??this.deployerAddress,origin:e.origin??this.deployerAddress,data:e.data?(0,L.aT)(e.data):new Uint8Array,value:e.value??0n,gasLimit:e.gasLimit??10000000n};t&&this.evm.events.on("step",(e=>{const n={pc:e.pc,opcode:e.opcode.name,stack:[...e.stack]};t(n)}));const s=await this.evm.runCall(n);t&&this.evm.events.removeAllListeners("step");const o=s,r=o.execResult||o;return{success:void 0===r.exceptionError,gasUsed:r.executionGasUsed||0n,returnValue:r.returnValue||new Uint8Array,logs:r.logs||[],error:r.exceptionError}}async executeCode(e,t={}){const n=(0,L.aT)(e),s=new U.pVw((0,L.aT)("9999999999999999999999999999999999999999"));await this.stateManager.putCode(s,n),await this.stateManager.putAccount(s,new U.gDM(0n,0n));const o={code:n,data:t.data?(0,L.aT)(t.data):new Uint8Array,gasLimit:t.gasLimit??10000000n,value:t.value??0n,origin:t.origin??new U.pVw(_.alloc(20)),caller:t.caller??new U.pVw(_.alloc(20)),address:s},r=await this.evm.runCode(o),i=r.execResult||r;return{success:void 0===i.exceptionError,gasUsed:i.executionGasUsed||0n,returnValue:i.returnValue||new Uint8Array,logs:i.logs||[],error:i.exceptionError}}async getStorage(e){const t=_.alloc(32),n=e.toString(16).padStart(64,"0");t.write(n,"hex");const s=await this.stateManager.getStorage(this.contractAddress,t);return 0===s.length?0n:BigInt("0x"+(0,P.My)(s))}async setStorage(e,t){const n=_.alloc(32);n.writeBigUInt64BE(e,24);const s=_.alloc(32),o=t.toString(16).padStart(64,"0");s.write(o,"hex"),await this.stateManager.putStorage(this.contractAddress,n,s)}async getCode(){return this.stateManager.getCode(this.contractAddress)}async reset(){this.stateManager=new C.xH,this.evm=new M.ZM({common:new O.y_({chain:O.DA,hardfork:"shanghai"}),stateManager:this.stateManager})}}n(70396);function R({isOpen:e,onClose:t,onToggle:n,title:r,headerActions:i,children:a,className:c=""}){const[l,u]=(0,o.useState)((()=>"undefined"!=typeof window?Math.round(.45*window.innerHeight):400)),[d,p]=(0,o.useState)(!1),m=(0,o.useRef)(null),f=(0,o.useCallback)((e=>{e.preventDefault(),p(!0)}),[]);(0,o.useEffect)((()=>{if(!d)return;const e=e=>{const t="touches"in e?e.touches[0].clientY:e.clientY,n=window.innerHeight,s=n-t,o=.85*n;u(Math.max(200,Math.min(s,o)))},t=()=>{p(!1)};return document.addEventListener("mousemove",e),document.addEventListener("mouseup",t),document.addEventListener("touchmove",e),document.addEventListener("touchend",t),()=>{document.removeEventListener("mousemove",e),document.removeEventListener("mouseup",t),document.removeEventListener("touchmove",e),document.removeEventListener("touchend",t)}}),[d]),(0,o.useEffect)((()=>{const n=n=>{"Escape"===n.key&&e&&t()};return document.addEventListener("keydown",n),()=>document.removeEventListener("keydown",n)}),[e,t]);const h=`drawer ${c}`.trim();return e?(0,s.jsxs)("div",{ref:m,className:`${h} open ${d?"resizing":""}`,style:{"--drawer-height":`${l}px`},children:[(0,s.jsx)("div",{className:"drawer-resize-handle",onMouseDown:f,onTouchStart:f,children:(0,s.jsx)("div",{className:"drawer-resize-bar"})}),(0,s.jsxs)("div",{className:"drawer-header",children:[(0,s.jsxs)("button",{className:"drawer-toggle",onClick:n,type:"button","aria-expanded":!0,"aria-label":`Close ${r}`,children:[(0,s.jsx)("span",{className:"drawer-toggle-icon",children:"\u25bc"}),(0,s.jsx)("span",{className:"drawer-toggle-text",children:r})]}),(0,s.jsxs)("div",{className:"drawer-header-actions",children:[i,(0,s.jsx)("button",{className:"drawer-close",onClick:t,type:"button","aria-label":"Close",children:"\u2715"})]})]}),(0,s.jsx)("div",{className:"drawer-content",children:a})]}):(0,s.jsx)("div",{ref:m,className:`${h} closed`,style:{"--drawer-height":`${l}px`},children:(0,s.jsx)("div",{className:"drawer-header",children:(0,s.jsxs)("button",{className:"drawer-toggle",onClick:n,type:"button","aria-expanded":!1,"aria-label":`Open ${r}`,children:[(0,s.jsx)("span",{className:"drawer-toggle-icon",children:"\u25b2"}),(0,s.jsx)("span",{className:"drawer-toggle-text",children:r})]})})})}function V(){return(0,s.jsx)(I.A,{fallback:null,children:()=>(0,s.jsx)(z,{})})}function z(){const{example:e,isOpen:t,toggleDrawer:n,closeDrawer:r,setSource:i}=function(){const e=(0,o.useContext)(A);if(!e)throw new Error("useTracePlayground must be used within a TracePlaygroundProvider");return e}(),[a,c]=(0,o.useState)(e?.source??""),[l,u]=(0,o.useState)(null),[d,p]=(0,o.useState)(!1),[m,f]=(0,o.useState)([]),[h,g]=(0,o.useState)(0),[y,b]=(0,o.useState)(!1),[k,v]=(0,o.useState)(null),[x,w]=(0,o.useState)({}),T=(0,o.useMemo)((()=>{const e=new Map;if(!l?.bytecode?.runtimeInstructions)return e;let t=0;for(const n of l.bytecode.runtimeInstructions)e.set(t,n),t+=1+(n.immediates?.length||0);return e}),[l?.bytecode?.runtimeInstructions]),E=(0,o.useMemo)((()=>{if(0===m.length||h>=m.length)return[];const e=m[h],t=T.get(e.pc);return t?.debug?.context?(0,$.sH)(t.debug.context):[]}),[m,h,T]),S=(0,o.useMemo)((()=>{if(0===m.length||h>=m.length)return[];const e=m[h],t=T.get(e.pc);return t?.debug?.context?Y(t.debug.context):[]}),[m,h,T]),N=(0,o.useCallback)((async e=>{let t;p(!0),u(null),f([]),g(0),v(null),w({});try{const n=await(0,D.wE)({to:"bytecode",source:e,optimizer:{level:0}});if(!n.success){const e=n.messages[D.AI.Error]||[];return void u({success:!1,error:e[0]?.message||"Compilation failed"})}t={runtime:n.value.bytecode.runtime,create:n.value.bytecode.create,runtimeInstructions:n.value.bytecode.runtimeInstructions,createInstructions:n.value.bytecode.createInstructions},u({success:!0,bytecode:t})}catch(n){return void u({success:!1,error:n instanceof Error?n.message:String(n)})}finally{p(!1)}if(t){b(!0);try{const e=new B;if(t.create){const n=Array.from(t.create).map((e=>e.toString(16).padStart(2,"0"))).join("");await e.deploy(n)}const[n,s]=function(){const e=[];return[t=>{e.push(t)},()=>({steps:[...e]})]}();await e.execute({},n);const o=s();f(o.steps),g(0);const r={};for(let t=0n;t<16n;t++){const n=await e.getStorage(t);if(0n!==n){r[`0x${t.toString(16).padStart(2,"0")}`]=`0x${n.toString(16).padStart(64,"0")}`}}w(r)}catch(n){v(n instanceof Error?n.message:String(n))}finally{b(!1)}}}),[]);(0,o.useEffect)((()=>{e?.source&&(c(e.source),N(e.source))}),[e,N]);const j=(0,o.useCallback)((e=>{c(e),i(e)}),[i]),I=(0,o.useCallback)((()=>{N(a)}),[a,N]),M=m[h],C=m.length>0,O=d||y,U=(0,s.jsx)("button",{className:"trace-drawer-btn trace-btn",onClick:I,disabled:O||!a.trim(),type:"button",children:d?"Compiling...":y?"Running...":"Compile & Run"});return(0,s.jsx)(R,{isOpen:t,onClose:r,onToggle:n,title:e?.title||"Trace Playground",headerActions:U,className:"trace-drawer",children:(0,s.jsxs)("div",{className:"trace-drawer-layout",children:[(0,s.jsx)("div",{className:"trace-drawer-editor",children:(0,s.jsx)($.KE,{value:a,onChange:j,language:"bug",highlightedRanges:E})}),(0,s.jsxs)("div",{className:"trace-drawer-output",children:[l&&!l.success&&(0,s.jsxs)("div",{className:"trace-drawer-error",children:[(0,s.jsx)("strong",{children:"Compile Error:"})," ",l.error]}),k&&(0,s.jsxs)("div",{className:"trace-drawer-error",children:[(0,s.jsx)("strong",{children:"Trace Error:"})," ",k]}),!C&&O&&(0,s.jsx)("div",{className:"trace-drawer-placeholder",children:d?"Compiling...":"Running trace..."}),C&&(0,s.jsxs)("div",{className:"trace-viewer",children:[(0,s.jsxs)("div",{className:"trace-controls",children:[(0,s.jsx)("button",{onClick:()=>g(0),disabled:0===h,className:"trace-nav-btn",title:"Jump to start",children:"\u23ee"}),(0,s.jsx)("button",{onClick:()=>{g((e=>Math.max(e-1,0)))},disabled:0===h,className:"trace-nav-btn",title:"Step backward",children:"\u25c0"}),(0,s.jsxs)("span",{className:"trace-step-info",children:[h+1," / ",m.length]}),(0,s.jsx)("button",{onClick:()=>{g((e=>Math.min(e+1,m.length-1)))},disabled:h>=m.length-1,className:"trace-nav-btn",title:"Step forward",children:"\u25b6"}),(0,s.jsx)("button",{onClick:()=>g(m.length-1),disabled:h>=m.length-1,className:"trace-nav-btn",title:"Jump to end",children:"\u23ed"})]}),(0,s.jsxs)("div",{className:"trace-panels",children:[(0,s.jsxs)("div",{className:"trace-panel opcodes-panel",children:[(0,s.jsx)("div",{className:"panel-header",children:"Instructions"}),(0,s.jsx)(F,{trace:m,currentStep:h,onStepClick:g})]}),(0,s.jsx)("div",{className:"trace-panel state-panel",children:M&&(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)("div",{className:"current-opcode",children:[(0,s.jsx)("code",{children:M.opcode}),(0,s.jsxs)("span",{className:"opcode-pc",children:["@ 0x",M.pc.toString(16)]})]}),(0,s.jsx)("div",{className:"panel-header",children:"Stack"}),(0,s.jsx)(H,{stack:M.stack}),S.length>0&&(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("div",{className:"panel-header",children:"Variables"}),(0,s.jsx)(K,{variables:S})]}),Object.keys(x).length>0&&(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("div",{className:"panel-header",children:"Storage"}),(0,s.jsx)(q,{storage:x})]})]})})]})]})]})]})})}function F({trace:e,currentStep:t,onStepClick:n}){const o=Math.max(0,t-8),r=Math.min(e.length,t+8+1),i=e.slice(o,r);return(0,s.jsxs)("div",{className:"opcode-list",children:[o>0&&(0,s.jsxs)("div",{className:"opcode-ellipsis",children:["... ",o," above"]}),i.map(((e,r)=>{const i=o+r,a=i===t;return(0,s.jsxs)("div",{className:"opcode-item "+(a?"active":""),onClick:()=>n(i),children:[(0,s.jsx)("span",{className:"opcode-index",children:i+1}),(0,s.jsxs)("span",{className:"opcode-pc",children:["0x",e.pc.toString(16).padStart(4,"0")]}),(0,s.jsx)("code",{className:"opcode-name",children:e.opcode})]},i)})),r<e.length&&(0,s.jsxs)("div",{className:"opcode-ellipsis",children:["... ",e.length-r," below"]})]})}function H({stack:e}){return 0===e.length?(0,s.jsx)("div",{className:"stack-empty",children:"(empty)"}):(0,s.jsxs)("div",{className:"stack-list",children:[e.slice(0,6).map(((e,t)=>(0,s.jsxs)("div",{className:"stack-item",children:[(0,s.jsxs)("span",{className:"stack-index",children:["[",t,"]"]}),(0,s.jsx)("code",{className:"stack-value",children:W(e)})]},t))),e.length>6&&(0,s.jsxs)("div",{className:"stack-item stack-more",children:["... ",e.length-6," more"]})]})}function q({storage:e}){const t=Object.entries(e);return(0,s.jsx)("div",{className:"storage-list",children:t.map((([e,t])=>(0,s.jsxs)("div",{className:"storage-item",children:[(0,s.jsx)("span",{className:"storage-slot",children:e}),(0,s.jsx)("span",{className:"storage-arrow",children:"\u2192"}),(0,s.jsx)("code",{className:"storage-value",children:t.length>18?t.slice(0,18)+"...":t})]},e)))})}function W(e){const t=e.toString(16);return t.length<=8?`0x${t}`:`0x${t.slice(0,6)}...${t.slice(-4)}`}function K({variables:e}){return(0,s.jsx)("div",{className:"variables-list",children:e.map(((e,t)=>(0,s.jsxs)("div",{className:"variable-item",children:[(0,s.jsx)("span",{className:"variable-name",children:e.identifier}),e.type&&(0,s.jsx)("span",{className:"variable-type",children:e.type})]},t)))})}function Y(e){if(!e||"object"!=typeof e)return[];const t=e,n=[];if(t.variables&&Array.isArray(t.variables))for(const s of t.variables)if(s&&"object"==typeof s&&"identifier"in s){const e=s;n.push({identifier:String(e.identifier),type:e.type?G(e.type):void 0})}if(t.gather&&Array.isArray(t.gather))for(const s of t.gather)n.push(...Y(s));return t.frame&&"object"==typeof t.frame&&n.push(...Y(t.frame)),t.context&&n.push(...Y(t.context)),n}function G(e){if(!e||"object"!=typeof e)return String(e);const t=e;return"uint"===t.kind&&"number"==typeof t.bits?`uint${t.bits}`:"int"===t.kind&&"number"==typeof t.bits?`int${t.bits}`:"bool"===t.kind?"bool":"address"===t.kind?"address":"bytes"===t.kind&&"number"==typeof t.size?`bytes${t.size}`:JSON.stringify(e)}function J({children:e,initialExample:t}){return(0,s.jsx)(I.A,{fallback:(0,s.jsx)("div",{className:"trace-playground-fallback",children:e}),children:()=>(0,s.jsxs)(j,{initialExample:t??null,initialOpen:!1,children:[(0,s.jsx)("div",{className:"trace-playground-content",children:e}),(0,s.jsx)(V,{})]})})}var Z=n(54034),X=n.n(Z);function Q({source:e,title:t,description:n,showPreview:o=!0}){return(0,s.jsxs)("div",{className:"trace-example",children:[t&&(0,s.jsx)("div",{className:"trace-example-title",children:t}),n&&(0,s.jsx)("div",{className:"trace-example-description",children:n}),(0,s.jsxs)("div",{className:"trace-example-content",children:[o&&(0,s.jsx)("div",{className:"trace-example-code",children:(0,s.jsx)(X(),{language:"javascript",children:e.trim()})}),(0,s.jsx)(I.A,{fallback:null,children:()=>(0,s.jsx)(ee,{source:e,title:t})})]})]})}function ee({source:e,title:t}){const n=(0,o.useContext)(A);if(!n)return null;return(0,s.jsxs)("button",{className:"trace-example-try-btn",onClick:()=>{n.loadExample({source:e,title:t})},type:"button",title:"Load this example in the Trace Playground",children:[(0,s.jsx)("span",{className:"try-btn-icon",children:"\u25b6"}),(0,s.jsx)("span",{className:"try-btn-text",children:"Try it"})]})}},87270(e,t,n){n.d(t,{A:()=>m});n(14041);var s=n(40665),o=n(54034),r=n.n(o);const i="container_eo8G",a="header_CGit",c="title_NhXp",l="schemaLink_R3qF",u="schemaName_hPpq",d="schemaLabel_TlZH";var p=n(31085);function m({schema:e,href:t,children:n,title:o}){const m="string"==typeof n?n:JSON.stringify(n,null,2),f=e.startsWith("ethdebug/format/")?e:`ethdebug/format/${e}`;return(0,p.jsxs)("div",{className:i,children:[(0,p.jsxs)("div",{className:a,children:[o&&(0,p.jsx)("span",{className:c,children:o}),(0,p.jsxs)(s.A,{to:t,className:l,children:[(0,p.jsx)("span",{className:d,children:"Schema:"}),(0,p.jsx)("span",{className:u,children:f})]})]}),(0,p.jsx)(r(),{language:"json",children:m})]})}}}]);