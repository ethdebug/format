"use strict";(globalThis.webpackChunk_ethdebug_format_web=globalThis.webpackChunk_ethdebug_format_web||[]).push([[720],{38532(e,t,n){n.d(t,{C:()=>E,rM:()=>$});var s=n(31085),r=n(14041),i=n(70396);function o(e){return e.toHex()}function a(e={}){const{initialPointer:t=null,initialStateSpec:n={},autoResolve:s=!0}=e,[o,a]=(0,r.useState)(t),[l,c]=(0,r.useState)(n),[d,h]=(0,r.useState)(!1),[u,p]=(0,r.useState)(null),[m,g]=(0,r.useState)(null),x=(0,r.useCallback)(((e,t)=>{c((n=>({...n,[e]:t})))}),[]),f=(0,r.useCallback)((async()=>{if(!o)return p(null),void g(null);h(!0),g(null);try{const e=function(e){const t=(e.stack||[]).map((e=>"string"==typeof e?i.B.fromHex(e).padUntilAtLeast(32):i.B.fromUint(e).padUntilAtLeast(32))),n=e.memory?i.B.fromHex(e.memory):i.B.zero(),s=new Map;for(const[c,d]of Object.entries(e.storage||{})){const e=i.B.fromHex(c).padUntilAtLeast(32).toHex();s.set(e,i.B.fromHex(d).padUntilAtLeast(32))}const r=e.calldata?i.B.fromHex(e.calldata):i.B.zero(),o=e.returndata?i.B.fromHex(e.returndata):i.B.zero(),a=e.code?i.B.fromHex(e.code):i.B.zero(),l=new Map;for(const[c,d]of Object.entries(e.transient||{})){const e=i.B.fromHex(c).padUntilAtLeast(32).toHex();l.set(e,i.B.fromHex(d).padUntilAtLeast(32))}return{get traceIndex(){return Promise.resolve(e.traceIndex??0n)},get programCounter(){return Promise.resolve(e.programCounter??0n)},get opcode(){return Promise.resolve(e.opcode??"STOP")},stack:{get length(){return Promise.resolve(BigInt(t.length))},async peek({depth:e,slice:n}){const s=Number(e);if(s>=t.length)throw new Error(`Stack underflow: depth ${e} exceeds stack size`);const r=t[s];if(!n)return r;const{offset:o,length:a}=n,l=32-Number(o)-Number(a),c=l+Number(a);return i.B.fromBytes(r.slice(l,c))}},memory:{get length(){return Promise.resolve(BigInt(n.length))},async read({slice:e}){const{offset:t,length:s}=e,r=Number(t),o=r+Number(s);if(o>n.length){const e=new Uint8Array(Number(s)),t=Math.max(0,n.length-r);return t>0&&r<n.length&&e.set(n.slice(r,r+t),0),i.B.fromBytes(e)}return i.B.fromBytes(n.slice(r,o))}},storage:{async read({slot:e,slice:t}){const n=e.padUntilAtLeast(32).toHex(),r=s.get(n)||i.B.zero().padUntilAtLeast(32);if(!t)return r;const{offset:o,length:a}=t,l=32-Number(o)-Number(a),c=l+Number(a);return i.B.fromBytes(r.slice(l,c))}},calldata:{get length(){return Promise.resolve(BigInt(r.length))},async read({slice:e}){const{offset:t,length:n}=e,s=Number(t),o=s+Number(n);if(o>r.length){const e=new Uint8Array(Number(n)),t=Math.max(0,r.length-s);return t>0&&s<r.length&&e.set(r.slice(s,s+t),0),i.B.fromBytes(e)}return i.B.fromBytes(r.slice(s,o))}},returndata:{get length(){return Promise.resolve(BigInt(o.length))},async read({slice:e}){const{offset:t,length:n}=e,s=Number(t),r=s+Number(n);if(r>o.length){const e=new Uint8Array(Number(n)),t=Math.max(0,o.length-s);return t>0&&s<o.length&&e.set(o.slice(s,s+t),0),i.B.fromBytes(e)}return i.B.fromBytes(o.slice(s,r))}},code:{get length(){return Promise.resolve(BigInt(a.length))},async read({slice:e}){const{offset:t,length:n}=e,s=Number(t),r=s+Number(n);if(r>a.length){const e=new Uint8Array(Number(n)),t=Math.max(0,a.length-s);return t>0&&s<a.length&&e.set(a.slice(s,s+t),0),i.B.fromBytes(e)}return i.B.fromBytes(a.slice(s,r))}},transient:{async read({slot:e,slice:t}){const n=e.padUntilAtLeast(32).toHex(),s=l.get(n)||i.B.zero().padUntilAtLeast(32);if(!t)return s;const{offset:r,length:o}=t,a=32-Number(r)-Number(o),c=a+Number(o);return i.B.fromBytes(s.slice(a,c))}}}}(l),t=await(0,i.D)(o,{state:e}),n=await t.view(e),s=new Map;for(const i of n.regions)try{const e=await n.read(i);s.set(i,e)}catch{}const r={};for(const i of n.regions)"name"in i&&"string"==typeof i.name&&(r[i.name]||(r[i.name]=[]),r[i.name].push(i));const a={};for(const[i,o]of Object.entries(r))o.length>0&&(a[i]=o[o.length-1]);p({regions:[...n.regions],values:s,namedRegions:r,lookup:a})}catch(e){g(e instanceof Error?e:new Error(String(e))),p(null)}finally{h(!1)}}),[o,l]),j=(0,r.useCallback)((()=>{a(t),c(n),p(null),g(null)}),[t,n]);return(0,r.useEffect)((()=>{s&&f()}),[s,f]),{pointer:o,stateSpec:l,isResolving:d,result:u,error:m,setPointer:a,setStateSpec:c,updateStateSpec:x,resolve:f,reset:j}}const l=(0,r.createContext)(void 0);function c(){const e=(0,r.useContext)(l);if(void 0===e)throw new Error("usePointerResolverContext must be used within a PointerResolverProvider");return e}function d({children:e,...t}){const n=a(t);return(0,s.jsx)(l.Provider,{value:n,children:e})}function h(e){return"location"in e&&"string"==typeof e.location?e.location:"unknown"}function u(e){const t=[h(e)];if("slot"in e&&void 0!==e.slot){const n=o(e.slot);t.push(`slot: ${n}`)}if("offset"in e&&void 0!==e.offset){const n=o(e.offset);t.push(`offset: ${n}`)}if("length"in e&&void 0!==e.length){const n=o(e.length);t.push(`length: ${n}`)}return t.join(", ")}function p({regions:e,selectedName:t,onRegionClick:n}){const r=Object.keys(e).sort();return 0===r.length?(0,s.jsx)("div",{className:"region-map region-map-empty",children:(0,s.jsx)("span",{className:"region-map-empty-text",children:"No named regions"})}):(0,s.jsx)("div",{className:"region-map",children:r.map((r=>{const i=e[r],o=r===t;return(0,s.jsxs)("div",{className:"region-map-entry "+(o?"selected":""),children:[(0,s.jsx)("div",{className:"region-map-name",children:r}),(0,s.jsx)("div",{className:"region-map-regions",children:i.map(((e,t)=>{const i=h(e),o=function(e){return{storage:"region-storage",memory:"region-memory",stack:"region-stack",calldata:"region-calldata",returndata:"region-returndata",code:"region-code",transient:"region-transient"}[e]||"region-unknown"}(i);return(0,s.jsxs)("div",{className:`region-map-region ${o}`,onClick:()=>n?.(r,e),role:"button",tabIndex:0,onKeyDown:t=>{"Enter"!==t.key&&" "!==t.key||n?.(r,e)},children:[(0,s.jsx)("span",{className:"region-location-badge",children:i}),(0,s.jsx)("span",{className:"region-details",children:u(e)})]},t)}))})]},r)}))})}function m({region:e,value:t,showFullValues:n,index:r}){const i=function(e){return"location"in e&&"string"==typeof e.location?e.location:"unknown"}(e),a=function(e){return{storage:"region-storage",memory:"region-memory",stack:"region-stack",calldata:"region-calldata",returndata:"region-returndata",code:"region-code",transient:"region-transient"}[e]||"region-unknown"}(i),l="name"in e?e.name:void 0,c=t?n?o(t):function(e,t=10){const n=e.toHex();if(n.length<=t+2)return n;const s=Math.floor((t-2)/2),r=t-2-s;return`${n.slice(0,2+s)}...${n.slice(-r)}`}(t,16):"(no value)";return(0,s.jsxs)("div",{className:`region-output-item ${a}`,children:[(0,s.jsxs)("div",{className:"region-output-header",children:[(0,s.jsxs)("span",{className:"region-output-index",children:["#",r+1]}),(0,s.jsx)("span",{className:"region-location-badge",children:i}),l&&(0,s.jsx)("span",{className:"region-name-badge",children:l})]}),(0,s.jsxs)("div",{className:"region-output-details",children:["slot"in e&&void 0!==e.slot&&(0,s.jsxs)("div",{className:"region-output-field",children:[(0,s.jsx)("span",{className:"region-field-label",children:"slot:"}),(0,s.jsx)("code",{className:"region-field-value",children:o(e.slot)})]}),"offset"in e&&void 0!==e.offset&&(0,s.jsxs)("div",{className:"region-output-field",children:[(0,s.jsx)("span",{className:"region-field-label",children:"offset:"}),(0,s.jsx)("code",{className:"region-field-value",children:o(e.offset)})]}),"length"in e&&void 0!==e.length&&(0,s.jsxs)("div",{className:"region-output-field",children:[(0,s.jsx)("span",{className:"region-field-label",children:"length:"}),(0,s.jsx)("code",{className:"region-field-value",children:o(e.length)})]})]}),(0,s.jsxs)("div",{className:"region-output-value",children:[(0,s.jsx)("span",{className:"region-value-label",children:"value:"}),(0,s.jsx)("code",{className:"region-value-data "+(t?"":"no-value"),title:t?o(t):void 0,children:c})]})]})}function g({regions:e,values:t,showFullValues:n=!1}){return 0===e.length?(0,s.jsx)("div",{className:"region-output region-output-empty",children:(0,s.jsx)("span",{className:"region-output-empty-text",children:"No regions resolved"})}):(0,s.jsxs)("div",{className:"region-output",children:[(0,s.jsxs)("div",{className:"region-output-summary",children:[e.length," region",1!==e.length?"s":""," resolved"]}),(0,s.jsx)("div",{className:"region-output-list",children:e.map(((e,r)=>(0,s.jsx)(m,{region:e,value:t.get(e),showFullValues:n,index:r},r)))})]})}function x({storage:e,onChange:t}){const n=Object.entries(e);return(0,s.jsxs)("div",{className:"state-editor-section",children:[(0,s.jsxs)("div",{className:"state-editor-header",children:[(0,s.jsx)("span",{children:"Storage"}),(0,s.jsx)("button",{className:"state-editor-add-btn",onClick:()=>{const s=`0x${n.length.toString(16).padStart(2,"0")}`;t({...e,[s]:"0x00"})},type:"button",children:"+ Add"})]}),0===n.length?(0,s.jsx)("div",{className:"state-editor-empty",children:"No storage entries"}):(0,s.jsx)("div",{className:"state-editor-entries",children:n.map((([n,r])=>(0,s.jsxs)("div",{className:"state-editor-entry",children:[(0,s.jsx)("input",{className:"state-editor-input slot",value:n,onChange:s=>((n,s)=>{const r={...e},i=r[n];delete r[n],s&&(r[s]=i),t(r)})(n,s.target.value),placeholder:"slot (hex)"}),(0,s.jsx)("span",{className:"state-editor-arrow",children:"="}),(0,s.jsx)("input",{className:"state-editor-input value",value:r,onChange:s=>((n,s)=>{t({...e,[n]:s})})(n,s.target.value),placeholder:"value (hex)"}),(0,s.jsx)("button",{className:"state-editor-remove-btn",onClick:()=>(n=>{const s={...e};delete s[n],t(s)})(n),type:"button","aria-label":"Remove entry",children:"\xd7"})]},n)))})]})}function f({stack:e,onChange:t}){return(0,s.jsxs)("div",{className:"state-editor-section",children:[(0,s.jsxs)("div",{className:"state-editor-header",children:[(0,s.jsx)("span",{children:"Stack (top first)"}),(0,s.jsx)("button",{className:"state-editor-add-btn",onClick:()=>{t([...e,"0x00"])},type:"button",children:"+ Add"})]}),0===e.length?(0,s.jsx)("div",{className:"state-editor-empty",children:"Empty stack"}):(0,s.jsx)("div",{className:"state-editor-entries",children:e.map(((n,r)=>(0,s.jsxs)("div",{className:"state-editor-entry",children:[(0,s.jsxs)("span",{className:"state-editor-index",children:["[",r,"]"]}),(0,s.jsx)("input",{className:"state-editor-input value",value:"bigint"==typeof n?`0x${n.toString(16)}`:n,onChange:n=>((n,s)=>{const r=[...e];r[n]=s,t(r)})(r,n.target.value),placeholder:"value (hex)"}),(0,s.jsx)("button",{className:"state-editor-remove-btn",onClick:()=>(n=>{const s=[...e];s.splice(n,1),t(s)})(r),type:"button","aria-label":"Remove entry",children:"\xd7"})]},r)))})]})}function j({memory:e,onChange:t}){return(0,s.jsxs)("div",{className:"state-editor-section",children:[(0,s.jsx)("div",{className:"state-editor-header",children:(0,s.jsx)("span",{children:"Memory"})}),(0,s.jsx)("textarea",{className:"state-editor-textarea",value:e||"",onChange:e=>t(e.target.value),placeholder:"0x... (hex bytes)",rows:3})]})}function v({showPointerInput:e=!0,showStateEditor:t=!0,showControls:n=!0,showFullValues:i=!1}){const{pointer:o,stateSpec:a,isResolving:l,result:d,error:h,setPointer:u,updateStateSpec:m,resolve:v}=c(),[y,b]=(0,r.useState)(o?JSON.stringify(o,null,2):""),[w,N]=(0,r.useState)(null),k=(0,r.useCallback)((e=>{if(b(e),N(null),e.trim())try{const t=JSON.parse(e);u(t)}catch(t){N(t instanceof Error?t.message:"Invalid JSON")}else u(null)}),[u]);return(0,s.jsxs)("div",{className:"resolution-visualizer",children:[(0,s.jsxs)("div",{className:"resolution-visualizer-inputs",children:[e&&(0,s.jsxs)("div",{className:"resolution-visualizer-panel pointer-panel",children:[(0,s.jsx)("h4",{className:"panel-title",children:"Pointer Definition"}),(0,s.jsx)("textarea",{className:"pointer-input",value:y,onChange:e=>k(e.target.value),placeholder:'{"location": "storage", "slot": 0}',rows:10}),w&&(0,s.jsx)("div",{className:"pointer-parse-error",children:w})]}),t&&(0,s.jsxs)("div",{className:"resolution-visualizer-panel state-panel",children:[(0,s.jsx)("h4",{className:"panel-title",children:"Machine State"}),(0,s.jsxs)("div",{className:"state-editor",children:[(0,s.jsx)(x,{storage:a.storage||{},onChange:e=>m("storage",e)}),(0,s.jsx)(f,{stack:a.stack||[],onChange:e=>m("stack",e)}),(0,s.jsx)(j,{memory:a.memory,onChange:e=>m("memory",e)})]})]})]}),n&&(0,s.jsx)("div",{className:"resolution-visualizer-controls",children:(0,s.jsx)("button",{className:"resolve-button",onClick:()=>v(),disabled:l||!o,type:"button",children:l?"Resolving...":"Resolve Pointer"})}),(0,s.jsxs)("div",{className:"resolution-visualizer-output",children:[h&&(0,s.jsxs)("div",{className:"resolution-error",children:[(0,s.jsx)("h4",{children:"Resolution Error"}),(0,s.jsx)("pre",{children:h.message})]}),d&&(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)("div",{className:"resolution-visualizer-panel regions-panel",children:[(0,s.jsx)("h4",{className:"panel-title",children:"Named Regions"}),(0,s.jsx)(p,{regions:d.namedRegions})]}),(0,s.jsxs)("div",{className:"resolution-visualizer-panel output-panel",children:[(0,s.jsx)("h4",{className:"panel-title",children:"Resolved Output"}),(0,s.jsx)(g,{regions:d.regions,values:d.values,showFullValues:i})]})]})]})]})}var y=n(49499);const b=(0,r.createContext)(null);function w({children:e,initialPointer:t=null,initialState:n={},initialOpen:i=!1}){const[o,a]=(0,r.useState)(t),[l,c]=(0,r.useState)(n),[d,h]=(0,r.useState)(i),u=(0,r.useCallback)((()=>h(!0)),[]),p=(0,r.useCallback)((()=>h(!1)),[]),m=(0,r.useCallback)((()=>h((e=>!e))),[]),g=(0,r.useCallback)(((e,t={})=>{a(e),c(t),h(!0)}),[]);return(0,s.jsx)(b.Provider,{value:{pointer:o,stateSpec:l,isOpen:d,loadExample:g,openDrawer:u,closeDrawer:p,toggleDrawer:m,setPointer:a,setStateSpec:c},children:e})}function N(){return(0,s.jsx)(y.A,{fallback:null,children:()=>(0,s.jsx)(k,{})})}function k(){const{pointer:e,stateSpec:t,isOpen:n,toggleDrawer:i,closeDrawer:o}=function(){const e=(0,r.useContext)(b);if(!e)throw new Error("usePointerPlayground must be used within a PointerPlaygroundProvider");return e}(),[a,l]=(0,r.useState)((()=>Math.round(.4*window.innerHeight))),[c,h]=(0,r.useState)(!1),u=(0,r.useRef)(null),[p,m]=(0,r.useState)(0);(0,r.useEffect)((()=>{m((e=>e+1))}),[e,t]);const g=(0,r.useCallback)((e=>{e.preventDefault(),h(!0)}),[]);return(0,r.useEffect)((()=>{if(!c)return;const e=e=>{const t="touches"in e?e.touches[0].clientY:e.clientY,n=window.innerHeight,s=n-t,r=.85*n;l(Math.max(200,Math.min(s,r)))},t=()=>{h(!1)};return document.addEventListener("mousemove",e),document.addEventListener("mouseup",t),document.addEventListener("touchmove",e),document.addEventListener("touchend",t),()=>{document.removeEventListener("mousemove",e),document.removeEventListener("mouseup",t),document.removeEventListener("touchmove",e),document.removeEventListener("touchend",t)}}),[c]),(0,r.useEffect)((()=>{const e=e=>{"Escape"===e.key&&n&&o()};return document.addEventListener("keydown",e),()=>document.removeEventListener("keydown",e)}),[n,o]),n?(0,s.jsxs)("div",{ref:u,className:"pointer-drawer open "+(c?"resizing":""),style:{"--drawer-height":`${a}px`},children:[(0,s.jsx)("div",{className:"pointer-drawer-resize-handle",onMouseDown:g,onTouchStart:g,children:(0,s.jsx)("div",{className:"resize-handle-bar"})}),(0,s.jsxs)(d,{initialPointer:e,initialStateSpec:t,autoResolve:!0,children:[(0,s.jsx)(C,{toggleDrawer:i,closeDrawer:o}),(0,s.jsx)("div",{className:"pointer-drawer-content",children:(0,s.jsx)(v,{showPointerInput:!0,showStateEditor:!0,showControls:!1,showFullValues:!1})})]},p)]}):(0,s.jsx)("div",{ref:u,className:"pointer-drawer closed",style:{"--drawer-height":`${a}px`},children:(0,s.jsx)("div",{className:"pointer-drawer-header",children:(0,s.jsxs)("button",{className:"pointer-drawer-toggle",onClick:i,type:"button","aria-expanded":!1,"aria-label":"Open pointer playground",children:[(0,s.jsx)("span",{className:"toggle-icon",children:"\u25b2"}),(0,s.jsx)("span",{className:"toggle-text",children:"Pointer Playground"})]})})})}function C({toggleDrawer:e,closeDrawer:t}){const{pointer:n,isResolving:r,resolve:i}=c();return(0,s.jsxs)("div",{className:"pointer-drawer-header",children:[(0,s.jsxs)("button",{className:"pointer-drawer-toggle",onClick:e,type:"button","aria-expanded":!0,"aria-label":"Close pointer playground",children:[(0,s.jsx)("span",{className:"toggle-icon",children:"\u25bc"}),(0,s.jsx)("span",{className:"toggle-text",children:"Pointer Playground"})]}),(0,s.jsxs)("div",{className:"pointer-drawer-header-actions",children:[(0,s.jsx)("button",{className:"resolve-button",onClick:()=>i(),disabled:r||!n,type:"button",children:r?"Resolving...":"Resolve Pointer"}),(0,s.jsx)("button",{className:"pointer-drawer-close",onClick:t,type:"button","aria-label":"Close",children:"\u2715"})]})]})}var S=n(54034),P=n.n(S);function E({pointer:e,state:t={},title:n,description:r,showCode:i=!0}){const o=JSON.stringify(e,null,2);return(0,s.jsxs)("div",{className:"pointer-example",children:[n&&(0,s.jsx)("div",{className:"pointer-example-title",children:n}),r&&(0,s.jsx)("div",{className:"pointer-example-description",children:r}),(0,s.jsxs)("div",{className:"pointer-example-content",children:[i&&(0,s.jsx)(P(),{language:"json",className:"pointer-example-code",children:o}),(0,s.jsx)(y.A,{fallback:null,children:()=>(0,s.jsx)(U,{pointer:e,state:t,showCode:i})})]})]})}function U({pointer:e,state:t,showCode:n}){const i=(0,r.useContext)(b);if(!i)return null;return(0,s.jsxs)("button",{className:"pointer-example-try-btn "+(n?"":"standalone"),onClick:()=>{i.loadExample(e,t)},type:"button",title:"Load this example in the Pointer Playground",children:[(0,s.jsx)("span",{className:"try-btn-icon",children:"\u25b6"}),(0,s.jsx)("span",{className:"try-btn-text",children:"Try it"})]})}function $({children:e,initialPointer:t,initialState:n}){return(0,s.jsx)(y.A,{fallback:(0,s.jsx)("div",{className:"pointer-playground-fallback",children:e}),children:()=>(0,s.jsxs)(w,{initialPointer:t??null,initialState:n,initialOpen:!1,children:[(0,s.jsx)("div",{className:"pointer-playground-content",children:e}),(0,s.jsx)(N,{})]})})}},48802(e,t,n){n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"pointers/collections","title":"Collections","description":"While regions describe single contiguous byte ranges, collections","source":"@site/docs/pointers/collections.mdx","sourceDirName":"pointers","slug":"/pointers/collections","permalink":"/format/pr-preview/pr-168/docs/pointers/collections","draft":false,"unlisted":false,"editUrl":"https://github.com/ethdebug/format/tree/main/packages/web/docs/pointers/collections.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"Expressions","permalink":"/format/pr-preview/pr-168/docs/pointers/expressions"},"next":{"title":"Programs","permalink":"/format/pr-preview/pr-168/docs/programs/"}}');var r=n(31085),i=n(71184),o=n(38532);const a={sidebar_position:4},l="Collections",c={},d=[{value:"Why collections?",id:"why-collections",level:2},{value:"Group",id:"group",level:2},{value:"List",id:"list",level:2},{value:"List with dynamic count",id:"list-with-dynamic-count",level:3},{value:"List properties",id:"list-properties",level:3},{value:"Conditional",id:"conditional",level:2},{value:"Conditional properties",id:"conditional-properties",level:3},{value:"Scope",id:"scope",level:2},{value:"Scope properties",id:"scope-properties",level:3},{value:"Reference and Templates",id:"reference-and-templates",level:2},{value:"Template definition",id:"template-definition",level:3},{value:"Reference properties",id:"reference-properties",level:3},{value:"Nesting collections",id:"nesting-collections",level:2},{value:"Named regions in collections",id:"named-regions-in-collections",level:2},{value:"Learn more",id:"learn-more",level:2}];function h(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"collections",children:"Collections"})}),"\n",(0,r.jsxs)(o.rM,{children:[(0,r.jsxs)(t.p,{children:["While ",(0,r.jsx)(t.a,{href:"./regions",children:"regions"})," describe single contiguous byte ranges, ",(0,r.jsx)(t.strong,{children:"collections"}),"\naggregate multiple pointers together. Collections handle cases where data\nstructures span multiple locations or have dynamic configurations."]}),(0,r.jsx)(t.h2,{id:"why-collections",children:"Why collections?"}),(0,r.jsx)(t.p,{children:"Consider a Solidity struct with multiple fields, or a dynamic array whose\nlength isn't known at compile time. These require more than pointing to a\nsingle memory location\u2014they need to describe relationships between multiple\npointers or generate pointers based on runtime values."}),(0,r.jsx)(t.p,{children:"Collections provide six patterns for composing pointers:"}),(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Collection"}),(0,r.jsx)(t.th,{children:"Purpose"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"group"})}),(0,r.jsx)(t.td,{children:"Combine multiple pointers into one"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"list"})}),(0,r.jsx)(t.td,{children:"Generate pointers for indexed sequences"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"conditional"})}),(0,r.jsx)(t.td,{children:"Choose between pointers based on a condition"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"scope"})}),(0,r.jsx)(t.td,{children:"Define variables for use in nested pointers"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"reference"})}),(0,r.jsx)(t.td,{children:"Invoke reusable pointer templates"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"templates"})}),(0,r.jsx)(t.td,{children:"Define inline templates for local reuse"})]})]})]}),(0,r.jsxs)(t.p,{children:["Click ",(0,r.jsx)(t.strong,{children:'"\u25b6 Try it"'})," on any example to load it into the Pointer Playground\ndrawer at the bottom of the screen."]}),(0,r.jsx)(t.h2,{id:"group",children:"Group"}),(0,r.jsxs)(t.p,{children:["A ",(0,r.jsx)(t.strong,{children:"group"})," combines multiple pointers into a single composite pointer. Each\npointer in the group can have a name for identification."]}),(0,r.jsx)(o.C,{title:"Struct with two fields",pointer:{group:[{name:"len",location:"storage",slot:0},{name:"data",location:"storage",slot:1}]},state:{storage:{"0x00":"0x0000000000000000000000000000000000000000000000000000000000000005","0x01":"0x48656c6c6f000000000000000000000000000000000000000000000000000000"}}}),(0,r.jsx)(t.p,{children:"Groups are useful for structs and other compound data types where multiple\nfields need to be accessed together."}),(0,r.jsx)(t.h2,{id:"list",children:"List"}),(0,r.jsxs)(t.p,{children:["A ",(0,r.jsx)(t.strong,{children:"list"})," generates a sequence of pointers based on a count expression. This\nhandles dynamic arrays and other indexed collections."]}),(0,r.jsx)(o.C,{title:"Dynamic array (3 elements)",pointer:{list:{count:3,each:"i",is:{name:"element",location:"storage",slot:{$sum:[10,"i"]}}}},state:{storage:{"0x0a":"0x0000000000000000000000000000000000000000000000000000000000000001","0x0b":"0x0000000000000000000000000000000000000000000000000000000000000002","0x0c":"0x0000000000000000000000000000000000000000000000000000000000000003"}}}),(0,r.jsxs)(t.p,{children:["The list evaluates ",(0,r.jsx)(t.code,{children:"count"})," to determine how many pointers to generate, then\nfor each index (bound to the variable named by ",(0,r.jsx)(t.code,{children:"each"}),"), it evaluates the ",(0,r.jsx)(t.code,{children:"is"}),"\npointer template."]}),(0,r.jsx)(t.h3,{id:"list-with-dynamic-count",children:"List with dynamic count"}),(0,r.jsx)(t.p,{children:"When the count comes from storage:"}),(0,r.jsx)(o.C,{title:"Array with length from storage",pointer:{group:[{name:"arrayLength",location:"storage",slot:0},{list:{count:{$read:"arrayLength"},each:"i",is:{name:"element",location:"storage",slot:{$sum:[1,"i"]}}}}]},state:{storage:{"0x00":"0x0000000000000000000000000000000000000000000000000000000000000002","0x01":"0x000000000000000000000000000000000000000000000000000000000000000a","0x02":"0x0000000000000000000000000000000000000000000000000000000000000014"}}}),(0,r.jsx)(t.h3,{id:"list-properties",children:"List properties"}),(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Property"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"count"})}),(0,r.jsx)(t.td,{children:"Expression evaluating to the number of items"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"each"})}),(0,r.jsx)(t.td,{children:"Variable name for the current index (starting at 0)"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"is"})}),(0,r.jsx)(t.td,{children:"Pointer template evaluated for each index"})]})]})]}),(0,r.jsx)(t.h2,{id:"conditional",children:"Conditional"}),(0,r.jsxs)(t.p,{children:["A ",(0,r.jsx)(t.strong,{children:"conditional"})," selects between pointers based on whether an expression\nevaluates to a non-zero value."]}),(0,r.jsx)(o.C,{title:"Conditional pointer",pointer:{group:[{name:"flag",location:"storage",slot:0},{if:{$read:"flag"},then:{name:"whenTrue",location:"storage",slot:1},else:{name:"whenFalse",location:"storage",slot:2}}]},state:{storage:{"0x00":"0x0000000000000000000000000000000000000000000000000000000000000001","0x01":"0x000000000000000000000000000000000000000000000000000000000000002a","0x02":"0x00000000000000000000000000000000000000000000000000000000000000ff"}},description:"Click 'Try it' and change slot 0 to 0x00 to see the 'else' branch"}),(0,r.jsx)(t.h3,{id:"conditional-properties",children:"Conditional properties"}),(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Property"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"if"})}),(0,r.jsx)(t.td,{children:"Expression to evaluate (non-zero = true)"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"then"})}),(0,r.jsx)(t.td,{children:"Pointer to use when condition is true"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"else"})}),(0,r.jsx)(t.td,{children:"Optional pointer when condition is false"})]})]})]}),(0,r.jsx)(t.h2,{id:"scope",children:"Scope"}),(0,r.jsxs)(t.p,{children:["A ",(0,r.jsx)(t.strong,{children:"scope"})," defines variables that can be used in a nested pointer. Variables\nare evaluated in order, so later variables can reference earlier ones."]}),(0,r.jsx)(o.C,{title:"Scope with computed slot",pointer:{define:{baseSlot:3,offset:2},in:{name:"result",location:"storage",slot:{$sum:["baseSlot","offset"]}}},state:{storage:{"0x05":"0x0000000000000000000000000000000000000000000000000000000000000064"}},description:"Computes slot 3 + 2 = 5"}),(0,r.jsxs)(t.p,{children:["Scopes help break complex pointer definitions into readable steps. For examples\ncombining scopes with keccak256 for storage slot computation, see the\n",(0,r.jsx)(t.a,{href:"./expressions#computing-storage-slots-with-keccak256",children:"expressions documentation"}),"."]}),(0,r.jsx)(t.h3,{id:"scope-properties",children:"Scope properties"}),(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Property"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"define"})}),(0,r.jsx)(t.td,{children:"Object mapping variable names to expressions"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"in"})}),(0,r.jsx)(t.td,{children:"Pointer where defined variables are available"})]})]})]}),(0,r.jsx)(t.h2,{id:"reference-and-templates",children:"Reference and Templates"}),(0,r.jsxs)(t.p,{children:["A ",(0,r.jsx)(t.strong,{children:"reference"})," invokes a named pointer template, while ",(0,r.jsx)(t.strong,{children:"templates"})," defines\nthem inline. These work together for reusable pointer patterns."]}),(0,r.jsx)(o.C,{title:"Template with reference",pointer:{templates:{"read-slot":{expect:["n"],for:{name:"slot",location:"storage",slot:"n"}}},in:{group:[{define:{n:0},in:{template:"read-slot"}},{define:{n:1},in:{template:"read-slot"}}]}},state:{storage:{"0x00":"0x000000000000000000000000000000000000000000000000000000000000000a","0x01":"0x0000000000000000000000000000000000000000000000000000000000000014"}},description:"Defines a template and uses it twice"}),(0,r.jsx)(t.h3,{id:"template-definition",children:"Template definition"}),(0,r.jsxs)(t.p,{children:["Each template in the ",(0,r.jsx)(t.code,{children:"templates"})," object has:"]}),(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Property"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"expect"})}),(0,r.jsx)(t.td,{children:"Array of required variable names"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"for"})}),(0,r.jsx)(t.td,{children:"The pointer template body"})]})]})]}),(0,r.jsx)(t.h3,{id:"reference-properties",children:"Reference properties"}),(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Property"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"template"})}),(0,r.jsx)(t.td,{children:"Name of the template to invoke"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"yields"})}),(0,r.jsx)(t.td,{children:"Optional object mapping template region names to new names"})]})]})]}),(0,r.jsx)(t.h2,{id:"nesting-collections",children:"Nesting collections"}),(0,r.jsx)(t.p,{children:"Collections can be nested to build complex pointer structures. A group might\ncontain lists, conditionals might wrap groups, and scopes can define variables\nused throughout nested collections."}),(0,r.jsx)(o.C,{title:"Nested: scope + conditional + list",pointer:{group:[{name:"lengthSlot",location:"storage",slot:0},{define:{len:{$read:"lengthSlot"}},in:{if:"len",then:{list:{count:"len",each:"i",is:{name:"item",location:"storage",slot:{$sum:[1,"i"]}}}}}}]},state:{storage:{"0x00":"0x0000000000000000000000000000000000000000000000000000000000000003","0x01":"0x0000000000000000000000000000000000000000000000000000000000000001","0x02":"0x0000000000000000000000000000000000000000000000000000000000000002","0x03":"0x0000000000000000000000000000000000000000000000000000000000000003"}},description:"Reads length, checks if non-zero, then generates that many pointers"}),(0,r.jsx)(t.h2,{id:"named-regions-in-collections",children:"Named regions in collections"}),(0,r.jsxs)(t.p,{children:["Pointers within collections can include a ",(0,r.jsx)(t.code,{children:"name"})," property. Named regions are\ntracked during resolution and can be referenced using the ",(0,r.jsx)(t.code,{children:".slot"}),", ",(0,r.jsx)(t.code,{children:".offset"}),",\nand ",(0,r.jsx)(t.code,{children:".length"})," syntax in expressions."]}),(0,r.jsx)(o.C,{title:"Region reference with .slot",pointer:{group:[{name:"header",location:"storage",slot:0},{name:"body",location:"storage",slot:{$sum:[{".slot":"header"},1]}}]},state:{storage:{"0x00":"0x0000000000000000000000000000000000000000000000000000000000000010","0x01":"0x0000000000000000000000000000000000000000000000000000000000000020"}},description:"Second region's slot is computed from first region's slot (0 + 1 = 1)"}),(0,r.jsx)(t.h2,{id:"learn-more",children:"Learn more"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"./regions",children:"Regions"})," for simple pointer definitions"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"./expressions",children:"Expressions"})," for dynamic value computation"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"/spec/pointer/collection",children:"Pointer specification"})," for formal definitions"]}),"\n"]})]})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},70396(e,t,n){var s;n.d(t,{B:()=>a,D:()=>m}),function(e){e.dereferencePointer=e=>({kind:"dereference-pointer",pointer:e}),e.saveRegions=e=>({kind:"save-regions",regions:e}),e.saveVariables=e=>({kind:"save-variables",variables:e}),e.pushRegionRenames=e=>({kind:"push-region-renames",mapping:e}),e.popRegionRenames=()=>({kind:"pop-region-renames"}),e.pushTemplates=e=>({kind:"push-templates",templates:e}),e.popTemplates=()=>({kind:"pop-templates"})}(s||(s={}));var r=n(31917),i=n(43568);const o=Symbol.for("nodejs.util.inspect.custom");class a extends Uint8Array{static zero(){return new a([])}static fromUint(e){if(0n===e)return this.zero();const t=Math.ceil(Number(e.toString(2).length)/8),n=new Uint8Array(t);for(let s=t-1;s>=0;s--)n[s]=Number(0xffn&e),e>>=8n;return new a(n)}static fromNumber(e){const t=Math.ceil(Math.log2(e+1)/8),n=new Uint8Array(t);for(let s=t-1;s>=0;s--)n[s]=255&e,e>>=8;return new a(n)}static fromHex(e){if(!e.startsWith("0x"))throw new Error('Invalid hex string format. Expected "0x" prefix.');const t=new Uint8Array((e.length-2)/2+.5);for(let n=2;n<e.length;n+=2)t[n/2-1]=parseInt(e.slice(n,n+2),16);return new a(t)}static fromBytes(e){return new a(e)}asUint(){const e=8n;let t=0n;for(const n of this.values()){t=(t<<e)+BigInt(n)}return t}toHex(){return`0x${(0,i.nj)(this)}`}padUntilAtLeast(e){if(this.length>=e)return this;const t=new Uint8Array(e);return t.set(this,e-this.length),a.fromBytes(t)}resizeTo(e){if(this.length===e)return this;const t=new Uint8Array(e);return this.length<e?t.set(this,e-this.length):t.set(this.slice(this.length-e)),a.fromBytes(t)}concat(...e){const t=[this,...e].map((e=>e.toHex().slice(2))).reduce(((e,t)=>`${e}${t}`),"0x");return a.fromHex(t)}inspect(e,t,n){return`Data[${t.stylize(this.toHex(),"number")}]`}[o](e,t,n){return this.inspect(e,t,n)}}async function l(e,t){const{location:n}=e,{state:s}=t;switch(n){case"stack":{const{slot:t,offset:n=0n,length:r=32n}=c(["slot","offset","length"],e);return await s.stack.peek({depth:t,slice:{offset:n,length:r}})}case"memory":{const{offset:t,length:n}=c(["offset","length"],e);return await s.memory.read({slice:{offset:t,length:n}})}case"storage":{const{slot:t}=e,{offset:n=0n,length:r=32n}=c(["offset","length"],e);return await s.storage.read({slot:t,slice:{offset:n,length:r}})}case"calldata":{const{offset:t,length:n}=c(["offset","length"],e);return await s.calldata.read({slice:{offset:t,length:n}})}case"returndata":{const{offset:t,length:n}=c(["offset","length"],e);return await s.returndata.read({slice:{offset:t,length:n}})}case"transient":{const{slot:t}=e,{offset:n=0n,length:r=32n}=c(["offset","length"],e);return await s.transient.read({slot:t,slice:{offset:n,length:r}})}case"code":{const{offset:t,length:n}=c(["offset","length"],e);return await s.code.read({slice:{offset:t,length:n}})}}}function c(e,t){const n={};for(const s of e){const e=t[s];void 0!==e&&(n[s]=e.asUint())}return n}var d=n(33688);async function h(e,t){if(r.gm.Expression.isLiteral(e))return async function(e){switch(typeof e){case"string":return a.fromHex(e);case"number":return a.fromNumber(e)}}(e);if(r.gm.Expression.isConstant(e))return async function(e){if("$wordsize"===e)return a.fromHex("0x20")}(e);if(r.gm.Expression.isVariable(e))return async function(e,{variables:t}){const n=t[e];if(void 0===n)throw new Error(`Unknown variable with identifier ${e}`);return n}(e,t);if(r.gm.Expression.isArithmetic(e)){if(r.gm.Expression.Arithmetic.isSum(e))return async function(e,t){const n=await Promise.all(e.$sum.map((async e=>await h(e,t)))),s=n.reduce(((e,{length:t})=>t>e?t:e),0);return a.fromUint(n.reduce(((e,t)=>e+t.asUint()),0n)).padUntilAtLeast(s)}(e,t);if(r.gm.Expression.Arithmetic.isDifference(e))return async function(e,t){const[n,s]=await Promise.all(e.$difference.map((async e=>await h(e,t)))),r=n.length>s.length?n.length:s.length,i=n.asUint()>s.asUint()?a.fromUint(n.asUint()-s.asUint()):a.fromNumber(0);return i.padUntilAtLeast(r)}(e,t);if(r.gm.Expression.Arithmetic.isProduct(e))return async function(e,t){const n=await Promise.all(e.$product.map((async e=>await h(e,t)))),s=n.reduce(((e,{length:t})=>t>e?t:e),0);return a.fromUint(n.reduce(((e,t)=>e*t.asUint()),1n)).padUntilAtLeast(s)}(e,t);if(r.gm.Expression.Arithmetic.isQuotient(e))return async function(e,t){const[n,s]=await Promise.all(e.$quotient.map((async e=>await h(e,t)))),r=n.length>s.length?n.length:s.length;return a.fromUint(n.asUint()/s.asUint()).padUntilAtLeast(r)}(e,t);if(r.gm.Expression.Arithmetic.isRemainder(e))return async function(e,t){const[n,s]=await Promise.all(e.$remainder.map((async e=>await h(e,t)))),r=n.length>s.length?n.length:s.length;return a.fromUint(n.asUint()%s.asUint()).padUntilAtLeast(r)}(e,t)}if(r.gm.Expression.isKeccak256(e))return async function(e,t){const n=await Promise.all(e.$keccak256.map((async e=>await h(e,t)))),s=a.zero().concat(...n);return a.fromBytes((0,d.So)(s))}(e,t);if(r.gm.Expression.isConcat(e))return async function(e,t){const n=await Promise.all(e.$concat.map((async e=>await h(e,t))));return a.zero().concat(...n)}(e,t);if(r.gm.Expression.isResize(e))return async function(e,t){const[[n,s]]=Object.entries(e),i=r.gm.Expression.Resize.isToNumber(e)?Number(n.match(/^\$sized([1-9]+[0-9]*)$/)[1]):32;return(await h(s,t)).resizeTo(i)}(e,t);if(r.gm.Expression.isLookup(e)){if(r.gm.Expression.Lookup.isOffset(e))return u(".offset",e,t);if(r.gm.Expression.Lookup.isLength(e))return u(".length",e,t);if(r.gm.Expression.Lookup.isSlot(e))return u(".slot",e,t)}if(r.gm.Expression.isRead(e))return async function(e,t){const{state:n,regions:s}=t,r=e.$read,i=s[r];if(!i)throw new Error(`Region not found: ${r}`);return await l(i,t)}(e,t);throw new Error(`Unexpected runtime failure to recognize kind of expression: ${JSON.stringify(e)}`)}async function u(e,t,n){const{regions:s}=n,i=t[e],o=s[i];if(!o)throw new Error(`Region not found: ${i}`);const a=r.gm.Expression.Lookup.propertyFrom(e),l=o[a];if(void 0===l)throw new Error(`Region named ${i} does not have ${a} needed by lookup`);return l}async function*p(e,t){if(r.gm.isRegion(e)){const n=e;return yield*async function*(e,{stackLengthChange:t,...n}){const i=await async function(e,t){const n={},s={},r=new Proxy({...e},{get(e,t){if(t in n)return n[t];throw new Error(`Property not evaluated yet: $this.${t.toString()}`)}}),i=["slot","offset","length"],o=i.filter((t=>t in e)).map((t=>[t,e[t]]));for(;o.length>0;){const[e,l]=o.shift();try{const s=await h(l,{...t,regions:{...t.regions,$this:r}});n[e]=s}catch(a){if(!(a instanceof Error&&a.message.startsWith("Property not evaluated yet: $this.")))throw a;{const t=s[e]||0;if(t>i.length-1)throw new Error(`Circular reference detected: $this.${e.toString()}`);s[e]=t+1,o.push([e,l])}}}return{...e,...n}}(function(e,t){if(r.gm.Region.isStack(e)){const n=0n===t?e.slot:t>0n?{$sum:[e.slot,`0x${t.toString(16)}`]}:{$difference:[e.slot,"0x"+-t.toString(16)]};return{...e,slot:n}}return e}(e,t),n);if(yield i,void 0!==e.name)return[s.saveRegions({[e.name]:i})];return[]}(n,t)}const n=e;if(r.gm.Collection.isGroup(n))return yield*async function*(e,t){const{group:n}=e;return n.map(s.dereferencePointer)}(n);if(r.gm.Collection.isList(n))return yield*async function*(e,t){const{list:n}=e,{count:r,each:i,is:o}=n,l=(await h(r,t)).asUint(),c=[];for(let d=0n;d<l;d++)c.push(s.saveVariables({[i]:a.fromUint(d)})),c.push(s.dereferencePointer(o));return c}(n,t);if(r.gm.Collection.isConditional(n))return yield*async function*(e,t){const{if:n,then:r,else:i}=e,o=(await h(n,t)).asUint();if(o)return[s.dereferencePointer(r)];return i?[s.dereferencePointer(i)]:[]}(n,t);if(r.gm.Collection.isScope(n))return yield*async function*(e,t){const{define:n,in:r}=e,i={...t.variables},o={};for(const[s,a]of Object.entries(n)){const e=await h(a,{...t,variables:i});i[s]=e,o[s]=e}return[s.saveVariables(o),s.dereferencePointer(r)]}(n,t);if(r.gm.Collection.isReference(n))return yield*async function*(e,t){const{template:n,yields:r}=e,{templates:i,variables:o}=t,a=i[n];if(!a)throw new Error(`Unknown pointer template named ${n}`);const{expect:l,for:c}=a,d=new Set(Object.keys(o)),h=l.filter((e=>!d.has(e)));if(h.length>0)throw new Error([`Invalid reference to template named ${n}; missing expected `,`variables with identifiers: ${h.join(", ")}. `,"Please ensure these variables are defined prior to this reference."].join(""));if(r&&Object.keys(r).length>0)return[s.pushRegionRenames(r),s.dereferencePointer(c),s.popRegionRenames()];return[s.dereferencePointer(c)]}(n,t);if(r.gm.Collection.isTemplates(n))return yield*async function*(e,t){const{templates:n,in:r}=e;return[s.pushTemplates(n),s.dereferencePointer(r),s.popTemplates()]}(n);throw console.error("%s",JSON.stringify(e,void 0,2)),new Error("Unexpected unknown kind of pointer")}async function m(e,t={}){const n=await async function({templates:e={},state:t}){const n=t?await t.stack.length:0n;return{templates:e,initialStackLength:n}}(t);return function(e){return{async view(t){const n=[];for await(const a of e(t))n.push(a);const s={},r={},i={writable:!1,enumerable:!1,configurable:!1},o=Object.create(Array.prototype,{length:{value:n.length,...i}});for(const[e,a]of n.entries())Object.defineProperty(o,e,{value:a,...i,enumerable:!0}),"string"==typeof a.name&&(a.name in s||(s[a.name]=[]),s[a.name].push(a),r[a.name]=a);for(const[e,a]of Object.entries(r))Object.defineProperty(o,e,{value:a,...i});return Object.defineProperties(o,{named:{value:e=>s[e]||[],...i},lookup:{value:{...r},...i}}),{regions:o,read:async e=>await l(e,{state:t})}}}}((t=>({async*[Symbol.asyncIterator](){yield*async function*(e,t){const n=await async function({templates:e,state:t,initialStackLength:n}){return{templates:e,state:t,stackLengthChange:await t.stack.length-n,regions:{},variables:{}}}(t),{regions:r,variables:i}=n,o=[],a=[],l=[s.dereferencePointer(e)];for(;l.length>0;){const e=l.pop();let t=[];switch(e.kind){case"dereference-pointer":{const s=a.reduce(((e,t)=>({...e,...t})),n.templates),r=p(e.pointer,{...n,templates:s});let i=await r.next();for(;!i.done;){let e=i.value;const t=o[o.length-1];if(t&&e.name){const n=t[e.name];n&&n!==e.name&&(e={...e,name:n})}yield e,i=await r.next()}t=i.value;break}case"save-regions":for(const[t,n]of Object.entries(e.regions))r[t]=n;break;case"save-variables":Object.assign(i,e.variables);break;case"push-region-renames":o.push(e.mapping);break;case"pop-region-renames":{const e=o.pop();if(e)for(const[t,n]of Object.entries(e))t in r&&n!==t&&(r[n]={...r[t],name:n});break}case"push-templates":a.push(e.templates);break;case"pop-templates":a.pop()}for(let n=t.length-1;n>=0;n--)l.push(t[n])}}(e,{...n,state:t})}})))}}}]);