"use strict";(globalThis.webpackChunk_ethdebug_format_web=globalThis.webpackChunk_ethdebug_format_web||[]).push([[2493],{9921(e,t,n){n.d(t,{Ir:()=>i,AI:()=>B,wE:()=>yo});var s={};n.r(s),n.d(s,{K$:()=>T});var o={};n.r(o),n.d(o,{combineDebugContexts:()=>N,combineSubInstructionContexts:()=>$,extractContexts:()=>D,extractSubInstructionContexts:()=>M,preserveDebug:()=>A,preserveSubInstructionDebug:()=>j});var i={};n.r(i),n.d(i,{ht:()=>s,bQ:()=>w,ZU:()=>v,Aq:()=>o,WT:()=>x});var r=n(31917);var a;!function(e){e.isBase=e=>{return"object"==typeof e&&!!e&&"id"in e&&"string"==typeof e.id&&"kind"in e&&"string"==typeof e.kind&&!!e.kind&&"loc"in e&&(null===e.loc||(t=e.loc,r.t8.isSourceRange({source:{id:"pending"},range:t})));var t},e.clone=function(t){const n={...t};for(const[s,o]of Object.entries(n))o&&"object"==typeof o&&(Array.isArray(o)?n[s]=o.map((t=>t&&"object"==typeof t&&"kind"in t?e.clone(t):t)):"kind"in o&&(n[s]=e.clone(o)));return n},e.update=function(e,t){return{...e,...t}}}(a||(a={}));var c;!function(e){e.isBase=e=>a.isBase(e)&&e.kind.startsWith("declaration")&&"name"in e&&"string"==typeof e.name,e.struct=function(e,t,n,s){return{id:e,kind:"declaration:struct",name:t,fields:n,loc:s??null}},e.isStruct=e=>"kind"in e&&"declaration:struct"===e.kind,e.field=function(e,t,n,s,o){return{id:e,kind:"declaration:field",name:t,type:n,initializer:s,loc:o??null}},e.isField=e=>"kind"in e&&"declaration:field"===e.kind,e.storage=function(e,t,n,s,o){return{id:e,kind:"declaration:storage",name:t,type:n,slot:s,loc:o??null}},e.isStorage=e=>"kind"in e&&"declaration:storage"===e.kind,e.variable=function(e,t,n,s,o){return{id:e,kind:"declaration:variable",name:t,type:n,initializer:s,loc:o??null}},e.isVariable=e=>"kind"in e&&"declaration:variable"===e.kind,e.function_=function(e,t,n,s,o,i){return{id:e,kind:"declaration:function",name:t,parameters:n,returnType:s,body:o,loc:i??null}},e.isFunction=e=>"kind"in e&&"declaration:function"===e.kind,e.parameter=function(e,t,n,s){return{id:e,kind:"declaration:parameter",name:t,type:n,loc:s??null}},e.isParameter=e=>"declaration:parameter"===e.kind}(c||(c={}));var l;!function(e){e.isBase=e=>a.isBase(e)&&e.kind.startsWith("block:"),e.statements=function(e,t,n){return{id:e,kind:"block:statements",items:t,loc:n??null}},e.isStatements=e=>"block:statements"===e.kind,e.definitions=function(e,t,n){return{id:e,kind:"block:definitions",items:t,loc:n??null}},e.isDefinitions=e=>"block:definitions"===e.kind}(l||(l={}));var u;!function(e){let t,n;e.isBase=e=>a.isBase(e)&&e.kind.startsWith("type:"),e.isElementary=e=>e.kind.startsWith("type:elementary:"),function(e){e.isBase=e=>e.kind.startsWith("type:elementary:"),e.isUint=e=>"type:elementary:uint"===e.kind,e.uint=function(e,t=256,n){return{id:e,kind:"type:elementary:uint",bits:t,loc:n??null}},e.isInt=e=>"type:elementary:int"===e.kind,e.int=function(e,t=256,n){return{id:e,kind:"type:elementary:int",bits:t,loc:n??null}},e.isAddress=e=>"type:elementary:address"===e.kind,e.address=function(e,t){return{id:e,kind:"type:elementary:address",loc:t??null}},e.isBool=e=>"type:elementary:bool"===e.kind,e.bool=function(e,t){return{id:e,kind:"type:elementary:bool",loc:t??null}},e.isBytes=e=>"type:elementary:bytes"===e.kind,e.bytes=function(e,t,n){return{id:e,kind:"type:elementary:bytes",size:t,loc:n??null}},e.isString=e=>"type:elementary:string"===e.kind,e.string=function(e,t){return{id:e,kind:"type:elementary:string",loc:t??null}},e.isFixed=e=>"type:elementary:fixed"===e.kind,e.fixed=function(e,t=128,n){return{id:e,kind:"type:elementary:fixed",bits:t,loc:n??null}},e.isUfixed=e=>"type:elementary:ufixed"===e.kind,e.ufixed=function(e,t=128,n){return{id:e,kind:"type:elementary:ufixed",bits:t,loc:n??null}}}(t=e.Elementary||(e.Elementary={})),e.isComplex=e=>e.kind.startsWith("type:complex:"),function(e){e.isBase=e=>e.kind.startsWith("type:complex:"),e.isArray=e=>"type:complex:array"===e.kind,e.array=function(e,t,n,s){return{id:e,kind:"type:complex:array",element:t,size:n,loc:s??null}},e.isMapping=e=>"type:complex:mapping"===e.kind,e.mapping=function(e,t,n,s){return{id:e,kind:"type:complex:mapping",key:t,value:n,loc:s??null}},e.isStruct=e=>"type:complex:struct"===e.kind,e.struct=function(e,t,n){return{id:e,kind:"type:complex:struct",fields:t,loc:n??null}},e.isTuple=e=>"type:complex:tuple"===e.kind,e.tuple=function(e,t,n){return{id:e,kind:"type:complex:tuple",members:t,loc:n??null}},e.isFunction=e=>"type:complex:function"===e.kind,e.function_=function(e,t,n,s){return{id:e,kind:"type:complex:function",parameters:t,returns:n,loc:s??null}},e.isAlias=e=>"type:complex:alias"===e.kind,e.alias=function(e,t,n){return{id:e,kind:"type:complex:alias",base:t,loc:n??null}},e.isContract=e=>"type:complex:contract"===e.kind,e.contract=function(e,t,n){return{id:e,kind:"type:complex:contract",name:t,loc:n??null}},e.isEnum=e=>"type:complex:enum"===e.kind,e.enum_=function(e,t,n){return{id:e,kind:"type:complex:enum",members:t,loc:n??null}}}(n=e.Complex||(e.Complex={})),e.isReference=e=>"type:reference"===e.kind,e.reference=function(e,t,n){return{id:e,kind:"type:reference",name:t,loc:n??null}}}(u||(u={}));const d=e=>p.isBase(e)&&[p.isDeclare,p.isAssign,p.isControlFlow,p.isExpress].some((t=>t(e)));var p;!function(e){let t;e.isBase=e=>a.isBase(e)&&e.kind.startsWith("statement:"),e.isDeclare=e=>"statement:declare"===e.kind,e.declare=function(e,t,n){return{id:e,kind:"statement:declare",declaration:t,loc:n??null}},e.isAssign=e=>"statement:assign"===e.kind,e.assign=function(e,t,n,s,o){return{id:e,kind:"statement:assign",target:t,value:n,operator:s,loc:o??null}},e.isControlFlow=t=>e.ControlFlow.isBase(t)&&[e.ControlFlow.isIf,e.ControlFlow.isFor,e.ControlFlow.isWhile,e.ControlFlow.isReturn,e.ControlFlow.isBreak,e.ControlFlow.isContinue].some((e=>e(t))),function(e){e.isBase=e=>e.kind.startsWith("statement:control-flow:"),e.isIf=e=>"statement:control-flow:if"===e.kind,e.if_=function(e,t,n,s,o){return{id:e,kind:"statement:control-flow:if",condition:t,body:n,alternate:s,loc:o??null}},e.isFor=e=>"statement:control-flow:for"===e.kind,e.for_=function(e,t,n,s,o,i){return{id:e,kind:"statement:control-flow:for",init:n,condition:s,update:o,body:t,loc:i??null}},e.isWhile=e=>"statement:control-flow:while"===e.kind,e.while_=function(e,t,n,s){return{id:e,kind:"statement:control-flow:while",condition:t,body:n,loc:s??null}},e.isReturn=e=>"statement:control-flow:return"===e.kind,e.return_=function(e,t,n){return{id:e,kind:"statement:control-flow:return",value:t,loc:n??null}},e.isBreak=e=>"statement:control-flow:break"===e.kind,e.break_=function(e,t,n){return{id:e,kind:"statement:control-flow:break",label:t,loc:n??null}},e.isContinue=e=>"statement:control-flow:continue"===e.kind,e.continue_=function(e,t,n){return{id:e,kind:"statement:control-flow:continue",label:t,loc:n??null}}}(t=e.ControlFlow||(e.ControlFlow={})),e.isExpress=e=>"statement:express"===e.kind,e.express=function(e,t,n){return{id:e,kind:"statement:express",expression:t,loc:n??null}}}(p||(p={}));const m=e=>f.isBase(e)&&[f.isIdentifier,f.isLiteral,f.isArray,f.isStruct,f.isOperator,f.isAccess,f.isCall,f.isCast,f.isSpecial].some((t=>t(e)));var f;!function(e){let t,n,s;e.isBase=e=>a.isBase(e)&&e.kind.startsWith("expression:"),e.isAssignable=function(e){return"expression:identifier"===e.kind||e.kind.startsWith("expression:access")},e.isIdentifier=e=>"expression:identifier"===e.kind&&"name"in e&&"string"==typeof e.name,e.identifier=function(e,t,n){return{id:e,kind:"expression:identifier",name:t,loc:n??null}},e.isLiteral=t=>e.Literal.isBase(t)&&[e.Literal.isNumber,e.Literal.isString,e.Literal.isBoolean,e.Literal.isAddress,e.Literal.isHex].some((e=>e(t))),function(e){e.isBase=e=>e.kind.startsWith("expression:literal:")&&"value"in e&&"string"==typeof e.value,e.isNumber=e=>"expression:literal:number"===e.kind,e.number=function(e,t,n,s){return{id:e,kind:"expression:literal:number",value:t,unit:n,loc:s??null}},e.isString=e=>"expression:literal:string"===e.kind,e.string=function(e,t,n){return{id:e,kind:"expression:literal:string",value:t,loc:n??null}},e.isBoolean=e=>"expression:literal:boolean"===e.kind,e.boolean=function(e,t,n){return{id:e,kind:"expression:literal:boolean",value:t,loc:n??null}},e.isAddress=e=>"expression:literal:address"===e.kind,e.address=function(e,t,n){return{id:e,kind:"expression:literal:address",value:t,loc:n??null}},e.isHex=e=>"expression:literal:hex"===e.kind,e.hex=function(e,t,n){return{id:e,kind:"expression:literal:hex",value:t,loc:n??null}}}(t=e.Literal||(e.Literal={})),e.isArray=e=>"expression:array"===e.kind&&"elements"in e&&y.isArray(e.elements)&&e.elements.every(m),e.array=function(e,t,n){return{id:e,kind:"expression:array",elements:t,loc:n??null}},e.isStruct=e=>"expression:struct"===e.kind&&"fields"in e&&y.isArray(e.fields)&&e.fields.every((e=>"object"==typeof e&&null!==e&&"name"in e&&"string"==typeof e.name&&"value"in e&&m(e.value))),e.struct=function(e,t,n,s){return{id:e,kind:"expression:struct",structName:n,fields:t,loc:s??null}},e.isOperator=e=>"expression:operator"===e.kind&&"operator"in e&&"string"==typeof e.operator&&"operands"in e&&Array.isArray(e.operands),e.operator=function(e,t,n,s){return{id:e,kind:"expression:operator",operator:t,operands:n,loc:s??null}},e.isAccess=t=>e.Access.isBase(t)&&[e.Access.isMember,e.Access.isSlice,e.Access.isIndex].some((e=>e(t))),function(e){e.isBase=e=>a.isBase(e)&&e.kind.startsWith("expression:access:")&&"object"in e&&m(e.object),e.member=function(e,t,n,s){return{id:e,kind:"expression:access:member",object:t,property:n,loc:s??null}},e.isMember=e=>"expression:access:member"===e.kind,e.slice=function(e,t,n,s,o){return{id:e,kind:"expression:access:slice",object:t,start:n,end:s,loc:o??null}},e.isSlice=e=>"expression:access:slice"===e.kind,e.index=function(e,t,n,s){return{id:e,kind:"expression:access:index",object:t,index:n,loc:s??null}},e.isIndex=e=>"expression:access:index"===e.kind}(n=e.Access||(e.Access={})),e.isCall=e=>"expression:call"===e.kind&&"callee"in e&&"object"==typeof e.callee&&"arguments"in e&&Array.isArray(e.arguments),e.call=function(e,t,n,s){return{id:e,kind:"expression:call",callee:t,arguments:n,loc:s??null}},e.isCast=e=>"expression:cast"===e.kind&&"expression"in e&&"object"==typeof e.expression&&"targetType"in e&&"object"==typeof e.targetType,e.cast=function(e,t,n,s){return{id:e,kind:"expression:cast",expression:t,targetType:n,loc:s??null}},e.isSpecial=t=>e.Special.isBase(t)&&[e.Special.isMsgData,e.Special.isMsgValue,e.Special.isMsgSender,e.Special.isBlockNumber,e.Special.isBlockTimestamp].some((e=>e(t))),function(e){e.isBase=e=>e.kind.startsWith("expression:special:"),e.isMsgSender=e=>"expression:special:msg.sender"===e.kind,e.msgSender=function(e,t){return{id:e,kind:"expression:special:msg.sender",loc:t??null}},e.isMsgValue=e=>"expression:special:msg.value"===e.kind,e.msgValue=function(e,t){return{id:e,kind:"expression:special:msg.value",loc:t??null}},e.isMsgData=e=>"expression:special:msg.data"===e.kind,e.msgData=function(e,t){return{id:e,kind:"expression:special:msg.data",loc:t??null}},e.isBlockTimestamp=e=>"expression:special:block.timestamp"===e.kind,e.blockTimestamp=function(e,t){return{id:e,kind:"expression:special:block.timestamp",loc:t??null}},e.isBlockNumber=e=>"expression:special:block.number"===e.kind,e.blockNumber=function(e,t){return{id:e,kind:"expression:special:block.number",loc:t??null}}}(s=e.Special||(e.Special={}))}(f||(f={}));const y=Array;function g(e,t,n){if("program"===t.kind)return e.program(t,n);if(t.kind.startsWith("declaration:"))return e.declaration(t,n);if(t.kind.startsWith("block:"))return e.block(t,n);if(t.kind.startsWith("type:"))return e.type(t,n);if(t.kind.startsWith("statement:"))return e.statement(t,n);if(t.kind.startsWith("expression:"))return e.expression(t,n);throw new Error(`Unknown node kind: ${t.kind}`)}const b=e=>k.isBase(e)&&[k.isElementary,k.isArray,k.isStruct,k.isMapping,k.isFunction,k.isFailure].some((t=>t(e))),h=Array;var k,v,x,w,T,E,S;function I(e,t,n){const s=new Map(e);return s.set(t,n),s}!function(e){let t,n,s,o,i,r;e.equals=(t,n)=>{if(t.kind!==n.kind)return!1;if(e.isElementary(t)&&e.isElementary(n))return e.Elementary.equals(t,n);return{array:e.Array.equals,struct:e.Struct.equals,mapping:e.Mapping.equals,function:e.Function.equals,failure:e.Failure.equals}[t.kind](t,n)},e.format=t=>{if(e.isElementary(t))return e.Elementary.format(t);return{array:e.Array,struct:e.Struct,mapping:e.Mapping,function:e.Function,failure:e.Failure}[t.kind].format(t)},e.isBase=e=>"object"==typeof e&&!!e&&"kind"in e&&"string"==typeof e.kind&&!!e.kind,e.isElementary=t=>[e.Elementary.isUint,e.Elementary.isInt,e.Elementary.isAddress,e.Elementary.isBool,e.Elementary.isBytes,e.Elementary.isString].some((e=>e(t))),function(t){let n,s,o,i,r,a;t.equals=(t,n)=>{if(t.kind!==n.kind)return!1;return{uint:e.Elementary.Uint.equals,int:e.Elementary.Int.equals,address:e.Elementary.Address.equals,bytes:e.Elementary.Bytes.equals,bool:e.Elementary.Bool.equals,string:e.Elementary.String.equals}[t.kind](t,n)},t.format=t=>({uint:e.Elementary.Uint,int:e.Elementary.Int,address:e.Elementary.Address,bytes:e.Elementary.Bytes,bool:e.Elementary.Bool,string:e.Elementary.String}[t.kind].format(t)),t.uint=e=>({kind:"uint",bits:e}),function(e){e.equals=(e,t)=>e.bits===t.bits,e.format=e=>`uint${e.bits}`}(n=t.Uint||(t.Uint={})),t.int=e=>({kind:"int",bits:e}),function(e){e.equals=(e,t)=>e.bits===t.bits,e.format=e=>`int${e.bits}`}(s=t.Int||(t.Int={})),t.address=()=>({kind:"address"}),function(e){e.equals=(e,t)=>!0,e.format=e=>"address"}(o=t.Address||(t.Address={})),t.bool=()=>({kind:"bool"}),function(e){e.equals=(e,t)=>!0,e.format=e=>"bool"}(i=t.Bool||(t.Bool={})),t.bytes=e=>({kind:"bytes",size:e}),function(e){e.isDynamic=e=>!("size"in e)||void 0===e.size,e.equals=(e,t)=>e.size==t.size,e.format=e=>`bytes${"size"in e&&"number"==typeof e.size?e.size.toString():""}`}(r=t.Bytes||(t.Bytes={})),t.string=()=>({kind:"string"}),function(e){e.equals=(e,t)=>!0,e.format=e=>"string"}(a=t.String||(t.String={}));const c=e=>t=>t.kind===e;t.isUint=c("uint"),t.isInt=c("int"),t.isAddress=c("address"),t.isBool=c("bool"),t.isBytes=c("bytes"),t.isString=c("string"),t.isNumeric=t=>e.Elementary.isUint(t)||e.Elementary.isInt(t)}(t=e.Elementary||(e.Elementary={})),e.isArray=e=>"array"===e.kind&&"element"in e&&b(e.element),e.array=(e,t)=>({kind:"array",element:e,size:t}),function(t){t.equals=(t,n)=>e.equals(t.element,n.element)&&t.size===n.size,t.format=t=>`array<${e.format(t.element)}${"size"in t&&"number"==typeof t.size?`, ${t.size}`:""}>`}(n=e.Array||(e.Array={})),e.mapping=(e,t)=>({kind:"mapping",key:e,value:t}),e.isMapping=e=>"mapping"===e.kind&&"key"in e&&"value"in e&&b(e.key)&&b(e.value),function(t){t.equals=(t,n)=>e.equals(t.key,n.key)&&e.equals(t.value,n.value),t.format=t=>`mapping<${e.format(t.key)}, ${e.format(t.value)}>`}(s=e.Mapping||(e.Mapping={})),e.isStruct=e=>"struct"===e.kind&&"name"in e&&"string"==typeof e.name&&"fields"in e&&e.fields instanceof Map&&[...e.fields.values()].every(b),e.struct=(e,t,n)=>({kind:"struct",name:e,fields:t,layout:n}),function(e){e.equals=(e,t)=>e.name===t.name&&e.fields.size==t.fields.size&&[...e.fields.entries()].every((([e,n],s)=>[...t.fields.keys()][s]===e&&[...t.fields.values()][s]===n)),e.format=e=>e.name}(o=e.Struct||(e.Struct={})),e.function_=(e,t,n)=>({kind:"function",parameters:e,return:t,name:n}),e.isFunction=e=>"function"===e.kind&&"parameters"in e&&e.parameters instanceof h&&e.parameters.every(b)&&"return"in e&&(null===e.return||b(e.return)),function(t){t.equals=(t,n)=>t.parameters.length===n.parameters.length&&t.parameters.every(((e,t)=>e==n.parameters[t]))&&(null===t.return&&null===n.return||null!==t.return&&null!==n.return&&e.equals(t.return,n.return)),t.format=t=>`function ${"name"in t?t.name:""}(${t.parameters.map((t=>e.format(t))).join(", ")})${null!==t.return?`-> ${e.format(t.return)}`:""}`}(i=e.Function||(e.Function={})),e.failure=e=>({kind:"fail",reason:e}),e.isFailure=e=>"fail"===e.kind&&"reason"in e&&"string"==typeof e.reason&&!!e.reason,function(e){e.equals=(e,t)=>e.reason===t.reason,e.format=e=>`fail<"${e.reason}">`}(r=e.Failure||(e.Failure={}))}(k||(k={}));!function(e){let t,n;e.isBase=e=>"object"==typeof e&&!!e&&"kind"in e&&"string"==typeof e.kind,e.scalar=(e,t)=>({kind:"scalar",size:e,origin:t}),e.isScalar=e=>"scalar"===e.kind&&"size"in e&&"number"==typeof e.size&&e.size>=1&&e.size<=32&&"origin"in e,function(t){t.synthetic=t=>e.scalar(t,"synthetic"),t.bytes1=t.synthetic(1),t.bytes4=t.synthetic(4),t.bytes8=t.synthetic(8),t.bytes20=t.synthetic(20),t.bytes32=t.synthetic(32),t.uint8=t.bytes1,t.uint32=t.bytes4,t.uint64=t.bytes8,t.uint256=t.bytes32,t.int8=t.bytes1,t.int256=t.bytes32,t.address=t.bytes20,t.bool=t.bytes1,t.word=t.bytes32,t.equals=(e,t)=>e.size===t.size&&e.origin===t.origin,t.format=e=>{const t=`scalar${e.size}`;return"synthetic"===e.origin?t:`${t}[${k.format(e.origin)}]`}}(t=e.Scalar||(e.Scalar={})),e.ref=(e,t)=>({kind:"ref",location:e,origin:t}),e.isRef=e=>"ref"===e.kind&&"location"in e&&"string"==typeof e.location&&["memory","storage","calldata","returndata","transient"].includes(e.location)&&"origin"in e,function(t){t.synthetic=t=>e.ref(t,"synthetic"),t.memory=()=>t.synthetic("memory"),t.storage=()=>t.synthetic("storage"),t.calldata=()=>t.synthetic("calldata"),t.returndata=()=>t.synthetic("returndata"),t.transient=()=>t.synthetic("transient"),t.equals=(e,t)=>e.location===t.location&&e.origin===t.origin,t.format=e=>{const t=`ref<${e.location}>`;return"synthetic"===e.origin?t:`${t}[${k.format(e.origin)}]`}}(n=e.Ref||(e.Ref={})),e.equals=(t,n)=>t.kind===n.kind&&(e.isScalar(t)&&e.isScalar(n)?e.Scalar.equals(t,n):!(!e.isRef(t)||!e.isRef(n))&&e.Ref.equals(t,n)),e.format=t=>e.isScalar(t)?e.Scalar.format(t):e.isRef(t)?e.Ref.format(t):"unknown"}(v||(v={})),function(e){e.temp=function(e,t,n){return{kind:"temp",id:e,type:t,debug:n}},e.constant=function(e,t,n){return{kind:"const",value:e,type:t,debug:n}}}(x||(x={})),function(e){let t,n;!function(e){e.isArray=e=>"array"===e.offsetKind,e.array=(e,t,n,s,o,i,r,a)=>({kind:"compute_offset",offsetKind:"array",location:e,base:t,baseDebug:r,index:n,indexDebug:a,stride:s,dest:o,operationDebug:i}),e.isField=e=>"field"===e.offsetKind,e.field=(e,t,n,s,o,i,r)=>({kind:"compute_offset",offsetKind:"field",location:e,base:t,baseDebug:r,field:n,fieldOffset:s,dest:o,operationDebug:i}),e.isByte=e=>"byte"===e.offsetKind,e.byte=(e,t,n,s,o,i,r)=>({kind:"compute_offset",offsetKind:"byte",location:e,base:t,baseDebug:i,offset:n,offsetDebug:r,dest:s,operationDebug:o})}(t=e.ComputeOffset||(e.ComputeOffset={})),function(e){e.isMapping=e=>"mapping"===e.slotKind,e.mapping=(e,t,n,s,o,i,r)=>({kind:"compute_slot",slotKind:"mapping",base:e,baseDebug:i,key:t,keyDebug:r,keyType:n,dest:s,operationDebug:o}),e.isArray=e=>"array"===e.slotKind,e.array=(e,t,n,s)=>({kind:"compute_slot",slotKind:"array",base:e,baseDebug:s,dest:t,operationDebug:n}),e.isField=e=>"field"===e.slotKind,e.field=(e,t,n,s,o)=>({kind:"compute_slot",slotKind:"field",base:e,baseDebug:o,fieldOffset:t,dest:n,operationDebug:s})}(n=e.ComputeSlot||(e.ComputeSlot={}))}(w||(w={}));function N(...e){const t=e.filter((e=>void 0!==e)).map((e=>e.context)).filter((e=>void 0!==e));if(0===t.length)return{};const n=[];for(const i of t)"pick"in i&&Array.isArray(i.pick)?n.push(...i.pick):n.push(i);const s=[],o=new Set;for(const i of n){const e=JSON.stringify(i,((e,t)=>t&&"object"==typeof t&&!Array.isArray(t)?Object.keys(t).sort().reduce(((e,n)=>(e[n]=t[n],e)),{}):t));o.has(e)||(o.add(e),s.push(i))}return 0===s.length?{}:1===s.length?{context:s[0]}:{context:{pick:s}}}function A(e,...t){let n;return"operationDebug"in e?n=e.operationDebug:"debug"in e&&(n=e.debug),N(n,...t)}function D(...e){const t=[];for(const n of e){if(!n)continue;let e;"operationDebug"in n?e=n.operationDebug:"debug"in n&&(e=n.debug),e?.context&&t.push(e.context)}return t}function $(e,t){return N(...[e,...Object.values(t)])}function M(e){const t=[];switch(e.operationDebug?.context&&t.push(e.operationDebug.context),e.kind){case"binary":e.leftDebug?.context&&t.push(e.leftDebug.context),e.rightDebug?.context&&t.push(e.rightDebug.context);break;case"unary":e.operandDebug?.context&&t.push(e.operandDebug.context);break;case"read":case"write":e.slotDebug?.context&&t.push(e.slotDebug.context),e.offsetDebug?.context&&t.push(e.offsetDebug.context),e.lengthDebug?.context&&t.push(e.lengthDebug.context),"write"===e.kind&&e.valueDebug?.context&&t.push(e.valueDebug.context);break;case"compute_offset":e.baseDebug?.context&&t.push(e.baseDebug.context),"array"===e.offsetKind&&e.indexDebug?.context&&t.push(e.indexDebug.context),"byte"===e.offsetKind&&e.offsetDebug?.context&&t.push(e.offsetDebug.context);break;case"compute_slot":e.baseDebug?.context&&t.push(e.baseDebug.context),"mapping"===e.slotKind&&e.keyDebug?.context&&t.push(e.keyDebug.context);break;case"const":case"hash":case"cast":e.valueDebug?.context&&t.push(e.valueDebug.context);break;case"allocate":e.sizeDebug?.context&&t.push(e.sizeDebug.context);break;case"length":e.objectDebug?.context&&t.push(e.objectDebug.context)}const n=e=>{e?.debug?.context&&t.push(e.debug.context)};switch(e.kind){case"binary":n(e.left),n(e.right);break;case"unary":n(e.operand);break;case"read":n(e.slot),n(e.offset),n(e.length);break;case"write":n(e.slot),n(e.offset),n(e.length),n(e.value);break;case"compute_offset":n(e.base),"array"===e.offsetKind&&n(e.index),"byte"===e.offsetKind&&n(e.offset);break;case"compute_slot":n(e.base),"mapping"===e.slotKind&&n(e.key);break;case"allocate":n(e.size);break;case"hash":case"cast":n(e.value);break;case"length":n(e.object)}return t}function j(e,...t){const n=M(e),s=t.filter((e=>void 0!==e)).map((e=>e.context)).filter((e=>void 0!==e));return N(...n.map((e=>({context:e}))),...s.map((e=>({context:e}))))}!function(e){e.Analyzer=class{analyze(e){const t=e.main,n=Array.from(t.blocks.values()),s=n.length,o=n.flatMap((e=>e.instructions)),i=o.length,r={};for(const g of o)r[g.kind]=(r[g.kind]||0)+1;const a=n.map((e=>e.instructions.length+1)),c=Math.max(...a),l=a.reduce(((e,t)=>e+t),0)/s,u=this.countTemporaries(t),d=t.parameters.length,p=this.countCfgEdges(t),m=this.computeDominatorTree(t),f=this.findCriticalPaths(t),y=this.detectLoops(t,m);return{blockCount:s,instructionCount:i,tempCount:u,parameterCount:d,maxBlockSize:c,avgBlockSize:Math.round(10*l)/10,cfgEdges:p,instructionTypes:r,criticalPaths:f,dominatorTree:m,loopInfo:y}}countTemporaries(e){const t=new Set;for(const n of e.blocks.values()){for(const e of n.instructions)"dest"in e&&e.dest&&t.add(e.dest),this.collectTempsFromValue(e,t);"branch"===n.terminator.kind?this.collectTempsFromValueRef(n.terminator.condition,t):"return"===n.terminator.kind&&n.terminator.value&&this.collectTempsFromValueRef(n.terminator.value,t)}return t.size}collectTempsFromValue(e,t){const n=["value","left","right","operand","object","array","index","key"];for(const s of n)if(s in e){const n=e[s];n&&this.collectTempsFromValueRef(n,t)}}collectTempsFromValueRef(e,t){"object"==typeof e&&e&&"kind"in e&&"temp"===e.kind&&t.add(e.id)}countCfgEdges(e){let t=0;for(const n of e.blocks.values())switch(n.terminator.kind){case"jump":t+=1;break;case"branch":t+=2}return t}computeDominatorTree(e){const t={},n=Array.from(e.blocks.keys()),s={};for(const i of n)s[i]=Array.from(e.blocks.get(i)?.predecessors||[]);t[e.entry]=null;for(const i of n)i!==e.entry&&(t[i]=void 0);let o=!0;for(;o;){o=!1;const n=[e.entry],i=new Set([e.entry]);for(;n.length>0;){const r=n.shift(),a=e.blocks.get(r);if(!a)continue;const c=this.getSuccessors(a);for(const e of c)i.has(e)||(n.push(e),i.add(e));if(r===e.entry)continue;const l=s[r]||[];if(0===l.length)continue;let u;for(const e of l)if(void 0!==t[e]){u=e;break}if(void 0!==u){for(const e of l)e!==u&&void 0!==t[e]&&(u=this.intersectDominators(e,u,t));t[r]!==u&&(t[r]=u,o=!0)}}}return t}intersectDominators(e,t,n){let s=e,o=t;const i=new Set;for(;null!==s;)i.add(s),s=n[s]??null;for(;null!==o;){if(i.has(o))return o;o=n[o]??null}throw new Error("No common dominator found - CFG may be disconnected")}findCriticalPaths(e){const t=[],n=new Set,s=(o,i,r)=>{if(n.has(o))return;const a=e.blocks.get(o);if(!a)return;const c=[...i,o],l=r+a.instructions.length+1;if("return"===a.terminator.kind)return void t.push({from:e.entry,to:o,length:l,blocks:c});n.add(o);const u=this.getSuccessors(a);for(const e of u)s(e,c,l);n.delete(o)};return s(e.entry,[],0),t.sort(((e,t)=>t.length-e.length)).slice(0,3)}detectLoops(e,t){const n=[];for(const[s,o]of e.blocks.entries()){const i=this.getSuccessors(o);for(const o of i)if(this.dominates(o,s,t)){const t=this.findLoopBlocks(o,s,e);n.push({header:o,blocks:t,depth:0})}}return this.computeLoopDepths(n),n}computeLoopDepths(e){for(let t=0;t<e.length;t++){let n=1;for(let s=0;s<e.length;s++)t!==s&&this.isLoopContainedIn(e[t],e[s])&&n++;e[t].depth=n}}isLoopContainedIn(e,t){return t.blocks.includes(e.header)}dominates(e,t,n){let s=t;for(;null!==s;){if(s===e)return!0;s=n[s]||null}return!1}findLoopBlocks(e,t,n){const s=new Set([e,t]),o=[t];for(;o.length>0;){const t=o.pop(),i=n.blocks.get(t);if(i)for(const n of i.predecessors)s.has(n)||(s.add(n),n!==e&&o.push(n))}return Array.from(s)}getSuccessors(e){switch(e.terminator.kind){case"jump":return[e.terminator.target];case"branch":return[e.terminator.trueTarget,e.terminator.falseTarget];default:return[]}}}}(T||(T={}));function C(e,t,n,s,o,i,r){let a,c=e.popN(t,n.length);for(let l=s.length-1;l>=0;l--)({id:a,state:c}=e.generateId(c,i)),c=e.push(c,e.create(a,(r?.produces||s)[l]));return e.emit(c,o)}!function(e){e.makeControls=({slice:e,prepend:t,readTop:n,generateId:s,create:o,duplicate:i,rebrand:r,emit:a})=>({popN:(t,n)=>e(t,n),push:(e,n)=>t(e,n),topN:(e,t)=>n(e,t),create:(e,t)=>o(e,t),duplicate:(e,t)=>i(e,t),rebrand:(e,t)=>r(e,t),generateId:(e,t)=>s(e,t),emit:(e,t)=>a(e,t)})}(E||(E={})),function(e){e.makeUsing=function(e){return{mapInstruction:(e,t)=>({[e.mnemonic]:t(e)}),makeOperationForInstruction:({consumes:t,produces:n,idPrefix:s})=>o=>i=>r=>C(e,r,t,n,{...o,...i},s,void 0),makeOperationWithImmediatesForInstruction:({consumes:t,produces:n,idPrefix:s})=>o=>(i,r)=>a=>C(e,a,t,n,{...o,immediates:i,...r},s,void 0)}}}(S||(S={}));const O=e=>{function t(t){return n=>{const s=Object.keys(t).map(Number).sort(((e,t)=>t-e));if(0===s.length)return n;const o=s[0],i=e.topN(n,o),r=e.popN(n,o);return i.reduceRight(((n,s,o)=>e.push(n,o+1 in t?e.rebrand(s,t[o+1]):s)),r)}}return{rebrand:t,rebrandTop:e=>n=>t({1:e})(n)}};class _{constructor(e,t){this.controls=e,this.transition=t}err(e){return this.then((()=>{throw e}))}peek(e){return new _(this.controls,(t=>{const n=this.transition(t),s=new _(this.controls,(e=>e));return e(n,s).transition(n)}))}then(e,t){const{rebrandTop:n}=O(this.controls),s=t=>e(this.transition(t));return new _(this.controls,t?e=>n(t.as)(s(e)):s)}done(){return e=>this.transition(e)}}var B,U=n(1159);!function(e){e.Error="error",e.Warning="warning"}(B||(B={}));const L={ok:e=>({success:!0,value:e,messages:{}}),okWith:(e,t)=>L.addMessages(L.ok(e),t),err(e){const t=Array.isArray(e)?e:[e];return{success:!1,messages:{[B.Error]:t}}},map:(e,t)=>e.success?{...e,value:t(e.value)}:e,addMessages(e,t){const n={...e.messages};for(const s of t){const e=s.severity;n[e]||(n[e]=[]),n[e].push(s)}return{...e,messages:n}},mergeMessages(e,t){const n={...e};for(const[s,o]of Object.entries(t))n[s]||(n[s]=[]),n[s].push(...o);return n},hasErrors:e=>(e.messages[B.Error]?.length??0)>0,hasWarnings:e=>(e.messages[B.Warning]?.length??0)>0,allMessages:e=>Object.values(e.messages).flat(),getMessages:(e,t)=>e.messages[t]||[],firstError(e){const t=e.messages[B.Error];return t?.[0]},firstMessage:e=>L.allMessages(e)[0],countBySeverity:(e,t)=>e.messages[t]?.length??0,countMessages:(e,t)=>t?L.findMessages(e,t).length:L.allMessages(e).length,findMessage:(e,t)=>L.allMessages(e).find((e=>{if(void 0!==t.severity&&e.severity!==t.severity)return!1;if(t.code&&e.code!==t.code)return!1;if(t.message){if(!("string"==typeof t.message?e.message.includes(t.message):t.message.test(e.message)))return!1}if(t.location){if(!e.location)return!1;if(e.location.offset!==t.location.offset)return!1;if(void 0!==t.location.length&&e.location.length!==t.location.length)return!1}return!0})),findMessages:(e,t)=>L.allMessages(e).filter((e=>{if(void 0!==t.severity&&e.severity!==t.severity)return!1;if(t.code&&e.code!==t.code)return!1;if(t.message){if(!("string"==typeof t.message?e.message.includes(t.message):t.message.test(e.message)))return!1}if(t.location){if(!e.location)return!1;if(e.location.offset!==t.location.offset)return!1;if(void 0!==t.location.length&&e.location.length!==t.location.length)return!1}return!0})),hasMessage:(e,t)=>void 0!==L.findMessage(e,t),hasMessages:e=>L.countMessages(e)>0,errors:e=>L.getMessages(e,B.Error),warnings:e=>L.getMessages(e,B.Warning),countErrors:e=>L.errors(e).length};class R extends Error{constructor(e,t,n,s=B.Error){super(e),this.name=this.constructor.name,this.code=t,this.location=n,this.severity=s,Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)}toString(){const e=this.severity===B.Error?"Error":"Warning",t=`[${this.code}]`;return this.location?`${e} ${t}: ${this.message} at offset ${this.location.offset}`:`${e} ${t}: ${this.message}`}}class P extends R{constructor(e,t,n){super(e,"PARSE_ERROR",t),this.expected=n}}const V="<pending>";function z(e){return function(e,t){const n=e.parse(t);if(n.status)return L.ok(n.value);{const e={offset:n.index.offset,length:1};let t=`Parse error at line ${n.index.line}, column ${n.index.column}`;if(n.expected&&n.expected.length>0)for(const o of n.expected)if(o&&(o.includes("exceeds maximum safe integer")||o.includes("must be positive")||o.includes("must be non-negative")||o.includes("must be an integer")||o.includes("Cannot use keyword"))){t=o;break}const s=new P(t,e,n.expected);return L.err(s)}}(Pe,e)}const F=U.alt(U.regexp(/\/\/[^\n]*/),U.regexp(/\/\*[^]*?\*\//)),H=U.alt(U.whitespace,F),q=H.many().result(void 0),W=H.atLeast(1).result(void 0),K=e=>e.skip(q),Y=e=>K(U.string(e).notFollowedBy(U.regexp(/[a-zA-Z0-9_]/)).desc(`keyword '${e}'`)),G=e=>K(U.string(e)),J={_:q,__:W,comment:F,lexeme:K,keyword:Y,operator:e=>U.string(e).desc(`operator '${e}'`),token:G,lparen:G("("),rparen:G(")"),lbracket:G("["),rbracket:G("]"),lbrace:G("{"),rbrace:G("}"),semicolon:G(";"),comma:G(","),colon:G(":"),dot:G("."),equals:G("="),arrow:G("->"),plus:G("+"),minus:G("-"),multiply:G("*"),divide:G("/"),lt:G("<"),gt:G(">"),lte:G("<="),gte:G(">="),eq:G("=="),neq:G("!="),and:G("&&"),or:G("||"),not:G("!"),as:G("as"),identifier:K(U.regexp(/[a-zA-Z_][a-zA-Z0-9_]*/).chain((e=>["let","if","else","for","while","return","break","continue","struct","mapping","array","function","storage","code","create","define","msg","true","false","wei","finney","ether","as","uint256","uint128","uint64","uint32","uint16","uint8","int256","int128","int64","int32","int16","int8","address","bool","bytes32","bytes16","bytes8","bytes4","bytes","string"].includes(e)?U.fail(`Cannot use keyword '${e}' as identifier`):U.succeed(e)))),number:K(U.regexp(/0x[0-9a-fA-F]+|[0-9]+/).desc("number").map((e=>(e.startsWith("0x"),BigInt(e))))),string:K(U.regexp(/"([^"\\\n\r]|\\[ntr"\\])*"/).desc("string literal").map((e=>e.slice(1,-1).replace(/\\n/g,"\n").replace(/\\t/g,"\t").replace(/\\r/g,"\r").replace(/\\\\/g,"\\").replace(/\\"/g,'"')))),boolean:K(U.alt(U.string("true").result(!0),U.string("false").result(!1)).desc("boolean literal")),address:K(U.regexp(/0x[0-9a-fA-F]{40}/).notFollowedBy(U.regexp(/[0-9a-fA-F]/)).desc("address literal")),weiUnit:U.alt(Y("ether"),Y("finney"),Y("wei")),elementaryType:U.alt(Y("uint256"),Y("uint128"),Y("uint64"),Y("uint32"),Y("uint16"),Y("uint8"),Y("int256"),Y("int128"),Y("int64"),Y("int32"),Y("int16"),Y("int8"),Y("address"),Y("bool"),Y("bytes32"),Y("bytes16"),Y("bytes8"),Y("bytes4"),Y("bytes"),Y("string")),reservedWord:U.alt(Y("let"),Y("if"),Y("else"),Y("for"),Y("while"),Y("return"),Y("break"),Y("continue"),Y("struct"),Y("mapping"),Y("array"),Y("function"),Y("name"),Y("storage"),Y("code"),Y("msg"),Y("true"),Y("false"))};function Z(e){return e.mark().map((e=>{const t=function(e){return{offset:e.start.offset,length:e.end.offset-e.start.offset}}(e),n=`${t.offset}_${t.length}`;return{...e.value,id:n,loc:t}}))}let X,Q,ee;const te=Z(J.elementaryType.map((e=>{if(e.startsWith("uint")){const t=parseInt(e.substring(4),10);return u.Elementary.uint(V,t)}if(e.startsWith("int")){const t=parseInt(e.substring(3),10);return u.Elementary.int(V,t)}if(e.startsWith("bytes")&&"bytes"!==e){const t=parseInt(e.substring(5),10);return u.Elementary.bytes(V,t)}if("address"===e)return u.Elementary.address(V);if("bool"===e)return u.Elementary.bool(V);if("string"===e)return u.Elementary.string(V);if("bytes"===e)return u.Elementary.bytes(V);throw new Error(`Unknown elementary type: ${e}`)}))),ne=Z(J.identifier.map((e=>u.reference(V,e)))),se=U.lazy((()=>Z(U.seq(J.keyword("array"),J.lt,X,U.seq(J.comma,re).map((([e,t])=>t)).fallback(null),J.gt).chain((([e,t,n,s,o])=>{if(s){const e=Number(s);if(e>Number.MAX_SAFE_INTEGER)return U.fail(`Array size ${s} exceeds maximum safe integer (${Number.MAX_SAFE_INTEGER})`);if(e<=0)return U.fail(`Array size must be positive, got ${e}`)}return U.succeed(u.Complex.array(V,n,s?Number(s):void 0))}))))),oe=U.lazy((()=>Z(U.seq(J.keyword("mapping"),J.lt,X,J.comma,X,J.gt).map((([e,t,n,s,o,i])=>u.Complex.mapping(V,n,o))))));X=U.alt(se,oe,te,ne);const ie=Z(J.identifier.map((e=>f.identifier(V,e)))),re=J.lexeme(U.regexp(/[0-9]+/).desc("number")),ae=J.lexeme(U.regexp(/0x[0-9a-fA-F]+/).desc("hex literal")),ce=Z(re.map((e=>f.Literal.number(V,e)))),le=Z(ae.map((e=>f.Literal.hex(V,e)))),ue=Z(U.alt(J.keyword("true"),J.keyword("false")).map((e=>f.Literal.boolean(V,e)))),de=Z(J.string.map((e=>f.Literal.string(V,e)))),pe=Z(U.regex(/0x[0-9a-fA-F]{40}/).desc("address literal").notFollowedBy(U.regex(/[0-9a-fA-F]/)).map((e=>f.Literal.address(V,e.toLowerCase())))),me=Z(U.seq(re,J._,U.alt(J.keyword("wei"),J.keyword("finney"),J.keyword("ether"))).map((([e,t,n])=>f.Literal.number(V,e,n)))),fe=Z(U.seq(J.keyword("msg"),J.dot,U.alt(J.keyword("sender"),J.keyword("value"),J.keyword("data"))).map((([e,t,n])=>{const s="sender"===n?"msg.sender":"value"===n?"msg.value":"msg.data";return"msg.sender"===s?f.Special.msgSender(V):"msg.value"===s?f.Special.msgValue(V):f.Special.msgData(V)}))),ye=Z(U.seq(J.keyword("block"),J.dot,U.alt(J.keyword("timestamp"),J.keyword("number"))).map((([e,t,n])=>"block.timestamp"===("timestamp"===n?"block.timestamp":"block.number")?f.Special.blockTimestamp(V):f.Special.blockNumber(V)))),ge=U.lazy((()=>U.seq(J.lbracket,U.sepBy(Q,J.comma),J.rbracket).map((([e,t,n])=>f.array(V,t))))),be=U.lazy((()=>{const e=U.seq(J.identifier,J.colon,Q).map((([e,t,n])=>({name:e,value:n})));return U.seq(J.identifier,J.lbrace,U.sepBy(e,J.comma),J.rbrace).map((([e,t,n,s])=>f.struct(V,n,e)))})),he=U.lazy((()=>U.alt(me,pe,le,ce,ue,de,ge,be,fe,ye,ie,J.lparen.then(Q).skip(J.rparen)))),ke=U.lazy((()=>{const e=U.seq(J.dot,J.identifier).map((([e,t])=>({type:"member",property:t}))),t=U.seq(J.lbracket,Q,U.seq(J.colon,Q).or(U.succeed(null)),J.rbracket).map((([e,t,n,s])=>n?{type:"slice",property:t,end:n[1]}:{type:"index",property:t})),n=U.seq(J.lparen,U.sepBy(Q,J.comma),J.rparen).map((([e,t,n])=>({type:"call",arguments:t}))),s=U.seq(J.as,X).map((([e,t])=>({type:"cast",targetType:t}))),o=U.alt(e,t,n,s),i=U.seq(he,o.many()).map((([e,t])=>t.reduce(((e,t)=>"member"===t.type?Z(U.succeed(f.Access.member(V,e,t.property))).tryParse(""):"slice"===t.type?Z(U.succeed(f.Access.slice(V,e,t.property,t.end))).tryParse(""):"call"===t.type?Z(U.succeed(f.call(V,e,t.arguments))).tryParse(""):"cast"===t.type?Z(U.succeed(f.cast(V,e,t.targetType))).tryParse(""):Z(U.succeed(f.Access.index(V,e,t.property))).tryParse("")),e)));return Z(i)})),ve=U.lazy((()=>U.alt(Z(U.seq(U.alt(J.not,J.minus),ve).map((([e,t])=>f.operator(V,e,[t])))),ke))),xe=[["||"],["&&"],["==","!="],["<",">","<=",">="],["+","-"],["*","/"]];Q=function e(t,n){if(t>=xe.length)return n;const s=[...xe[t]].sort(((e,t)=>t.length-e.length)).map((e=>J._.then(U.string(e)).skip(J._)));return U.lazy((()=>Z(U.seq(e(t+1,n),U.seq(U.alt(...s),e(t+1,n)).many()).map((([e,t])=>t.reduce(((e,[t,n])=>{const s=e.loc&&n.loc&&{offset:e.loc.offset,length:Number(n.loc.offset)+Number(n.loc.length)-Number(e.loc.offset)};return f.operator(V,t,[e,n],s||void 0)}),e))))))}(0,ve);const we=Z(U.seq(J.keyword("let"),Z(U.seq(J.identifier,U.seq(J.colon,X).map((([e,t])=>t)).fallback(void 0),J.equals,Q).map((([e,t,n,s])=>c.variable(V,e,t,s)))),J.semicolon).map((([e,t,n])=>p.declare(V,t)))),Te=U.lazy((()=>Z(U.seq(Q,J.equals,Q,J.semicolon).map((([e,t,n,s])=>p.assign(V,e,n)))))),Ee=Z(U.seq(Q,J.semicolon).map((([e,t])=>p.express(V,e)))),Se=Z(U.seq(J.keyword("return"),Q.fallback(null),J.semicolon).map((([e,t,n])=>p.ControlFlow.return_(V,t||void 0)))),Ie=Z(U.seq(J.keyword("break"),J.semicolon).map((()=>p.ControlFlow.break_(V)))),Ne=Z(U.lazy((()=>U.seq(J.lbrace,ee.many(),J.rbrace).map((([e,t,n])=>l.statements(V,t)))))),Ae=U.lazy((()=>Z(U.seq(J.keyword("if"),J.lparen,Q,J.rparen,Ne,U.seq(J.keyword("else"),Ne).map((([e,t])=>t)).fallback(void 0)).map((([e,t,n,s,o,i])=>p.ControlFlow.if_(V,n,o,i)))))),De=U.lazy((()=>Z(U.seq(J.keyword("for"),J.lparen,we,Q,J.semicolon,Z(U.seq(Q,J.equals,Q).map((([e,t,n])=>p.assign(V,e,n)))),J.rparen,Ne).map((e=>{const t=e[2],n=e[3],s=e[5],o=e[7];return p.ControlFlow.for_(V,o,t,n,s)})))));ee=U.alt(we,Ae,De,Se,Ie,Te,Ee);const $e=Z(U.seq(J.identifier,J.colon,X).map((([e,t,n])=>c.field(V,e,n)))),Me=Z(U.seq(J.keyword("struct"),J.identifier,J.lbrace,$e.sepBy(J.semicolon).skip(J.semicolon.or(U.succeed(null))),J.rbrace).map((([e,t,n,s,o])=>c.struct(V,t,s)))),je=Z(U.seq(J.identifier,J.colon,X).map((([e,t,n])=>c.parameter(V,e,n)))),Ce=U.lazy((()=>Z(U.seq(J.keyword("function"),J.identifier,J.lparen,je.sepBy(J.comma),J.rparen,U.seq(J.arrow,X).map((([e,t])=>t)).fallback(void 0),Ne).map((([e,t,n,s,o,i,r])=>c.function_(V,t,s,i,r)))))),Oe=Z(U.seq(J.lbracket,re,J.rbracket,J.identifier,J.colon,X).chain((([e,t,n,s,o,i])=>{const r=Number(t);return r>Number.MAX_SAFE_INTEGER?U.fail(`Storage slot ${t} exceeds maximum safe integer (${Number.MAX_SAFE_INTEGER})`):r<0?U.fail(`Storage slot must be non-negative, got ${r}`):Number.isInteger(r)?U.succeed(c.storage(V,s,i,r)):U.fail(`Storage slot must be an integer, got ${r}`)}))),_e=Z(U.seq(J.keyword("define"),J.lbrace,U.alt(U.alt(Me,Ce).skip(J.semicolon).atLeast(1),U.succeed([])),J.rbrace).map((([e,t,n,s])=>l.definitions(V,n)))),Be=U.seq(J.keyword("storage"),J.lbrace,U.alt(Oe.skip(J.semicolon).atLeast(1),U.succeed([])),J.rbrace).map((([e,t,n,s])=>n)),Ue=Z(U.seq(J.keyword("create"),J.lbrace,ee.many(),J.rbrace).map((([e,t,n,s])=>l.statements(V,n)))),Le=Z(U.seq(J.keyword("code"),J.lbrace,ee.many(),J.rbrace).map((([e,t,n,s])=>l.statements(V,n)))),Re=Z(U.seq(J.keyword("name"),J.identifier,J.semicolon,_e.or(U.succeed(null)),Be.or(U.succeed([])),Ue.or(U.succeed(null)),Le.or(U.succeed(null))).map((([e,t,n,s,o,i,r])=>function(e,t,n,s,o,i,r){return{id:e,kind:"program",name:t,storage:n,definitions:s,body:o,create:i,loc:r??null}}(V,t,o,s||void 0,r||void 0,i||void 0)))),Pe=U.seq(J._,Re,J._).map((([e,t,n])=>t));var Ve;!function(e){e.TYPE_MISMATCH="TYPE001",e.UNDEFINED_VARIABLE="TYPE002",e.UNDEFINED_TYPE="TYPE003",e.INVALID_OPERATION="TYPE004",e.MISSING_INITIALIZER="TYPE005",e.INVALID_ASSIGNMENT="TYPE006",e.INVALID_CONDITION="TYPE007",e.INVALID_OPERAND="TYPE008",e.NO_SUCH_FIELD="TYPE009",e.INVALID_INDEX_TYPE="TYPE010",e.NOT_INDEXABLE="TYPE011",e.INVALID_ARGUMENT_COUNT="TYPE012",e.INVALID_TYPE_CAST="TYPE013",e.INTERNAL_ERROR="TYPE014",e.GENERAL="TYPE_ERROR"}(Ve||(Ve={}));const ze=(e,t)=>`Type mismatch: expected ${e}, got ${t}`,Fe=e=>`Undefined variable: ${e}`,He=e=>`Undefined type: ${e}`,qe=(e,t)=>`Operator ${e} requires ${t} operand`,We=(e,t)=>`Operator ${e} requires ${t} operands`,Ke=(e,t)=>`Struct ${e} has no field ${t}`,Ye=e=>`Cannot index ${e}`;class Ge extends R{constructor(e,t,n,s,o=Ve.GENERAL){super(e,o,t),this.expectedType=n,this.actualType=s}}function Je(e){switch(e.kind){case"string":case"array":case"mapping":case"struct":return!0;case"bytes":return void 0===e.size;default:return!1}}function Ze(e){switch(e.kind){case"bool":return 1;case"uint":case"int":return Math.ceil(e.bits/8);case"address":return 20;case"bytes":return e.size||32;default:return 32}}function Xe(e,t){const n=new Map;for(const o of e.fields)if(c.isField(o)&&o.type){const e=tt(o.type,t);n.set(o.name,e)}const s=function(e){const t=new Map;let n=0,s=0;const o=32;for(const[i,r]of e){const e=Ze(r);Je(r)?(s>0&&(n+=o,s=0),t.set(i,{byteOffset:n,size:o}),n+=o,s=0):(s+e>o&&(n+=o,s=0),t.set(i,{byteOffset:n+s,size:e}),s+=e,s>=o&&(n+=o,s=0))}return t}(n);return k.struct(e.name,n,s)}function Qe(e,t){const n=[];for(const o of e.parameters){const e=tt(o.type,t);n.push(e)}const s=e.returnType?tt(e.returnType,t):null;return k.function_(n,s,e.name)}function et(e,t,n){if(u.isElementary(e)){if(u.Elementary.isUint(e)){return{type:{256:k.Elementary.uint(256),128:k.Elementary.uint(128),64:k.Elementary.uint(64),32:k.Elementary.uint(32),16:k.Elementary.uint(16),8:k.Elementary.uint(8)}[e.bits||256]||k.failure(`Unknown uint size: ${e.bits}`),bindings:n}}if(u.Elementary.isInt(e)){return{type:{256:k.Elementary.int(256),128:k.Elementary.int(128),64:k.Elementary.int(64),32:k.Elementary.int(32),16:k.Elementary.int(16),8:k.Elementary.int(8)}[e.bits||256]||k.failure(`Unknown int size: ${e.bits}`),bindings:n}}if(u.Elementary.isBytes(e)){if(!e.size)return{type:k.Elementary.bytes(),bindings:n};return[4,8,16,32].includes(e.size)?{type:k.Elementary.bytes(e.size),bindings:n}:{type:k.failure(`Unknown bytes size: ${e.size}`),bindings:n}}return u.Elementary.isAddress(e)?{type:k.Elementary.address(),bindings:n}:u.Elementary.isBool(e)?{type:k.Elementary.bool(),bindings:n}:u.Elementary.isString(e)?{type:k.Elementary.string(),bindings:n}:{type:k.failure(`Unknown elementary type: ${e.kind}`),bindings:n}}if(u.isComplex(e)){if(u.Complex.isArray(e)){const s=et(e.element,t,n);return{type:k.array(s.type,e.size),bindings:s.bindings}}if(u.Complex.isMapping(e)){const s=et(e.key,t,n),o=et(e.value,t,s.bindings);return{type:k.mapping(s.type,o.type),bindings:o.bindings}}return{type:k.failure(`Unsupported complex type: ${e.kind}`),bindings:n}}if(u.isReference(e)){const s=t.get(e.name);if(!s)throw new Ge(He(e.name),e.loc||void 0,void 0,void 0,Ve.UNDEFINED_TYPE);const o=I(n,e.id,s.node);return{type:s.type,bindings:o}}return{type:k.failure("Unknown type"),bindings:n}}function tt(e,t){if(u.isElementary(e)){if(u.Elementary.isUint(e)){return{256:k.Elementary.uint(256),128:k.Elementary.uint(128),64:k.Elementary.uint(64),32:k.Elementary.uint(32),16:k.Elementary.uint(16),8:k.Elementary.uint(8)}[e.bits||256]||k.failure(`Unknown uint size: ${e.bits}`)}if(u.Elementary.isInt(e)){return{256:k.Elementary.int(256),128:k.Elementary.int(128),64:k.Elementary.int(64),32:k.Elementary.int(32),16:k.Elementary.int(16),8:k.Elementary.int(8)}[e.bits||256]||k.failure(`Unknown int size: ${e.bits}`)}if(u.Elementary.isBytes(e)){if(!e.size)return k.Elementary.bytes();return[4,8,16,32].includes(e.size)?k.Elementary.bytes(e.size):k.failure(`Unknown bytes size: ${e.size}`)}return u.Elementary.isAddress(e)?k.Elementary.address():u.Elementary.isBool(e)?k.Elementary.bool():u.Elementary.isString(e)?k.Elementary.string():k.failure(`Unknown elementary type: ${e.kind}`)}if(u.isComplex(e)){if(u.Complex.isArray(e)){const n=tt(e.element,t);return k.array(n,e.size)}if(u.Complex.isMapping(e)){const n=tt(e.key,t),s=tt(e.value,t);return k.mapping(n,s)}return k.failure(`Unsupported complex type: ${e.kind}`)}if(u.isReference(e)){const n=t.get(e.name);if(!n)throw new Ge(He(e.name),e.loc||void 0,void 0,void 0,Ve.UNDEFINED_TYPE);return n.type}return k.failure("Unknown type")}class nt{constructor(e=[new Map]){this.scopes=e}static empty(){return new nt}enterScope(){return new nt([...this.scopes,new Map])}exitScope(){return this.scopes.length<=1?this:new nt(this.scopes.slice(0,-1))}define(e){const t=[...this.scopes],n=new Map(t[t.length-1]);return n.set(e.name,e),t[t.length-1]=n,new nt(t)}lookup(e){for(let t=this.scopes.length-1;t>=0;t--){const n=this.scopes[t].get(e);if(n)return n}}isDefined(e){return void 0!==this.lookup(e)}isDefinedInCurrentScope(e){return this.scopes[this.scopes.length-1].has(e)}}function st(e,t,n){let s=e.enterScope();const o=t.parameters;for(let i=0;i<o.length;i++){const e=o[i],t={name:e.name,type:n.parameters[i],mutable:!0,location:"memory",declaration:e};s=s.define(t)}return s}function ot(e,t){if(k.isFailure(e)||k.isFailure(t))return!0;if(k.equals(e,t))return!0;if(k.isElementary(e)&&k.isElementary(t)&&k.Elementary.isNumeric(e)&&k.Elementary.isNumeric(t)){if(k.Elementary.isUint(e)&&k.Elementary.isUint(t))return!0;if(k.Elementary.isInt(e)&&k.Elementary.isInt(t))return!0}return!1}function it(e,t){if(k.equals(e,t))return e;if(k.isElementary(e)&&k.isElementary(t)){if(k.Elementary.isUint(e)&&k.Elementary.isUint(t)){return(e.bits||256)>=(t.bits||256)?e:t}if(k.Elementary.isInt(e)&&k.Elementary.isInt(t)){return(e.bits||256)>=(t.bits||256)?e:t}}return null}const rt={expression(e,t){if(f.isIdentifier(e)){const n=[],s=new Map(t.nodeTypes);let o=t.bindings;const i=t.symbols.lookup(e.name);if(!i){const i=new Ge(Fe(e.name),e.loc||void 0,void 0,void 0,Ve.UNDEFINED_VARIABLE);return n.push(i),{type:void 0,symbols:t.symbols,nodeTypes:s,bindings:o,errors:n}}return s.set(e.id,i.type),o=I(o,e.id,i.declaration),{type:i.type,symbols:t.symbols,nodeTypes:s,bindings:o,errors:n}}if(f.isLiteral(e)){const n=new Map(t.nodeTypes);let s;switch(e.kind){case"expression:literal:number":s=k.Elementary.uint(256);break;case"expression:literal:boolean":s=k.Elementary.bool();break;case"expression:literal:string":s=k.Elementary.string();break;case"expression:literal:address":s=k.Elementary.address();break;case"expression:literal:hex":{const t=e.value.startsWith("0x")?e.value.slice(2):e.value,n=Math.ceil(t.length/2);s=n>0&&n<=32?k.Elementary.bytes(n):k.Elementary.bytes();break}}return s&&n.set(e.id,s),{type:s,symbols:t.symbols,nodeTypes:n,bindings:t.bindings,errors:[]}}if(f.isOperator(e)){const n=[];let s=new Map(t.nodeTypes),o=t.symbols,i=t.bindings;const r=[];for(let c=0;c<e.operands.length;c++){const a={...t,nodeTypes:s,symbols:o,bindings:i},l=g(t.visitor,e.operands[c],a);s=l.nodeTypes,o=l.symbols,i=l.bindings,n.push(...l.errors),l.type&&r.push(l.type)}if(r.length!==e.operands.length)return{symbols:o,nodeTypes:s,bindings:i,errors:n};let a;if(1===e.operands.length){const t=r[0];switch(e.operator){case"!":if(!k.Elementary.isBool(t)){const t=new Ge(qe("!","boolean"),e.loc||void 0,void 0,void 0,Ve.INVALID_OPERAND);n.push(t)}a=k.Elementary.bool();break;case"-":if(!k.isElementary(t)||!k.Elementary.isNumeric(t)){const t=new Ge(qe("-","numeric"),e.loc||void 0,void 0,void 0,Ve.INVALID_OPERAND);n.push(t)}a=t;break;default:{const t=new Ge(`Unknown unary operator: ${e.operator}`,e.loc||void 0,void 0,void 0,Ve.INVALID_OPERATION);n.push(t);break}}}else if(2===e.operands.length){const[t,s]=r;switch(e.operator){case"+":case"-":case"*":case"/":if(!(k.isElementary(t)&&k.isElementary(s)&&k.Elementary.isNumeric(t)&&k.Elementary.isNumeric(s))){const t=new Ge(We(e.operator,"numeric"),e.loc||void 0,void 0,void 0,Ve.INVALID_OPERAND);n.push(t)}a=it(t,s)||void 0;break;case"<":case">":case"<=":case">=":if(!(k.isElementary(t)&&k.isElementary(s)&&k.Elementary.isNumeric(t)&&k.Elementary.isNumeric(s))){const t=new Ge(We(e.operator,"numeric"),e.loc||void 0,void 0,void 0,Ve.INVALID_OPERAND);n.push(t)}a=k.Elementary.bool();break;case"==":case"!=":if(!ot(t,s)){const o=new Ge(`Cannot compare ${k.format(t)} with ${k.format(s)}`,e.loc||void 0,void 0,void 0,Ve.INVALID_OPERATION);n.push(o)}a=k.Elementary.bool();break;case"&&":case"||":if(!k.Elementary.isBool(t)||!k.Elementary.isBool(s)){const t=new Ge(We(e.operator,"boolean"),e.loc||void 0,void 0,void 0,Ve.INVALID_OPERAND);n.push(t)}a=k.Elementary.bool();break;default:{const t=new Ge(`Unknown binary operator: ${e.operator}`,e.loc||void 0,void 0,void 0,Ve.INVALID_OPERATION);n.push(t);break}}}else!function(e){throw new Ge("Unexpected code path; expected exhaustive conditionals",void 0,B.Error,Ve.INTERNAL_ERROR)}(e.operands);return a&&s.set(e.id,a),{type:a,symbols:o,nodeTypes:s,bindings:i,errors:n}}if(f.isAccess(e)){const n=[];let s=new Map(t.nodeTypes),o=t.symbols,i=t.bindings;const r={...t,nodeTypes:s,symbols:o,bindings:i},a=g(t.visitor,e.object,r);if(s=a.nodeTypes,o=a.symbols,i=a.bindings,n.push(...a.errors),!a.type)return{symbols:o,nodeTypes:s,bindings:i,errors:n};const c=a.type;let l;if(f.Access.isMember(e)){const t=e.property;if(k.isStruct(c)){const r=c.fields.get(t);if(!r){const r=new Ge(Ke(c.name,t),e.loc||void 0,void 0,void 0,Ve.NO_SUCH_FIELD);return n.push(r),{symbols:o,nodeTypes:s,bindings:i,errors:n}}l=r}else{if("length"!==t){const r=new Ge(`Cannot access member ${t} on ${k.format(c)}`,e.loc||void 0,void 0,void 0,Ve.INVALID_OPERATION);return n.push(r),{symbols:o,nodeTypes:s,bindings:i,errors:n}}if(k.isArray(c))l=k.Elementary.uint(256);else{if(!k.isElementary(c)||!k.Elementary.isBytes(c)&&!k.Elementary.isString(c)){const t=new Ge(`Type ${k.format(c)} does not have a length property`,e.loc||void 0,void 0,void 0,Ve.INVALID_OPERATION);return n.push(t),{symbols:o,nodeTypes:s,bindings:i,errors:n}}l=k.Elementary.uint(256)}}}else if(f.Access.isSlice(e)){const r=e.start,a=e.end,u={...t,nodeTypes:s,symbols:o,bindings:i},d=g(t.visitor,r,u);s=d.nodeTypes,o=d.symbols,i=d.bindings,n.push(...d.errors);const p={...t,nodeTypes:s,symbols:o,bindings:i},m=g(t.visitor,a,p);if(s=m.nodeTypes,o=m.symbols,i=m.bindings,n.push(...m.errors),!d.type||!m.type)return{symbols:o,nodeTypes:s,bindings:i,errors:n};if(!k.isElementary(c)||!k.Elementary.isBytes(c)){const t=new Ge(`Cannot slice ${k.format(c)} - only bytes types can be sliced`,e.loc||void 0,void 0,void 0,Ve.INVALID_OPERATION);return n.push(t),{symbols:o,nodeTypes:s,bindings:i,errors:n}}if(!k.isElementary(d.type)||!k.Elementary.isNumeric(d.type)){const e=new Ge("Slice start index must be numeric",r.loc||void 0,void 0,void 0,Ve.INVALID_INDEX_TYPE);n.push(e)}if(!k.isElementary(m.type)||!k.Elementary.isNumeric(m.type)){const e=new Ge("Slice end index must be numeric",a.loc||void 0,void 0,void 0,Ve.INVALID_INDEX_TYPE);n.push(e)}l=k.Elementary.bytes()}else{const r=e.index,a={...t,nodeTypes:s,symbols:o,bindings:i},u=g(t.visitor,r,a);if(s=u.nodeTypes,o=u.symbols,i=u.bindings,n.push(...u.errors),!u.type)return{symbols:o,nodeTypes:s,bindings:i,errors:n};const d=u.type;if(k.isArray(c)){if(!k.isElementary(d)||!k.Elementary.isNumeric(d)){const e=new Ge("Array index must be numeric",r.loc||void 0,void 0,void 0,Ve.INVALID_INDEX_TYPE);n.push(e)}l=c.element}else if(k.isMapping(c)){if(!ot(c.key,d)){const e=new Ge(`Invalid mapping key: expected ${k.format(c.key)}, got ${k.format(d)}`,r.loc||void 0,void 0,void 0,Ve.TYPE_MISMATCH);n.push(e)}l=c.value}else{if(!k.isElementary(c)||!k.Elementary.isBytes(c)){const t=new Ge(Ye(k.format(c)),e.loc||void 0,void 0,void 0,Ve.NOT_INDEXABLE);return n.push(t),{symbols:o,nodeTypes:s,bindings:i,errors:n}}if(!ot(k.Elementary.uint(8),d)){const e=new Ge(`Bytes index must be a numeric type, got ${k.format(d)}`,r.loc||void 0,void 0,void 0,Ve.TYPE_MISMATCH);n.push(e)}l=k.Elementary.uint(8)}}return l&&s.set(e.id,l),{type:l,symbols:o,nodeTypes:s,bindings:i,errors:n}}if(f.isCall(e)){const n=[];let s=new Map(t.nodeTypes),o=t.symbols,i=t.bindings;if("expression:identifier"===e.callee.kind){const r=e.callee.name;if("keccak256"===r){if(1!==e.arguments.length){const t=new Ge("keccak256 expects exactly 1 argument",e.loc||void 0,void 0,void 0,Ve.INVALID_ARGUMENT_COUNT);return n.push(t),{symbols:o,nodeTypes:s,bindings:i,errors:n}}const r={...t,nodeTypes:s,symbols:o,bindings:i},a=g(t.visitor,e.arguments[0],r);if(s=a.nodeTypes,o=a.symbols,i=a.bindings,n.push(...a.errors),!a.type)return{symbols:o,nodeTypes:s,bindings:i,errors:n};if(!k.Elementary.isBytes(a.type)&&!k.Elementary.isString(a.type)){const t=new Ge("keccak256 argument must be bytes or string type",e.arguments[0].loc||void 0,void 0,void 0,Ve.TYPE_MISMATCH);return n.push(t),{symbols:o,nodeTypes:s,bindings:i,errors:n}}const c=k.Elementary.bytes(32);return s.set(e.id,c),{type:c,symbols:o,nodeTypes:s,bindings:i,errors:n}}const a=o.lookup(r);if(!a){const t=new Ge(Fe(r),e.callee.loc||void 0,void 0,void 0,Ve.UNDEFINED_VARIABLE);return n.push(t),{symbols:o,nodeTypes:s,bindings:i,errors:n}}if(i=I(i,e.callee.id,a.declaration),!k.isFunction(a.type)){const t=new Ge(`${r} is not a function`,e.callee.loc||void 0,void 0,void 0,Ve.TYPE_MISMATCH);return n.push(t),{symbols:o,nodeTypes:s,bindings:i,errors:n}}const c=a.type;if(e.arguments.length!==c.parameters.length){const t=new Ge(`Function ${c.name} expects ${c.parameters.length} arguments but got ${e.arguments.length}`,e.loc||void 0,void 0,void 0,Ve.INVALID_ARGUMENT_COUNT);return n.push(t),{symbols:o,nodeTypes:s,bindings:i,errors:n}}for(let u=0;u<e.arguments.length;u++){const r={...t,nodeTypes:s,symbols:o,bindings:i},a=g(t.visitor,e.arguments[u],r);if(s=a.nodeTypes,o=a.symbols,i=a.bindings,n.push(...a.errors),!a.type)continue;const l=c.parameters[u];if(!ot(l,a.type)){const t=new Ge(`Argument ${u+1} type mismatch: expected ${k.format(l)}, got ${k.format(a.type)}`,e.arguments[u].loc||void 0,k.format(l),k.format(a.type),Ve.TYPE_MISMATCH);n.push(t)}}const l=c.return||k.failure("void function");return s.set(e.id,l),{type:l,symbols:o,nodeTypes:s,bindings:i,errors:n}}const r=new Ge("Complex function call expressions not yet supported",e.loc||void 0,void 0,void 0,Ve.INVALID_OPERATION);return n.push(r),{symbols:o,nodeTypes:s,bindings:i,errors:n}}if(f.isCast(e)){const n=[];let s=new Map(t.nodeTypes),o=t.symbols,i=t.bindings;const r={...t,nodeTypes:s,symbols:o,bindings:i},a=g(t.visitor,e.expression,r);if(s=a.nodeTypes,o=a.symbols,i=a.bindings,n.push(...a.errors),!a.type)return{symbols:o,nodeTypes:s,bindings:i,errors:n};const c={...t,nodeTypes:s,symbols:o,bindings:i},l=g(t.visitor,e.targetType,c);if(s=l.nodeTypes,o=l.symbols,i=l.bindings,n.push(...l.errors),!l.type)return{symbols:o,nodeTypes:s,bindings:i,errors:n};if(!function(e,t){if(k.isElementary(e)&&k.isElementary(t)&&k.Elementary.isNumeric(e)&&k.Elementary.isNumeric(t))return!0;if(k.Elementary.isUint(e)&&k.Elementary.isAddress(t))return!0;if(k.Elementary.isAddress(e)&&k.Elementary.isUint(t))return!0;if(k.Elementary.isBytes(e)&&k.Elementary.isBytes(t))return!0;if(k.Elementary.isString(e)&&k.Elementary.isBytes(t))return!0;if(k.Elementary.isBytes(e)&&k.Elementary.isString(t))return!0;if(k.Elementary.isBytes(e)&&k.Elementary.isAddress(t))return!0;if(k.isElementary(e)&&k.isElementary(t)&&k.Elementary.isBytes(e)&&k.Elementary.isNumeric(t))return!0;return!1}(a.type,l.type)){const t=new Ge(`Cannot cast from ${k.format(a.type)} to ${k.format(l.type)}`,e.loc||void 0,k.format(l.type),k.format(a.type),Ve.INVALID_TYPE_CAST);return n.push(t),{symbols:o,nodeTypes:s,bindings:i,errors:n}}return s.set(e.id,l.type),{type:l.type,symbols:o,nodeTypes:s,bindings:i,errors:n}}if(f.isArray(e)){const n=[];let s=new Map(t.nodeTypes),o=t.symbols,i=t.bindings;const r=[];for(let l=0;l<e.elements.length;l++){const a={...t,nodeTypes:s,symbols:o,bindings:i},c=g(t.visitor,e.elements[l],a);s=c.nodeTypes,o=c.symbols,i=c.bindings,n.push(...c.errors),c.type&&r.push(c.type)}if(r.length!==e.elements.length)return{symbols:o,nodeTypes:s,bindings:i,errors:n};let a;if(r.length>0){a=r[0];for(let t=1;t<r.length;t++){const c=it(a,r[t]);if(!c){const c=new Ge(`Array elements must have compatible types. Element at index ${t} has type ${k.format(r[t])} which is incompatible with ${k.format(a)}`,e.loc||void 0,void 0,void 0,Ve.TYPE_MISMATCH);return n.push(c),{symbols:o,nodeTypes:s,bindings:i,errors:n}}a=c}}else a=k.Elementary.uint(256);const c=k.array(a);return s.set(e.id,c),{type:c,symbols:o,nodeTypes:s,bindings:i,errors:n}}if(f.isStruct(e)){const n=[];let s,o=new Map(t.nodeTypes),i=t.symbols,r=t.bindings;if(e.structName){const t=i.lookup(e.structName);if(!t||!k.isStruct(t.type)){const t=new Ge(`${e.structName} is not a struct type`,e.loc||void 0,void 0,void 0,Ve.TYPE_MISMATCH);return n.push(t),{symbols:i,nodeTypes:o,bindings:r,errors:n}}s=t.type}const a=new Map;for(let c=0;c<e.fields.length;c++){const s=e.fields[c],l={...t,nodeTypes:o,symbols:i,bindings:r},u=g(t.visitor,s.value,l);if(o=u.nodeTypes,i=u.symbols,r=u.bindings,n.push(...u.errors),u.type)if(a.has(s.name)){const t=new Ge(`Duplicate field ${s.name} in struct literal`,e.loc||void 0,void 0,void 0,Ve.TYPE_MISMATCH);n.push(t)}else a.set(s.name,u.type)}if(s&&k.isStruct(s)){for(const[t,o]of s.fields){const s=a.get(t);if(s){if(!ot(o,s)){const i=new Ge(`Field ${t} type mismatch: expected ${k.format(o)}, got ${k.format(s)}`,e.loc||void 0,k.format(o),k.format(s),Ve.TYPE_MISMATCH);n.push(i)}}else{const s=new Ge(`Missing field ${t} in struct literal`,e.loc||void 0,void 0,void 0,Ve.TYPE_MISMATCH);n.push(s)}}for(const t of a.keys())if(!s.fields.has(t)){const s=new Ge(`Unknown field ${t} in struct literal`,e.loc||void 0,void 0,void 0,Ve.TYPE_MISMATCH);n.push(s)}return o.set(e.id,s),{type:s,symbols:i,nodeTypes:o,bindings:r,errors:n}}{const t=k.struct("anonymous",a,new Map);return o.set(e.id,t),{type:t,symbols:i,nodeTypes:o,bindings:r,errors:n}}}if(f.isSpecial(e)){let n;switch(e.kind){case"expression:special:msg.sender":n=k.Elementary.address();break;case"expression:special:msg.value":case"expression:special:block.timestamp":case"expression:special:block.number":n=k.Elementary.uint(256);break;case"expression:special:msg.data":n=k.Elementary.bytes()}const s=new Map(t.nodeTypes);return n&&s.set(e.id,n),{type:n,symbols:t.symbols,nodeTypes:s,bindings:t.bindings,errors:[]}}throw new Error("Unknown expression kind")}};const at=[rt,{statement(e,t){if(p.isDeclare(e))return g(t.visitor,e.declaration,t);if(p.isExpress(e)){const n={...t};return g(t.visitor,e.expression,n)}if(p.isAssign(e)){const n=[];let s=new Map(t.nodeTypes),o=t.symbols,i=t.bindings;if(!f.isAssignable(e.target)){const t=new Ge("Invalid assignment target",e.target.loc||void 0,void 0,void 0,Ve.INVALID_ASSIGNMENT);return n.push(t),{symbols:o,nodeTypes:s,bindings:i,errors:n}}const r={...t,nodeTypes:s,symbols:o,bindings:i},a=g(t.visitor,e.target,r);s=a.nodeTypes,o=a.symbols,i=a.bindings,n.push(...a.errors);const c={...t,nodeTypes:s,symbols:o,bindings:i},l=g(t.visitor,e.value,c);if(s=l.nodeTypes,o=l.symbols,i=l.bindings,n.push(...l.errors),a.type&&l.type&&!ot(a.type,l.type)){const t=new Ge(ze(k.format(a.type),k.format(l.type)),e.loc||void 0,k.format(a.type),k.format(l.type),Ve.TYPE_MISMATCH);n.push(t)}return{symbols:o,nodeTypes:s,bindings:i,errors:n}}if(p.isControlFlow(e)){const n=[];let s=new Map(t.nodeTypes),o=t.symbols,i=t.bindings;switch(e.kind){case"statement:control-flow:if":if(e.condition){const r={...t,nodeTypes:s,symbols:o,bindings:i},a=g(t.visitor,e.condition,r);if(s=a.nodeTypes,o=a.symbols,i=a.bindings,n.push(...a.errors),a.type&&!k.Elementary.isBool(a.type)){const t=new Ge("If condition must be boolean",e.condition.loc||void 0,void 0,void 0,Ve.INVALID_CONDITION);n.push(t)}}if(e.body){const r={...t,nodeTypes:s,symbols:o,bindings:i},a=g(t.visitor,e.body,r);s=a.nodeTypes,o=a.symbols,i=a.bindings,n.push(...a.errors)}if(e.alternate){const r={...t,nodeTypes:s,symbols:o,bindings:i},a=g(t.visitor,e.alternate,r);s=a.nodeTypes,o=a.symbols,i=a.bindings,n.push(...a.errors)}return{symbols:o,nodeTypes:s,bindings:i,errors:n};case"statement:control-flow:for":if(o=o.enterScope(),e.init){const r={...t,nodeTypes:s,symbols:o,bindings:i},a=g(t.visitor,e.init,r);s=a.nodeTypes,o=a.symbols,i=a.bindings,n.push(...a.errors)}if(e.condition){const r={...t,nodeTypes:s,symbols:o,bindings:i},a=g(t.visitor,e.condition,r);if(s=a.nodeTypes,o=a.symbols,i=a.bindings,n.push(...a.errors),a.type&&!k.Elementary.isBool(a.type)){const t=new Ge("For condition must be boolean",e.condition.loc||void 0,void 0,void 0,Ve.INVALID_CONDITION);n.push(t)}}if(e.update){const r={...t,nodeTypes:s,symbols:o,bindings:i},a=g(t.visitor,e.update,r);s=a.nodeTypes,o=a.symbols,i=a.bindings,n.push(...a.errors)}if(e.body){const r={...t,nodeTypes:s,symbols:o,bindings:i},a=g(t.visitor,e.body,r);s=a.nodeTypes,o=a.symbols,i=a.bindings,n.push(...a.errors)}return o=o.exitScope(),{symbols:o,nodeTypes:s,bindings:i,errors:n};case"statement:control-flow:return":if(e.value){const r={...t,nodeTypes:s,symbols:o,bindings:i},a=g(t.visitor,e.value,r);if(s=a.nodeTypes,o=a.symbols,i=a.bindings,n.push(...a.errors),a.type&&t.currentReturnType){if(!ot(t.currentReturnType,a.type)){const s=new Ge(ze(k.format(t.currentReturnType),k.format(a.type)),e.loc||void 0,k.format(t.currentReturnType),k.format(a.type),Ve.TYPE_MISMATCH);n.push(s)}}else if(a.type&&!t.currentReturnType){const t=new Ge("Cannot return a value from a void function",e.loc||void 0,void 0,void 0,Ve.TYPE_MISMATCH);n.push(t)}}else if(t.currentReturnType){const s=new Ge(`Function must return a value of type ${k.format(t.currentReturnType)}`,e.loc||void 0,void 0,void 0,Ve.TYPE_MISMATCH);n.push(s)}return{symbols:o,nodeTypes:s,bindings:i,errors:n};default:return{symbols:o,nodeTypes:s,bindings:i,errors:n}}}throw new Error("Unexpected statement")}},{program(e,t){let n=t.symbols,s=t.nodeTypes,o=t.bindings;const i=[];if(e.storage)for(const r of e.storage){const e={...t,symbols:n,nodeTypes:s,bindings:o,visitor:t.visitor},a=g(e.visitor,r,e);s=a.nodeTypes,o=a.bindings,i.push(...a.errors)}if(e.definitions){for(let r=0;r<e.definitions.items.length;r++){const a=e.definitions.items[r];if("declaration:function"===a.kind||"declaration:struct"===a.kind){const e={...t,symbols:n,nodeTypes:s,bindings:o,visitor:t.visitor},r=g(e.visitor,a,e);if(s=r.nodeTypes,o=r.bindings,i.push(...r.errors),"declaration:struct"===a.kind)for(const t of a.fields){const n=g(e.visitor,t,{...e,bindings:o});o=n.bindings,i.push(...n.errors)}}}for(let r=0;r<e.definitions.items.length;r++){const a=e.definitions.items[r];if(c.isFunction(a)){const e=n.lookup(a.name)?.type;if(e){const r=st(n,a,e),c={...t,symbols:r,currentReturnType:e.return||void 0,nodeTypes:s,bindings:o,visitor:t.visitor},l=g(c.visitor,a.body,c);s=l.nodeTypes,o=l.bindings,i.push(...l.errors)}}}}if(e.create){const r={...t,symbols:n,nodeTypes:s,bindings:o},a=g(r.visitor,e.create,r);n=a.symbols,s=a.nodeTypes,o=a.bindings,i.push(...a.errors)}if(e.body){const r={...t,symbols:n,nodeTypes:s,bindings:o},a=g(r.visitor,e.body,r);n=a.symbols,s=a.nodeTypes,o=a.bindings,i.push(...a.errors)}return{symbols:n,nodeTypes:s,bindings:o,errors:i}},block(e,t){if("block:statements"===e.kind){let n=t.symbols.enterScope(),s=t.nodeTypes,o=t.bindings;const i=[];for(let r=0;r<e.items.length;r++){const a=e.items[r],c={...t,symbols:n,nodeTypes:s,bindings:o},l=g(c.visitor,a,c);n=l.symbols,s=l.nodeTypes,o=l.bindings,i.push(...l.errors)}return{symbols:n.exitScope(),nodeTypes:s,bindings:o,errors:i}}if("block:definitions"===e.kind){let n=t.symbols,s=t.nodeTypes,o=t.bindings;const i=[];for(let r=0;r<e.items.length;r++){const a=e.items[r],c={...t,symbols:n,nodeTypes:s,bindings:o},l=g(c.visitor,a,c);n=l.symbols,s=l.nodeTypes,o=l.bindings,i.push(...l.errors)}return{symbols:n,nodeTypes:s,bindings:o,errors:i}}return{symbols:t.symbols,nodeTypes:t.nodeTypes,bindings:t.bindings,errors:[]}},declaration(e,t){const n=[];let s=new Map(t.nodeTypes),o=t.symbols,i=t.bindings;switch(e.kind){case"declaration:struct":default:return{symbols:o,nodeTypes:s,bindings:i,errors:n};case"declaration:function":{const r=o.lookup(e.name);r&&s.set(e.id,r.type);for(const n of e.parameters)if(n.type){i=et(n.type,t.structs,i).bindings}if(e.returnType){i=et(e.returnType,t.structs,i).bindings}return{type:r?.type,symbols:o,nodeTypes:s,bindings:i,errors:n}}case"declaration:storage":{const r=o.lookup(e.name);if(r&&s.set(e.id,r.type),e.type){i=et(e.type,t.structs,i).bindings}return{type:r?.type,symbols:o,nodeTypes:s,bindings:i,errors:n}}case"declaration:variable":{if(!e.initializer){const t=new Ge(`Variable ${e.name} must have an initializer`,e.loc||void 0,void 0,void 0,Ve.MISSING_INITIALIZER);n.push(t);const r=k.failure("missing initializer"),a={name:e.name,type:r,mutable:!0,location:"memory",declaration:e};return o=o.define(a),s.set(e.id,r),{type:r,symbols:o,nodeTypes:s,bindings:i,errors:n}}const r={...t,nodeTypes:s,bindings:i},a=g(r.visitor,e.initializer,r);let c;if(s=a.nodeTypes,i=a.bindings,n.push(...a.errors),e.type){const s=et(e.type,t.structs,i);if(c=s.type,i=s.bindings,a.type&&!ot(c,a.type)){const t=new Ge(ze(k.format(c),k.format(a.type)),e.initializer.loc||void 0,k.format(c),k.format(a.type),Ve.TYPE_MISMATCH);n.push(t)}}else c=a.type||k.failure("invalid initializer");const l={name:e.name,type:c,mutable:!0,location:"memory",declaration:e};return o=o.define(l),s.set(e.id,c),{type:c,symbols:o,nodeTypes:s,bindings:i,errors:n}}case"declaration:field":if(e.type){i=et(e.type,t.structs,i).bindings}return{symbols:o,nodeTypes:s,bindings:i,errors:n}}}},{type(e,t){if(u.isElementary(e)){const n=[],s=new Map(t.nodeTypes);let o;if(u.Elementary.isUint(e)){o={256:k.Elementary.uint(256),128:k.Elementary.uint(128),64:k.Elementary.uint(64),32:k.Elementary.uint(32),16:k.Elementary.uint(16),8:k.Elementary.uint(8)}[e.bits||256]||k.failure(`Unknown uint size: ${e.bits}`)}else if(u.Elementary.isInt(e)){o={256:k.Elementary.int(256),128:k.Elementary.int(128),64:k.Elementary.int(64),32:k.Elementary.int(32),16:k.Elementary.int(16),8:k.Elementary.int(8)}[e.bits||256]||k.failure(`Unknown int size: ${e.bits}`)}else o=u.Elementary.isBytes(e)?e.size?k.Elementary.bytes(e.size):k.Elementary.bytes():u.Elementary.isAddress(e)?k.Elementary.address():u.Elementary.isBool(e)?k.Elementary.bool():u.Elementary.isString(e)?k.Elementary.string():k.failure(`Unknown elementary type: ${e.kind}`);return o&&s.set(e.id,o),{type:o,symbols:t.symbols,nodeTypes:s,bindings:t.bindings,errors:n}}if(u.isComplex(e)){const n=[];let s,o=new Map(t.nodeTypes),i=t.symbols,r=t.bindings;if(u.Complex.isArray(e)){const a={...t,nodeTypes:o,symbols:i,bindings:r},c=g(t.visitor,e.element,a);o=c.nodeTypes,i=c.symbols,r=c.bindings,n.push(...c.errors),c.type&&(s=k.array(c.type,e.size))}else if(u.Complex.isMapping(e)){const a={...t,nodeTypes:o,symbols:i,bindings:r},c=g(t.visitor,e.key,a);o=c.nodeTypes,i=c.symbols,r=c.bindings,n.push(...c.errors);const l={...t,nodeTypes:o,symbols:i,bindings:r},u=g(t.visitor,e.value,l);o=u.nodeTypes,i=u.symbols,r=u.bindings,n.push(...u.errors),c.type&&u.type&&(s=k.mapping(c.type,u.type))}else s=k.failure(`Unsupported complex type: ${e.kind}`);return s&&o.set(e.id,s),{type:s,symbols:i,nodeTypes:o,bindings:r,errors:n}}const n=[],s=new Map(t.nodeTypes);let o;const i=t.structs.get(e.name);if(i)o=i.type;else{const t=new Ge(He(e.name),e.loc||void 0,void 0,void 0,Ve.UNDEFINED_TYPE);n.push(t),o=k.failure(`Undefined struct: ${e.name}`)}return o&&s.set(e.id,o),{type:o,symbols:t.symbols,nodeTypes:s,bindings:t.bindings,errors:n}}}].reduce(((e,t)=>({...e,...t})),{});function ct(e){const t=function(e){const t=new Map,n=new Map,s=[];for(const i of e.definitions?.items||[])if(c.isStruct(i))try{const e=Xe(i,t);t.set(i.name,{node:i,type:e})}catch(o){o instanceof Ge&&s.push(o)}for(const i of e.definitions?.items||[])if(c.isFunction(i))try{const e=Qe(i,t);n.set(i.name,{node:i,type:e})}catch(o){o instanceof Ge&&s.push(o)}return s.length>0?L.err(s):L.ok({structs:t,functions:n})}(e);if(!t.success)return t;const n=function(e,{functions:t,structs:n}){let s=nt.empty();const o=[];for(const[i,r]of t){const e={name:i,type:r.type,mutable:!1,location:"memory",declaration:r.node};s=s.define(e)}for(const i of e.storage||[]){const e=i.type?tt(i.type,n):k.failure("missing type"),t={name:i.name,type:e,mutable:!0,location:"storage",slot:i.slot,declaration:i};s=s.define(t)}return o.length>0?L.err(o):L.ok(s)}(e,t.value);if(!n.success)return n;const s={symbols:n.value,structs:t.value.structs,nodeTypes:new Map,bindings:new Map,visitor:at},o=g(at,e,s);return o.errors.length>0?L.err([...o.errors]):L.ok({types:o.nodeTypes,bindings:o.bindings})}var lt;!function(e){e.INVALID_NODE="IR001",e.UNKNOWN_IDENTIFIER="IR002",e.INTERNAL_ERROR="IR003",e.UNSUPPORTED_FEATURE="IR004",e.INVALID_LVALUE="IR005",e.STORAGE_ACCESS_ERROR="IR006",e.UNKNOWN_TYPE="IR007",e.INVALID_ARGUMENT_COUNT="IR008",e.MISSING_RETURN="IR009",e.GENERAL="IR_ERROR"}(lt||(lt={}));const ut=e=>`Unknown identifier: ${e}`;class dt extends R{constructor(e,t,n=B.Error,s=lt.GENERAL){super(e,s,t,n)}}function pt(e){throw new dt("Unexpected code path; expected exhaustive conditionals",void 0,B.Error,lt.INTERNAL_ERROR)}var mt;!function(e){let t,n,s,o,i,r,a,c,l;!function(e){const t=bt((e=>t=>e(t.types)));e.nodeType=e=>t((t=>t.get(e.id)))}(t=e.Types||(e.Types={})),function(e){const t=gt((e=>t=>({...t,module:e(t.module)})));e.main=Symbol("main"),e.create=Symbol("create"),e.addFunction=(n,s)=>t((t=>({...t,...n!==e.main&&n!==e.create?{functions:new Map([...t.functions,[n.toString(),s]])}:{},...n===e.main?{main:s}:{},...n===e.create?{create:s}:{}})))}(n=e.Module||(e.Module={})),function(e){const t=gt((e=>t=>({...t,function:e(t.function)})));e.addParameter=e=>t((t=>({...t,parameters:[...t.parameters,e]}))),e.addBlock=(e,n)=>t((t=>({...t,blocks:new Map([...t.blocks,[e,n]])})))}(s=e.Function||(e.Function={})),function(t){const n=gt((e=>t=>({...t,block:e(t.block)}))),s=bt((e=>({block:t})=>e(t)));t.emit=e=>n((t=>({...t,instructions:[...t.instructions,e]}))),t.terminator=()=>s((e=>e.terminator)),t.setTerminator=t=>e.Errors.attempt(n((e=>{if(e.terminator)throw new dt(`Block ${e.id} already has terminator`,void 0,B.Warning);return{...e,terminator:t}}))),t.addPhi=e=>n((t=>({...t,phis:[...t.phis,e]})))}(o=e.Block||(e.Block={})),function(t){t.update=gt((e=>t=>({...t,scopes:e(t.scopes)}))),t.extract=bt((e=>t=>e(t.scopes))),t.push=()=>t.update((e=>({stack:[...e.stack,{ssaVars:new Map,usedNames:new Map}]}))),t.pop=()=>e.Errors.attempt(t.update((e=>{if(e.stack.length<=1)throw new dt("Cannot pop last scope",void 0,B.Error);return{stack:e.stack.slice(0,-1)}}))),t.current=()=>t.extract((e=>e.stack.at(-1))),t.setCurrent=e=>t.update((t=>({stack:[...t.stack.slice(0,-1),e]}))),t.lookupVariable=e=>t.extract((t=>{for(let n=t.stack.length-1;n>=0;n--){const s=t.stack[n].ssaVars.get(e);if(s)return s}return null}))}(i=e.Scopes||(e.Scopes={})),function(t){const n=gt((e=>t=>({...t,loops:e(t.loops)})));t.push=(e,t)=>n((n=>({stack:[...n.stack,{continueTarget:e,breakTarget:t}]}))),t.pop=()=>e.Errors.attempt(n((e=>{if(e.stack.length<1)throw new dt("Cannot exit loop if not currently inside a loop",void 0,B.Error);return{stack:e.stack.slice(0,-1)}})))}(r=e.Loops||(e.Loops={})),function(e){const t=gt((e=>t=>({...t,counters:e(t.counters)}))),n=bt((e=>t=>e(t.counters)));e.nextTemp=()=>n((({temp:e})=>e)),e.consumeTemp=()=>t((e=>({...e,temp:e.temp+1}))),e.nextBlock=()=>n((({block:e})=>e)),e.consumeBlock=()=>t((e=>({...e,block:e.block+1})))}(a=e.Counters||(e.Counters={})),function(t){const n=gt((e=>t=>({...t,errors:e(t.errors)}))),s=bt((e=>t=>e(t.errors)));t.count=()=>s((e=>e.length)),t.append=e=>n((t=>[...t,e])),t.attempt=gt((t=>n=>{try{return t(n)}catch(s){if(s instanceof dt)return e.Errors.append(s)(n);throw s}}))}(c=e.Errors||(e.Errors={})),function(e){const t=gt((e=>t=>({...t,warnings:e(t.warnings)})));e.append=e=>t((t=>[...t,e]))}(l=e.Warnings||(e.Warnings={}))}(mt||(mt={}));const ft=Symbol("modify"),yt=Symbol("read");function gt(e){return t=>{const n=e(t);return Object.assign(n,{[ft]:!0})}}function bt(e){return t=>{const n=e(t);return Object.assign(n,{[yt]:!0})}}function ht(e){switch(e.kind){case"storage":return{location:"storage",slot:Number(e.slot)};case"storage-computed":return{location:"storage",slot:e.expression};case"memory":return{location:"memory",offset:Number(e.offset),length:Number(e.length)};case"memory-computed":return{location:"memory",offset:e.offsetExpression,length:e.lengthExpression};case"calldata":return{location:"calldata",offset:Number(e.offset),length:Number(e.length)};case"transient":return{location:"transient",slot:Number(e.slot)};case"stack":case"unknown":return}}function kt(e){if(k.isElementary(e))return function(e){const{kind:t}=e;switch(t){case"uint":return{kind:"uint",bits:e.bits};case"int":return{kind:"int",bits:e.bits};case"address":return{kind:"address"};case"bool":return{kind:"bool"};case"bytes":return void 0!==e.size?{kind:"bytes",size:e.size}:{kind:"bytes"};case"string":return{kind:"string"};default:return}}(e);if(k.isArray(e)){const t=kt(e.element);if(!t)return;return{kind:"array",contains:{type:t},...void 0!==e.size&&{length:e.size}}}if(k.isMapping(e)){const t=kt(e.key),n=kt(e.value);if(!t||!n)return;return{kind:"mapping",contains:{key:{type:t},value:{type:n}}}}if(k.isStruct(e)){const t=[];for(const[n,s]of e.fields){const e=kt(s);e&&t.push({name:n,type:e})}return{kind:"struct",contains:t}}k.isFunction(e)}function vt(e){if(k.isElementary(e))switch(e.kind){case"uint":case"int":return(e.bits||256)/8;case"address":return 20;case"bool":return 1;case"bytes":return e.size||32;default:return 32}return 32}function xt(e,t,n=0){if(k.isStruct(t)){const s=[];for(const[o,i]of t.fields){const r=t.layout.get(o);if(!r)continue;const a=n+r.byteOffset,c=xt(e+Math.floor(a/32),i,a%32);c&&s.push({...c,name:o})}if(0===s.length)return;return{group:s}}if(k.isArray(t)){const s=t.element,o=vt(s);if(void 0!==t.size){const n={name:"element",location:"storage",slot:o>=32?{$sum:[e,{$product:["i",o/32]}]}:{$sum:[e,{$quotient:[{$product:["i",o]},32]}]}};o<32&&(n.offset={$remainder:[{$product:["i",o]},32]},n.length=o);const i=k.isStruct(s)||k.isArray(s)?xt(0,s,0):n;return{list:{count:t.size,each:"i",is:i||n}}}{const t={name:"element",location:"storage",slot:o>=32?{$sum:[{$keccak256:[{$wordsized:e}]},{$product:["i",o/32]}]}:{$sum:[{$keccak256:[{$wordsized:e}]},{$quotient:[{$product:["i",o]},32]}]}};o<32&&(t.offset={$remainder:[{$product:["i",o]},32]},t.length=o);const i=k.isStruct(s)||k.isArray(s)?xt(0,s,0):t,r={name:"array-length",location:"storage",slot:e};return n>0&&(r.offset=n),{group:[r,{list:{count:{$read:"array-length"},each:"i",is:i||t}}]}}}if(k.isMapping(t)){const t={location:"storage",slot:e};return n>0&&(t.offset=n),t}const s=vt(t),o={location:"storage",slot:e};return n>0&&(o.offset=n),s<32&&(o.length=s),o}function wt(e,t){const n=[];for(const s of e.module.storageDeclarations){const o=e.types.get(s.id);if(!o){const e=ht({kind:"storage",slot:s.slot});e&&n.push({identifier:s.name,pointer:e,declaration:s.loc?{source:{id:t},range:s.loc}:void 0});continue}const i=xt(s.slot,o);if(!i)continue;const r=kt(o),a=s.loc?{source:{id:t},range:s.loc}:void 0;n.push({identifier:s.name,type:r,pointer:i,declaration:a})}return n}function Tt(e){const t={identifier:e.identifier};return e.type&&(t.type=e.type),e.pointer&&(t.pointer=e.pointer),e.declaration&&(t.declaration=e.declaration),t}var Et;function St(e){return function*(...t){const n=e(...t);if(!function(e){return"function"==typeof e&&ft in e}(n))return function(e){return"function"==typeof e&&yt in e}(n)?n(yield{type:"peek"}):void pt();yield{type:"modify",fn:n}}}function It(e){if(k.isFailure(e)||k.isFunction(e))throw new dt(`Cannot convert type with kind ${e.kind} to IR type`,void 0,B.Error,lt.UNKNOWN_TYPE);if(k.isArray(e))return v.ref("memory",e);if(k.isMapping(e))return v.ref("storage",e);if(k.isStruct(e))return v.ref("memory",e);if(k.isElementary(e))switch(e.kind){case"uint":{const t=e.bits||256;return v.scalar(t/8,e)}case"int":{const t=e.bits||256;return v.scalar(t/8,e)}case"address":return v.scalar(20,e);case"bool":return v.scalar(1,e);case"bytes":return e.size?v.scalar(e.size,e):v.ref("memory",e);case"string":return v.ref("memory",e);default:pt()}pt()}!function(e){let t,n,s,o,i,a,c,l,u,d;!function(e){e.nodeType=St(mt.Types.nodeType)}(t=e.Types||(e.Types={})),function(e){e.emit=St(mt.Block.emit)}(n=e.Instructions||(e.Instructions={})),function(e){e.terminate=function*(e){yield*St(mt.Block.setTerminator)(e);const n=(yield{type:"peek"}).block.id;switch(e.kind){case"jump":yield*t(e.target,n);break;case"branch":yield*t(e.trueTarget,n),yield*t(e.falseTarget,n);break;case"call":yield*t(e.continuation,n)}};const t=function*(e,t){const n=(yield{type:"peek"}).function.blocks.get(e);if(n){const s={...n,predecessors:new Set([...n.predecessors,t])};yield{type:"modify",fn:t=>({...t,function:{...t.function,blocks:new Map([...t.function.blocks,[e,s]])}})}}else{const n={id:e,instructions:[],terminator:{kind:"jump",target:e,operationDebug:{}},predecessors:new Set([t]),phis:[],debug:{}};yield{type:"modify",fn:t=>({...t,function:{...t.function,blocks:new Map([...t.function.blocks,[e,n]])}})}}};function*n(){const e=(yield{type:"peek"}).block;if(e.terminator){const t={id:e.id,instructions:e.instructions,terminator:e.terminator,predecessors:e.predecessors,phis:e.phis,debug:{}};yield*St(mt.Function.addBlock)(e.id,t)}}e.currentTerminator=St(mt.Block.terminator),e.create=function*(e){const t=`${e}_${(yield{type:"peek"}).counters.block}`;return yield*St(mt.Counters.consumeBlock)(),t},e.switchTo=function*(e){yield*n();const t=(yield{type:"peek"}).function.blocks.get(e);if(t){const n=t.terminator&&"jump"===t.terminator.kind&&t.terminator.target===e;yield{type:"modify",fn:e=>({...e,block:{id:t.id,instructions:[...t.instructions],terminator:n?void 0:t.terminator,predecessors:new Set(t.predecessors),phis:[...t.phis]}})}}else{const t={id:e,instructions:[],terminator:void 0,predecessors:new Set,phis:[]};yield{type:"modify",fn:e=>({...e,block:t})}}},e.syncCurrent=n}(s=e.Blocks||(e.Blocks={})),function(e){function*t(e,t,s){const i=yield*St(mt.Scopes.current)(),r=yield*o(),a=(i.ssaVars.get(e)?.version??-1)+1,c={name:e,currentTempId:r,type:t,version:a},l={...i,ssaVars:new Map([...i.ssaVars,[e,c]]),usedNames:new Map([...i.usedNames,[e,a+1]])};yield*St(mt.Scopes.setCurrent)(l);const u=`scope_${yield*St(mt.Scopes.extract)((e=>e.stack.length-1))}_${e}`;return yield*n(r,e,u,t,a,s),c}e.declare=t,e.declareWithExistingTemp=function*(e,t,s,o){const i=yield*St(mt.Scopes.current)(),r=(i.ssaVars.get(e)?.version??-1)+1,a={name:e,currentTempId:s,type:t,version:r},c={...i,ssaVars:new Map([...i.ssaVars,[e,a]]),usedNames:new Map([...i.usedNames,[e,r+1]])};yield*St(mt.Scopes.setCurrent)(c);const l=`scope_${yield*St(mt.Scopes.extract)((e=>e.stack.length-1))}_${e}`;return yield*n(s,e,l,t,r,o),a},e.assignSsa=function*(e,s){const i=yield*o(),r=yield*St(mt.Scopes.extract)((e=>e.stack));let a=-1;for(let t=r.length-1;t>=0;t--)if(r[t].ssaVars.has(e)){a=t;break}if(-1===a)return yield*t(e,s);const c=r[a],l=c.ssaVars.get(e).version+1,u={name:e,currentTempId:i,type:s,version:l},d={...c,ssaVars:new Map([...c.ssaVars,[e,u]])},p=[...r.slice(0,a),d,...r.slice(a+1)];yield*St(mt.Scopes.update)((()=>({stack:p})));const m=`scope_${a}_${e}`;return yield*n(i,e,m,s,l),u};const n=function*(e,t,n,s,o,i){const r=(yield{type:"peek"}).function.ssaMetadata||new Map,a=new Map(r);a.set(e,{name:t,scopeId:n,type:s,version:o,loc:i}),yield{type:"modify",fn:e=>({...e,function:{...e.function,ssaMetadata:a}})}};e.lookup=St(mt.Scopes.lookupVariable),e.checkAndInsertPhi=function*(e,t){const i=yield{type:"peek"},r=i.block;if(r.predecessors.size<=1)return null;const a=r.phis.find((t=>{const n=i.function.ssaMetadata?.get(t.dest);return n&&n.name===e}));if(a)return a.dest;const c=new Map;let l=!1,u=null;for(const n of r.predecessors){const s=i.function.blocks.get(n);if(!s)continue;let o=null;if(i.function.ssaMetadata)for(const[t,n]of i.function.ssaMetadata)if(n.name===e)for(const e of s.instructions)"dest"in e&&e.dest===t&&(o=t);o||e!==t.name||(o=t.currentTempId),o&&(c.set(n,o),null===u?u=o:u!==o&&(l=!0))}if(!l||0===c.size)return null;const d=yield*o(),p=new Map;for(const[n,s]of c){const e=i.function.ssaMetadata?.get(s);p.set(n,x.temp(s,e?.type||t.type))}const m={kind:"phi",dest:d,sources:p,type:t.type,operationDebug:{}};yield*St(mt.Block.addPhi)(m);const f=`scope_${yield*St(mt.Scopes.extract)((e=>e.stack.length-1))}_${e}`;return yield*n(d,e,f,t.type,t.version+1),yield*s(e,d),d};const s=function*(e,t){const n=yield*St(mt.Scopes.extract)((e=>e.stack));let s=-1;for(let c=n.length-1;c>=0;c--)if(n[c].ssaVars.has(e)){s=c;break}if(-1===s)return;const o=n[s],i={...o.ssaVars.get(e),currentTempId:t},r={...o,ssaVars:new Map([...o.ssaVars,[e,i]])},a=[...n.slice(0,s),r,...n.slice(s+1)];yield*St(mt.Scopes.update)((()=>({stack:a})))};function*o(){const e=`t${yield*St(mt.Counters.nextTemp)()}`;return yield*St(mt.Counters.consumeTemp)(),e}function*i(){const e=yield*St(mt.Scopes.extract)((e=>e.stack)),t=new Map;for(const n of e)for(const[e,s]of n.ssaVars)t.has(e)||t.set(e,{tempId:s.currentTempId,type:s.type});return t}e.updateSsaToExistingTemp=function*(e,t,s){const o=yield*St(mt.Scopes.extract)((e=>e.stack));let i=-1;for(let n=o.length-1;n>=0;n--)if(o[n].ssaVars.has(e)){i=n;break}if(-1===i){const o=yield*St(mt.Scopes.current)(),r=(o.ssaVars.get(e)?.version??-1)+1,a={name:e,currentTempId:t,type:s,version:r},c={...o,ssaVars:new Map([...o.ssaVars,[e,a]]),usedNames:new Map([...o.usedNames,[e,r+1]])};yield*St(mt.Scopes.setCurrent)(c);const l=`scope_${-1===i?0:i}_${e}`;return void(yield*n(t,e,l,s,r))}const r=o[i],a=r.ssaVars.get(e).version+1,c={name:e,currentTempId:t,type:s,version:a},l={...r,ssaVars:new Map([...r.ssaVars,[e,c]])},u=[...o.slice(0,i),l,...o.slice(i+1)];yield*St(mt.Scopes.update)((()=>({stack:u})));const d=`scope_${i}_${e}`;yield*n(t,e,d,s,a)},e.newTemp=o,e.enterScope=St(mt.Scopes.push),e.exitScope=St(mt.Scopes.pop),e.captureCurrentVariables=i,e.createLoopPhis=function(e,t){const n=new Map;for(const[s,{tempId:o,type:i}]of e)n.set(s,{phiTemp:"",varName:s,type:i,initialTemp:o});return n},e.createAndInsertLoopPhis=function*(e,t){const i=new Map,r=(yield{type:"peek"}).function.blocks.get(t);if(!r)return i;const a=Array.from(r.predecessors).find((e=>e!==t));if(!a)return i;for(const[c,{tempId:l,type:u}]of e){const e=yield*o(),t=new Map;t.set(a,x.temp(l,u));const r={kind:"phi",dest:e,sources:t,type:u,operationDebug:{}};yield*St(mt.Block.addPhi)(r);const d=`scope_${yield*St(mt.Scopes.extract)((e=>e.stack.length-1))}_${c}`;yield*n(e,c,d,u,0),yield*s(c,e),i.set(c,{phiTemp:e,varName:c,type:u,initialTemp:l})}return i},e.updateLoopPhis=function*(e,t,n){const s=(yield{type:"peek"}).function.blocks.get(n);if(!s)return;const o=yield*i();for(const[i,r]of e){const e=o.get(i);if(!e)continue;s.phis.find((e=>e.dest===r.phiTemp))&&(yield{type:"modify",fn:s=>{const o=s.function.blocks.get(n);if(!o)return s;const i=o.phis.map((n=>{if(n.dest===r.phiTemp){const s=new Map(n.sources);return s.set(t,x.temp(e.tempId,r.type)),{...n,sources:s}}return n}));return{...s,function:{...s.function,blocks:new Map([...s.function.blocks,[n,{...o,phis:i}]])}}}})}}}(o=e.Variables||(e.Variables={})),function(e){e.enterLoop=St(mt.Loops.push),e.exitLoop=St(mt.Loops.pop),e.currentLoop=function*(){const e=yield{type:"peek"};return e.loops.stack[e.loops.stack.length-1]||null}}(i=e.ControlFlow||(e.ControlFlow={})),function(e){e.initialize=function*(e,t){const n=[],s=new Map,o=new Map;for(const a of t){const e=`t${n.length}`,t={name:a.name,type:a.type,tempId:e};n.push(t),s.set(a.name,{name:a.name,currentTempId:e,type:a.type,version:0}),o.set(e,{name:a.name,scopeId:"param",type:a.type,version:0})}const i={id:e,parameters:n,blocks:new Map,ssaMetadata:o},r={id:"entry",instructions:[],terminator:void 0,predecessors:new Set,phis:[]};yield{type:"modify",fn:e=>({...e,function:i,block:r,scopes:{stack:[{ssaVars:s,usedNames:new Map}]},loops:{stack:[]},counters:{...e.counters,block:1,temp:t.length}})}},e.currentBlocks=function*(){return(yield{type:"peek"}).function.blocks},e.currentParameters=function*(){return(yield{type:"peek"}).function.parameters},e.finalize=function*(){yield*s.syncCurrent();const e=(yield{type:"peek"}).function;return{name:e.id,parameters:e.parameters,entry:"entry",blocks:e.blocks}},e.collectSsaMetadata=function*(){return(yield{type:"peek"}).function.ssaMetadata||new Map},e.addToModule=St(mt.Module.addFunction)}(a=e.Functions||(e.Functions={})),function(e){e.current=function*(){return(yield{type:"peek"}).module}}(c=e.Modules||(e.Modules={})),function(t){function*n(){const e=yield{type:"peek"},t=wt(e,e.module.name);return 0===t.length?{}:{context:{variables:t.map(Tt)}}}t.forAstNode=function*(t){const s=yield*n();if(!t.loc)return s;const{offset:o,length:i}=t.loc;return{context:{code:{source:{id:(yield*e.Modules.current()).name},range:{offset:o,length:i}},...r.BP.Context.isVariables(s.context)?{variables:s.context.variables}:{}}}},t.withStorageVariables=n}(l=e.Debug||(e.Debug={})),function(t){t.findSlot=function*(e){const t=(yield{type:"peek"}).module.storageDeclarations.find((t=>t.name===e));return t?{slot:t.slot,name:t.name,declaration:t}:null},t.computeSlot=function*(t,n,s){const i=yield*o.newTemp();return yield*e.Instructions.emit({kind:"compute_slot",slotKind:"mapping",base:t,key:n,dest:i,operationDebug:s?yield*e.Debug.forAstNode(s):{}}),x.temp(i,v.Scalar.uint256)},t.load=function*(t,n,s){const i=yield*o.newTemp();return yield*e.Instructions.emit({kind:"read",location:"storage",slot:t,offset:x.constant(0n,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),type:n,dest:i,operationDebug:s?yield*e.Debug.forAstNode(s):{}}),x.temp(i,n)},t.store=function*(t,n,s){yield*e.Instructions.emit({kind:"write",location:"storage",slot:t,offset:x.constant(0n,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),value:n,operationDebug:s?yield*e.Debug.forAstNode(s):{}})}}(u=e.Storage||(e.Storage={})),function(e){e.report=St(mt.Errors.append),e.count=St(mt.Errors.count),e.warning=St(mt.Warnings.append),e.attempt=St(mt.Errors.attempt)}(d=e.Errors||(e.Errors={})),e.run=function(e,t){let n=t,s=e.next();for(;!s.done;){const t=s.value;switch(t.type){case"modify":n=t.fn(n),s=e.next(n);break;case"peek":case"value":s=e.next(n);break;default:pt()}}return{state:n,value:s.value}}}(Et||(Et={}));const Nt=e=>function*(t){yield*Et.Variables.enterScope();for(const n of t.items)d(n)&&(yield*e(n));yield*Et.Variables.exitScope()};const At=e=>function*(t,n){const s=yield*Et.Types.nodeType(t);if(!s)return yield*Et.Errors.report(new dt(`Cannot determine type for unary operator: ${t.operator}`,t.loc??void 0,B.Error)),x.constant(0n,v.Scalar.uint256);const o=It(s),i=yield*e(t.operands[0],{kind:"rvalue"}),r=yield*Et.Variables.newTemp(),a="!"===t.operator?"not":"neg";return yield*Et.Instructions.emit({kind:"unary",op:a,operand:i,dest:r,operationDebug:yield*Et.Debug.forAstNode(t)}),x.temp(r,o)},Dt=e=>function*(t,n){const s=yield*Et.Types.nodeType(t);if(!s)return yield*Et.Errors.report(new dt(`Cannot determine type for binary operator: ${t.operator}`,t.loc??void 0,B.Error)),x.constant(0n,v.Scalar.uint256);const o=It(s),i=yield*e(t.operands[0],{kind:"rvalue"}),r=yield*e(t.operands[1],{kind:"rvalue"}),a=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"binary",op:$t(t.operator),left:i,right:r,dest:a,operationDebug:yield*Et.Debug.forAstNode(t)}),x.temp(a,o)};function $t(e){return{"+":"add","-":"sub","*":"mul","/":"div","%":"mod","==":"eq","!=":"ne","<":"lt","<=":"le",">":"gt",">=":"ge","&&":"and","||":"or"}[e]||"add"}function*Mt(e){if(f.isIdentifier(e)){const t=yield*Et.Storage.findSlot(e.name);return t?{slot:t,accesses:[]}:void 0}if(f.isAccess(e)&&f.Access.isIndex(e)){const t=e,n=yield*Mt(t.object);if(!n)return;const s=yield*zt(t.index,{kind:"rvalue"});return n.accesses.push({kind:"index",key:s}),n}if(f.isAccess(e)&&f.Access.isMember(e)){const t=e,n=yield*Mt(t.object);if(!n)return;return n.accesses.push({kind:"member",fieldName:t.property}),n}}function jt(e){if("synthetic"!==e.origin){if(k.Elementary.isAddress(e.origin))return 20;if(k.Elementary.isBool(e.origin))return 1;if(k.Elementary.isBytes(e.origin)&&e.origin.size)return e.origin.size;if(k.Elementary.isUint(e.origin))return(e.origin.bits||256)/8}return"scalar"===e.kind?e.size:32}function*Ct(e,t,n){const s=yield*Et.Types.nodeType(e.slot.declaration);let o=x.constant(BigInt(e.slot.slot),v.Scalar.uint256),i=s;for(const u of e.accesses)if("index"===u.kind&&u.key){const e=yield*Et.Variables.newTemp();if(i&&k.isMapping(i)){const t=It(i.key);yield*Et.Instructions.emit({kind:"compute_slot",slotKind:"mapping",base:o,key:u.key,keyType:t,dest:e,operationDebug:n?yield*Et.Debug.forAstNode(n):{}}),i=i.value}else if(i&&k.isArray(i)){const t=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"compute_slot",slotKind:"array",base:o,dest:t,operationDebug:n?yield*Et.Debug.forAstNode(n):{}}),yield*Et.Instructions.emit({kind:"binary",op:"add",left:x.temp(t,v.Scalar.uint256),right:u.key,dest:e,operationDebug:n?yield*Et.Debug.forAstNode(n):{}}),i=i.element}o=x.temp(e,v.Scalar.uint256)}else if("member"===u.kind&&u.fieldName&&i&&k.isStruct(i)){const e=i.fields.get(u.fieldName),t=i.layout.get(u.fieldName);if(!e||!t)throw new Error(`Field ${u.fieldName} not found in struct ${i.name}`);const s=Math.floor(t.byteOffset/32);if(s>0){const e=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"compute_slot",slotKind:"field",base:o,fieldOffset:s,dest:e,operationDebug:n?yield*Et.Debug.forAstNode(n):{}}),o=x.temp(e,v.Scalar.uint256)}u.fieldOffset=t.byteOffset,u.fieldType=It(e),i=e}let r=0,a=32;const c=e.accesses[e.accesses.length-1];c&&"member"===c.kind&&void 0!==c.fieldOffset&&(r=c.fieldOffset%32,c.fieldType&&(a=jt(c.fieldType)));const l=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"read",location:"storage",slot:o,offset:x.constant(BigInt(r),v.Scalar.uint256),length:x.constant(BigInt(a),v.Scalar.uint256),type:t,dest:l,operationDebug:n?yield*Et.Debug.forAstNode(n):{}}),x.temp(l,t)}function*Ot(e,t,n){if(0===e.accesses.length)return void(yield*Et.Instructions.emit({kind:"write",location:"storage",slot:x.constant(BigInt(e.slot.slot),v.Scalar.uint256),offset:x.constant(0n,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),value:t,operationDebug:n?yield*Et.Debug.forAstNode(n):{}}));const s=yield*Et.Types.nodeType(e.slot.declaration);let o=x.constant(BigInt(e.slot.slot),v.Scalar.uint256),i=s;for(const u of e.accesses)if("index"===u.kind&&u.key){if(i&&k.isMapping(i)){const e=yield*Et.Variables.newTemp(),t=It(i.key);yield*Et.Instructions.emit({kind:"compute_slot",slotKind:"mapping",base:o,key:u.key,keyType:t,dest:e,operationDebug:n?yield*Et.Debug.forAstNode(n):{}}),o=x.temp(e,v.Scalar.uint256),i=i.value}else if(i&&k.isArray(i)){const e=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"compute_slot",slotKind:"array",base:o,dest:e,operationDebug:n?yield*Et.Debug.forAstNode(n):{}});const t=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"binary",op:"add",left:x.temp(e,v.Scalar.uint256),right:u.key,dest:t,operationDebug:n?yield*Et.Debug.forAstNode(n):{}}),o=x.temp(t,v.Scalar.uint256),i=i.element}}else if("member"===u.kind&&u.fieldName&&i&&k.isStruct(i)){const e=i.fields.get(u.fieldName),t=i.layout.get(u.fieldName);if(e&&t){const s=Math.floor(t.byteOffset/32);if(s>0){const e=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"compute_slot",slotKind:"field",base:o,fieldOffset:s,dest:e,operationDebug:n?yield*Et.Debug.forAstNode(n):{}}),o=x.temp(e,v.Scalar.uint256)}u.fieldOffset=t.byteOffset,u.fieldType=It(e),i=e}else yield*Et.Errors.report(new dt(`Field ${u.fieldName} not found in struct`,n?.loc??void 0,B.Error))}let r,a=0;const c=e.accesses[e.accesses.length-1];c&&"member"===c.kind&&void 0!==c.fieldOffset&&(a=c.fieldOffset%32,c.fieldType&&(r=jt(c.fieldType)));const l=void 0!==r?r:32;yield*Et.Instructions.emit({kind:"write",location:"storage",slot:o,offset:x.constant(BigInt(a),v.Scalar.uint256),length:x.constant(BigInt(l),v.Scalar.uint256),value:t,operationDebug:n?yield*Et.Debug.forAstNode(n):{}})}const _t=(e,t)=>function*(n,s){if("length"===n.property){const t=yield*Et.Types.nodeType(n.object);if(t&&(k.isArray(t)||k.isElementary(t)&&(k.Elementary.isBytes(t)||k.Elementary.isString(t)))){const s=v.Scalar.uint256,o=yield*Et.Variables.newTemp();if(k.isArray(t)&&void 0!==t.size)return yield*Et.Instructions.emit({kind:"const",value:BigInt(t.size),type:s,dest:o,operationDebug:yield*Et.Debug.forAstNode(n)}),x.temp(o,s);const i=yield*e(n.object,{kind:"rvalue"});return yield*Et.Instructions.emit({kind:"length",object:i,dest:o,operationDebug:yield*Et.Debug.forAstNode(n)}),x.temp(o,s)}}const o=yield*t(n);if(o){const e=yield*Et.Types.nodeType(n);if(e){const t=It(e);return yield*Ct(o,t,n)}}const i=yield*e(n.object,{kind:"rvalue"}),r=yield*Et.Types.nodeType(n.object);if(r&&k.isStruct(r)){const e=r.fields.get(n.property);if(e){const t=Array.from(r.fields.keys()).indexOf(n.property),s=It(e),o=yield*Et.Variables.newTemp(),a=32*t;yield*Et.Instructions.emit(w.ComputeOffset.field("memory",i,n.property,a,o,yield*Et.Debug.forAstNode(n)));const c=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"read",location:"memory",offset:x.temp(o,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),type:s,dest:c,operationDebug:yield*Et.Debug.forAstNode(n)}),x.temp(c,s)}}throw new dt("Invalid member access expression",n.loc??void 0,B.Error)},Bt=e=>function*(t,n){const s=yield*Et.Types.nodeType(t.object);if(s&&k.isElementary(s)&&k.Elementary.isBytes(s)){const n=yield*e(t.object,{kind:"rvalue"}),s=yield*e(t.start,{kind:"rvalue"}),o=yield*e(t.end,{kind:"rvalue"}),i=v.Ref.memory(),r=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"binary",op:"sub",left:o,right:s,dest:r,operationDebug:yield*Et.Debug.forAstNode(t)});const a=x.temp(r,v.Scalar.uint256),c=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"binary",op:"add",left:a,right:x.constant(32n,v.Scalar.uint256),dest:c,operationDebug:yield*Et.Debug.forAstNode(t)});const l=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"allocate",location:"memory",size:x.temp(c,v.Scalar.uint256),dest:l,operationDebug:yield*Et.Debug.forAstNode(t)}),yield*Et.Instructions.emit({kind:"write",location:"memory",offset:x.temp(l,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),value:a,operationDebug:yield*Et.Debug.forAstNode(t)});const u=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"binary",op:"add",left:n,right:x.constant(32n,v.Scalar.uint256),dest:u,operationDebug:yield*Et.Debug.forAstNode(t)});const d=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"binary",op:"add",left:x.temp(u,v.Scalar.uint256),right:s,dest:d,operationDebug:yield*Et.Debug.forAstNode(t)});const p=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"read",location:"memory",offset:x.temp(d,v.Scalar.uint256),length:a,type:i,dest:p,operationDebug:yield*Et.Debug.forAstNode(t)});const m=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"binary",op:"add",left:x.temp(l,v.Scalar.uint256),right:x.constant(32n,v.Scalar.uint256),dest:m,operationDebug:yield*Et.Debug.forAstNode(t)}),yield*Et.Instructions.emit({kind:"write",location:"memory",offset:x.temp(m,v.Scalar.uint256),length:a,value:x.temp(p,i),operationDebug:yield*Et.Debug.forAstNode(t)}),x.temp(l,i)}throw new dt("Only bytes types can be sliced",t.loc??void 0,B.Error)},Ut=(e,t)=>function*(n,s){const o=yield*Et.Types.nodeType(n),i=yield*Et.Types.nodeType(n.object);if(i&&k.isElementary(i)&&k.Elementary.isBytes(i)){if(void 0!==i.size)throw new dt(`Cannot index into fixed-size bytes type 'bytes${i.size}'`,n.loc??void 0,B.Error);const t=yield*e(n.object,{kind:"rvalue"}),s=yield*e(n.index,{kind:"rvalue"}),o=v.scalar(1,"synthetic"),r=yield*Et.Variables.newTemp();yield*Et.Instructions.emit(w.ComputeOffset.byte("memory",t,s,r,yield*Et.Debug.forAstNode(n)));const a=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"read",location:"memory",offset:x.temp(r,v.Scalar.uint256),length:x.constant(1n,v.Scalar.uint256),type:o,dest:a,operationDebug:yield*Et.Debug.forAstNode(n)}),x.temp(a,o)}if(i&&k.isArray(i)&&f.isIdentifier(n.object)){const t=n.object.name;if(yield*Et.Variables.lookup(t)){const t=yield*e(n.object,{kind:"rvalue"}),s=yield*e(n.index,{kind:"rvalue"}),o=It(i.element),r=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"binary",op:"add",left:t,right:x.constant(32n,v.Scalar.uint256),dest:r,operationDebug:yield*Et.Debug.forAstNode(n)});const a=yield*Et.Variables.newTemp();yield*Et.Instructions.emit(w.ComputeOffset.array("memory",x.temp(r,v.Scalar.uint256),s,32,a,yield*Et.Debug.forAstNode(n)));const c=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"read",location:"memory",offset:x.temp(a,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),type:o,dest:c,operationDebug:yield*Et.Debug.forAstNode(n)}),x.temp(c,o)}}const r=yield*t(n);if(r&&o){const e=It(o);return yield*Ct(r,e,n)}const a=yield*e(n.object,{kind:"rvalue"}),c=yield*e(n.index,{kind:"rvalue"});if(i&&k.isArray(i)){const e=It(i.element),t=yield*Et.Variables.newTemp();yield*Et.Instructions.emit(w.ComputeOffset.array("memory",a,c,32,t,yield*Et.Debug.forAstNode(n)));const s=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"read",location:"memory",offset:x.temp(t,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),type:e,dest:s,operationDebug:yield*Et.Debug.forAstNode(n)}),x.temp(s,e)}if(i&&k.isMapping(i)&&f.isIdentifier(n.object)){const e=yield*Et.Storage.findSlot(n.object.name);if(e){const t=It(i.value),s=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"compute_slot",slotKind:"mapping",base:x.constant(BigInt(e.slot),v.Scalar.uint256),key:c,keyType:It(i.key),dest:s,operationDebug:yield*Et.Debug.forAstNode(n)});const o=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"read",location:"storage",slot:x.temp(s,v.Scalar.uint256),offset:x.constant(0n,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),type:t,dest:o,operationDebug:yield*Et.Debug.forAstNode(n)}),x.temp(o,t)}}throw new dt("Invalid index access expression",n.loc??void 0,B.Error)};const Lt=(e=>{const t=At(e),n=Dt(e);return function*(e,s){if(!(yield*Et.Types.nodeType(e)))return yield*Et.Errors.report(new dt(`Cannot determine type for operator expression: ${e.operator}`,e.loc??void 0,B.Error)),x.constant(0n,v.Scalar.uint256);switch(e.operands.length){case 1:return yield*t(e,s);case 2:return yield*n(e,s);default:pt(e.operands)}}})(zt),Rt=(e=>{const t=Ut(e,Mt),n=_t(e,Mt),s=Bt(e);return function*(e,o){switch(e.kind){case"expression:access:member":return yield*n(e,o);case"expression:access:slice":return yield*s(e,o);case"expression:access:index":return yield*t(e,o);default:pt()}}})(zt),Pt=(e=>function*(t,n){if("expression:identifier"===t.callee.kind&&"keccak256"===t.callee.name){if(1!==t.arguments.length)return yield*Et.Errors.report(new dt("keccak256 expects exactly 1 argument",t.loc??void 0,B.Error)),x.constant(0n,v.Scalar.bytes32);const n=yield*e(t.arguments[0],{kind:"rvalue"}),s=v.Scalar.bytes32,o=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"hash",value:n,dest:o,operationDebug:yield*Et.Debug.forAstNode(t)}),x.temp(o,s)}if("expression:identifier"===t.callee.kind){const n=t.callee.name,s=yield*Et.Types.nodeType(t);if(!s)return yield*Et.Errors.report(new dt(`Unknown function: ${n}`,t.loc??void 0,B.Error)),x.constant(0n,v.Scalar.uint256);const o=[];for(const c of t.arguments)o.push(yield*e(c,{kind:"rvalue"}));const i=It(s);let r;k.isFailure(s)&&"void function"===s.reason||(r=yield*Et.Variables.newTemp());const a=yield*Et.Blocks.create("call_cont");return yield*Et.Blocks.terminate({kind:"call",function:n,arguments:o,dest:r,continuation:a,operationDebug:yield*Et.Debug.forAstNode(t)}),yield*Et.Blocks.switchTo(a),r?x.temp(r,i):x.constant(0n,v.Scalar.uint256)}return yield*Et.Errors.report(new dt("Complex function call expressions not yet supported",t.loc??void 0,B.Error)),x.constant(0n,v.Scalar.uint256)})(zt),Vt=(e=>function*(t,n){const s=yield*e(t.expression,{kind:"rvalue"}),o=yield*Et.Types.nodeType(t);if(!o)return yield*Et.Errors.report(new dt("Cannot determine target type for cast expression",t.loc??void 0,B.Error)),s;const i=It(o),r=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"cast",value:s,targetType:i,dest:r,operationDebug:yield*Et.Debug.forAstNode(t)}),x.temp(r,i)})(zt);function*zt(e,t){switch(e.kind){case"expression:identifier":return yield*function*(e){const t=yield*Et.Variables.lookup(e.name);if(t){const n=yield*Et.Variables.checkAndInsertPhi(e.name,t);return n?x.temp(n,t.type):x.temp(t.currentTempId,t.type)}const n=yield*Et.Storage.findSlot(e.name);if(n){const t=yield*Et.Types.nodeType(n.declaration),s=t?It(t):v.Scalar.uint256,o=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"read",location:"storage",slot:x.constant(BigInt(n.slot),v.Scalar.uint256),offset:x.constant(0n,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),type:s,dest:o,operationDebug:yield*Et.Debug.forAstNode(e)}),x.temp(o,s)}return yield*Et.Errors.report(new dt(ut(e.name),e.loc??void 0,B.Error)),x.constant(0n,v.Scalar.uint256)}(e);case"expression:literal:number":case"expression:literal:string":case"expression:literal:boolean":case"expression:literal:address":case"expression:literal:hex":return yield*function*(e){const t=yield*Et.Types.nodeType(e);if(!t)return yield*Et.Errors.report(new dt(`Cannot determine type for literal: ${e.value}`,e.loc??void 0,B.Error)),x.constant(0n,v.Scalar.uint256);const n=It(t);let s;switch(e.kind){case"expression:literal:number":s=BigInt(e.value);break;case"expression:literal:hex":s=(e.value.startsWith("0x")?e.value.slice(2):e.value).length>64?e.value.startsWith("0x")?e.value:`0x${e.value}`:BigInt(e.value);break;case"expression:literal:address":case"expression:literal:string":s=e.value;break;case"expression:literal:boolean":s="true"===e.value;break;default:pt()}const o=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"const",dest:o,value:s,type:n,operationDebug:yield*Et.Debug.forAstNode(e)}),x.temp(o,n)}(e);case"expression:operator":return yield*Lt(e,t);case"expression:access:member":case"expression:access:slice":case"expression:access:index":return yield*Rt(e,t);case"expression:call":return yield*Pt(e,t);case"expression:cast":return yield*Vt(e,t);case"expression:special:msg.sender":case"expression:special:msg.value":case"expression:special:msg.data":case"expression:special:block.timestamp":case"expression:special:block.number":return yield*function*(e){const t=yield*Et.Types.nodeType(e);if(!t)return yield*Et.Errors.report(new dt(`Cannot determine type for special expression: ${e.kind}`,e.loc??void 0,B.Error)),x.constant(0n,v.Scalar.uint256);const n=It(t),s=yield*Et.Variables.newTemp();let o;switch(e.kind){case"expression:special:msg.sender":o="msg_sender";break;case"expression:special:msg.value":o="msg_value";break;case"expression:special:msg.data":o="msg_data";break;case"expression:special:block.timestamp":o="block_timestamp";break;case"expression:special:block.number":o="block_number";break;default:pt()}return yield*Et.Instructions.emit({kind:"env",op:o,dest:s,operationDebug:yield*Et.Debug.forAstNode(e)}),x.temp(s,n)}(e);case"expression:array":return yield*function*(e,t){switch(t.kind){case"lvalue-storage":{const n=x.constant(BigInt(e.elements.length),v.Scalar.uint256);yield*Et.Instructions.emit({kind:"write",location:"storage",slot:x.constant(BigInt(t.slot),v.Scalar.uint256),offset:x.constant(0n,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),value:n,operationDebug:yield*Et.Debug.forAstNode(e)});for(let s=0;s<e.elements.length;s++){const n=yield*zt(e.elements[s],{kind:"rvalue"}),o=x.constant(BigInt(s),v.Scalar.uint256),i=yield*Et.Variables.newTemp();yield*Et.Instructions.emit(w.ComputeSlot.array(x.constant(BigInt(t.slot),v.Scalar.uint256),i,yield*Et.Debug.forAstNode(e)));const r=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"binary",op:"add",left:x.temp(i,v.Scalar.uint256),right:o,dest:r,operationDebug:yield*Et.Debug.forAstNode(e)}),yield*Et.Instructions.emit({kind:"write",location:"storage",slot:x.temp(r,v.Scalar.uint256),offset:x.constant(0n,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),value:n,operationDebug:yield*Et.Debug.forAstNode(e.elements[s])})}return x.constant(0n,v.Scalar.uint256)}case"lvalue-memory":case"rvalue":{const n="lvalue-memory"===t.kind?t.type:yield*Et.Types.nodeType(e);if(!n||!k.isArray(n)){const t=BigInt(e.elements.length),n=32n+32n*t,s=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"allocate",location:"memory",size:x.constant(n,v.Scalar.uint256),dest:s,operationDebug:yield*Et.Debug.forAstNode(e)}),yield*Et.Instructions.emit({kind:"write",location:"memory",offset:x.temp(s,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),value:x.constant(t,v.Scalar.uint256),operationDebug:yield*Et.Debug.forAstNode(e)});const o=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"binary",op:"add",left:x.temp(s,v.Scalar.uint256),right:x.constant(32n,v.Scalar.uint256),dest:o,operationDebug:yield*Et.Debug.forAstNode(e)});for(let i=0;i<e.elements.length;i++){const t=yield*zt(e.elements[i],{kind:"rvalue"}),n=yield*Et.Variables.newTemp();yield*Et.Instructions.emit(w.ComputeOffset.array("memory",x.temp(o,v.Scalar.uint256),x.constant(BigInt(i),v.Scalar.uint256),32,n,yield*Et.Debug.forAstNode(e.elements[i]))),yield*Et.Instructions.emit({kind:"write",location:"memory",offset:x.temp(n,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),value:t,operationDebug:yield*Et.Debug.forAstNode(e.elements[i])})}return x.temp(s,v.Scalar.uint256)}const s=BigInt(e.elements.length),o=32n+32n*s,i=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"allocate",location:"memory",size:x.constant(o,v.Scalar.uint256),dest:i,operationDebug:yield*Et.Debug.forAstNode(e)}),yield*Et.Instructions.emit({kind:"write",location:"memory",offset:x.temp(i,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),value:x.constant(s,v.Scalar.uint256),operationDebug:yield*Et.Debug.forAstNode(e)});const r=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"binary",op:"add",left:x.temp(i,v.Scalar.uint256),right:x.constant(32n,v.Scalar.uint256),dest:r,operationDebug:yield*Et.Debug.forAstNode(e)});for(let t=0;t<e.elements.length;t++){const n=yield*zt(e.elements[t],{kind:"rvalue"}),s=yield*Et.Variables.newTemp();yield*Et.Instructions.emit(w.ComputeOffset.array("memory",x.temp(r,v.Scalar.uint256),x.constant(BigInt(t),v.Scalar.uint256),32,s,yield*Et.Debug.forAstNode(e.elements[t]))),yield*Et.Instructions.emit({kind:"write",location:"memory",offset:x.temp(s,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),value:n,operationDebug:yield*Et.Debug.forAstNode(e.elements[t])})}return x.temp(i,v.Scalar.uint256)}}}(e,t);case"expression:struct":throw new Error("Struct expressions not yet implemented in IR generation");default:pt()}}function*Ft(e){const t=e.declaration;switch(t.kind){case"declaration:variable":return yield*function*(e){const t=yield*Et.Types.nodeType(e),n=t?It(t):v.Scalar.uint256;if("ref"===n.kind){let t;if(e.initializer)if(f.isLiteral(e.initializer)&&f.Literal.isHex(e.initializer)){const n=e.initializer,s=(n.value.startsWith("0x")?n.value.slice(2):n.value).length/2;t=x.constant(BigInt(s+32),v.Scalar.uint256)}else t=x.constant(64n,v.Scalar.uint256);else t=x.constant(64n,v.Scalar.uint256);const s=yield*Et.Variables.newTemp();if(yield*Et.Instructions.emit({kind:"allocate",location:"memory",size:t,dest:s,operationDebug:yield*Et.Debug.forAstNode(e)}),yield*Et.Variables.declareWithExistingTemp(e.name,n,s),e.initializer){const t=yield*zt(e.initializer,{kind:"rvalue"});if(f.isLiteral(e.initializer)){const n=e.initializer;if(f.Literal.isHex(n)){const o=(n.value.startsWith("0x")?n.value.slice(2):n.value).length/2;yield*Et.Instructions.emit({kind:"write",location:"memory",offset:x.temp(s,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),value:x.constant(BigInt(o),v.Scalar.uint256),operationDebug:yield*Et.Debug.forAstNode(e)});const i=yield*Et.Variables.newTemp();yield*Et.Instructions.emit({kind:"binary",op:"add",left:x.temp(s,v.Scalar.uint256),right:x.constant(32n,v.Scalar.uint256),dest:i,operationDebug:yield*Et.Debug.forAstNode(e)}),yield*Et.Instructions.emit({kind:"write",location:"memory",offset:x.temp(i,v.Scalar.uint256),length:x.constant(BigInt(o),v.Scalar.uint256),value:t,operationDebug:yield*Et.Debug.forAstNode(e)})}}else"temp"===t.kind?yield*Et.Variables.updateSsaToExistingTemp(e.name,t.id,n):yield*Et.Instructions.emit({kind:"binary",op:"add",left:t,right:x.constant(0n,v.Scalar.uint256),dest:s,operationDebug:yield*Et.Debug.forAstNode(e)})}}else if(e.initializer){const t=yield*zt(e.initializer,{kind:"rvalue"}),s=yield*Et.Variables.declare(e.name,n);"temp"===t.kind?t.id!==s.currentTempId&&(yield*Et.Variables.updateSsaToExistingTemp(e.name,t.id,n)):"const"===t.kind&&(yield*Et.Instructions.emit({kind:"const",value:t.value,type:n,dest:s.currentTempId,operationDebug:yield*Et.Debug.forAstNode(e)}))}else{const t=yield*Et.Variables.declare(e.name,n);yield*Et.Instructions.emit({kind:"const",value:0n,type:n,dest:t.currentTempId,operationDebug:yield*Et.Debug.forAstNode(e)})}}(t);case"declaration:function":case"declaration:parameter":case"declaration:struct":case"declaration:storage":return;default:return yield*Et.Errors.report(new dt(`Unsupported declaration kind: ${t.kind}`,e.loc??void 0,B.Error))}}const Ht=e=>{const t=Nt(e);return function*(e){const n=yield*Et.Blocks.create("then"),s=e.alternate?yield*Et.Blocks.create("else"):yield*Et.Blocks.create("merge"),o=e.alternate?yield*Et.Blocks.create("merge"):s,i=yield*zt(e.condition,{kind:"rvalue"});yield*Et.Blocks.terminate({kind:"branch",condition:i,trueTarget:n,falseTarget:s,operationDebug:yield*Et.Debug.forAstNode(e)}),yield*Et.Blocks.switchTo(n),yield*t(e.body);(yield*Et.Blocks.currentTerminator())||(yield*Et.Blocks.terminate({kind:"jump",target:o,operationDebug:yield*Et.Debug.forAstNode(e)}));if(e.alternate){yield*Et.Blocks.switchTo(s),yield*t(e.alternate);(yield*Et.Blocks.currentTerminator())||(yield*Et.Blocks.terminate({kind:"jump",target:o,operationDebug:yield*Et.Debug.forAstNode(e)}))}yield*Et.Blocks.switchTo(o)}},qt=e=>function*(t){const n=Nt(e);t.init&&(yield*e(t.init));const s=yield*Et.Blocks.create(`${t.prefix}_header`),o=yield*Et.Blocks.create(`${t.prefix}_body`),i=yield*Et.Blocks.create(`${t.prefix}_exit`),r=t.update?yield*Et.Blocks.create(`${t.prefix}_update`):null,a=yield*Et.Variables.captureCurrentVariables();yield*Et.Blocks.terminate({kind:"jump",target:s,operationDebug:t.node?yield*Et.Debug.forAstNode(t.node):{}}),yield*Et.Blocks.switchTo(s);const c=yield*Et.Variables.createAndInsertLoopPhis(a,s),l=t.condition?yield*zt(t.condition,{kind:"rvalue"}):x.constant(1n,v.Scalar.bool);yield*Et.Blocks.terminate({kind:"branch",condition:l,trueTarget:o,falseTarget:i,operationDebug:t.node?yield*Et.Debug.forAstNode(t.node):{}}),yield*Et.Blocks.switchTo(o);const u=r||s;yield*Et.ControlFlow.enterLoop(u,i),yield*n(t.body),yield*Et.ControlFlow.exitLoop();(yield*Et.Blocks.currentTerminator())||(yield*Et.Blocks.terminate({kind:"jump",target:u,operationDebug:t.node?yield*Et.Debug.forAstNode(t.node):{}}));if(r&&t.update){yield*Et.Blocks.switchTo(r),yield*e(t.update),yield*Et.Variables.updateLoopPhis(c,r,s);(yield*Et.Blocks.currentTerminator())||(yield*Et.Blocks.terminate({kind:"jump",target:s,operationDebug:t.node?yield*Et.Debug.forAstNode(t.node):{}}))}else if(!t.update){const e=(yield{type:"peek"}).block.id;yield*Et.Variables.updateLoopPhis(c,e,s)}yield*Et.Blocks.switchTo(i)},Wt=e=>{const t=qt(e);return function*(e){yield*t({condition:e.condition,body:e.body,prefix:"while",node:e})}},Kt=e=>{const t=qt(e);return function*(e){yield*t({init:e.init,condition:e.condition,update:e.update,body:e.body,prefix:"for",node:e})}};function*Yt(e){yield*function*(e,t){let n={kind:"rvalue"};if("expression:identifier"===e.kind){const t=e.name,s=yield*Et.Storage.findSlot(t);if(s){const t=yield*Et.Types.nodeType(e);t&&(n={kind:"lvalue-storage",slot:s.slot,type:t})}else{if(yield*Et.Variables.lookup(t)){const t=yield*Et.Types.nodeType(e);t&&(n={kind:"lvalue-memory",type:t})}}}const s=yield*zt(t,n);if("lvalue-storage"===n.kind&&"expression:array"===t.kind)return;yield*function*(e,t){if("expression:identifier"===e.kind){const n=e.name,s=yield*Et.Variables.lookup(n);if(s){if("temp"===t.kind)yield*Et.Variables.updateSsaToExistingTemp(n,t.id,s.type);else{const o=yield*Et.Variables.assignSsa(n,s.type);yield*Et.Instructions.emit({kind:"binary",op:"add",left:t,right:x.constant(0n,s.type),dest:o.currentTempId,operationDebug:yield*Et.Debug.forAstNode(e)})}return}const o=yield*Et.Storage.findSlot(n);return o?void(yield*Et.Instructions.emit({kind:"write",location:"storage",slot:x.constant(BigInt(o.slot),v.Scalar.uint256),offset:x.constant(0n,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),value:t,operationDebug:yield*Et.Debug.forAstNode(e)})):void(yield*Et.Errors.report(new dt(`Unknown identifier: ${n}`,e.loc||void 0,B.Error)))}if("expression:access:member"===e.kind||"expression:access:slice"===e.kind||"expression:access:index"===e.kind){const n=e;if("expression:access:member"===n.kind){const s=yield*Mt(e);if(s)return void(yield*Ot(s,t,n));const o=yield*zt(n.object,{kind:"rvalue"}),i=yield*Et.Types.nodeType(n.object);if(i&&k.isStruct(i)){const e=n.property;if(i.fields.get(e)){let s=0;for(const[t]of i.fields){if(t===e)break;s++}const r=yield*Et.Variables.newTemp(),a=32*s;return yield*Et.Instructions.emit({kind:"compute_offset",location:"memory",base:o,field:e,fieldOffset:a,dest:r,operationDebug:yield*Et.Debug.forAstNode(n)}),void(yield*Et.Instructions.emit({kind:"write",location:"memory",offset:x.temp(r,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),value:t,operationDebug:yield*Et.Debug.forAstNode(n)}))}}}else if("expression:access:index"===n.kind){const s=yield*Et.Types.nodeType(n.object);if(s&&k.isElementary(s)&&k.Elementary.isBytes(s)){const s=yield*zt(n.object,{kind:"rvalue"}),o=yield*zt(n.index,{kind:"rvalue"}),i=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"compute_offset",location:"memory",base:s,index:o,stride:1,dest:i,operationDebug:yield*Et.Debug.forAstNode(e)}),void(yield*Et.Instructions.emit({kind:"write",location:"memory",offset:x.temp(i,v.Scalar.uint256),length:x.constant(1n,v.Scalar.uint256),value:t,operationDebug:yield*Et.Debug.forAstNode(e)}))}const o=yield*Mt(e);if(o)return void(yield*Ot(o,t,n));const i=yield*zt(n.object,{kind:"rvalue"}),r=yield*zt(n.index,{kind:"rvalue"});if(s&&k.isArray(s)){const n=yield*Et.Variables.newTemp();return yield*Et.Instructions.emit({kind:"compute_offset",location:"memory",base:i,index:r,stride:32,dest:n,operationDebug:yield*Et.Debug.forAstNode(e)}),void(yield*Et.Instructions.emit({kind:"write",location:"memory",offset:x.temp(n,v.Scalar.uint256),length:x.constant(32n,v.Scalar.uint256),value:t,operationDebug:yield*Et.Debug.forAstNode(e)}))}}}yield*Et.Errors.report(new dt("Invalid lvalue",e.loc||void 0,B.Error))}(e,s)}(e.target,e.value)}const Gt=(e=>{const t=Ht(e),n=Wt(e),s=Kt(e);return function*(e){switch(e.kind){case"statement:control-flow:if":return yield*t(e);case"statement:control-flow:while":return yield*n(e);case"statement:control-flow:for":return yield*s(e);case"statement:control-flow:return":return yield*function*(e){const t=e.value?yield*zt(e.value,{kind:"rvalue"}):void 0;yield*Et.Blocks.terminate({kind:"return",value:t,operationDebug:yield*Et.Debug.forAstNode(e)})}(e);case"statement:control-flow:break":return yield*function*(e){const t=yield*Et.ControlFlow.currentLoop();if(!t)return void(yield*Et.Errors.report(new dt("Break outside loop",e.loc??void 0,B.Error)));yield*Et.Blocks.terminate({kind:"jump",target:t.breakTarget,operationDebug:yield*Et.Debug.forAstNode(e)})}(e);case"statement:control-flow:continue":return yield*function*(e){const t=yield*Et.ControlFlow.currentLoop();if(!t)return void(yield*Et.Errors.report(new dt("Continue outside loop",e.loc??void 0,B.Error)));yield*Et.Blocks.terminate({kind:"jump",target:t.continueTarget,operationDebug:yield*Et.Debug.forAstNode(e)})}(e);default:pt()}}})(Zt),Jt=Nt(Zt);function*Zt(e){switch(e.kind){case"statement:declare":return yield*Ft(e);case"statement:assign":return yield*Yt(e);case"statement:control-flow:if":case"statement:control-flow:for":case"statement:control-flow:while":case"statement:control-flow:return":case"statement:control-flow:break":case"statement:control-flow:continue":return yield*Gt(e);case"statement:express":return yield*function*(e){yield*zt(e.expression,{kind:"rvalue"})}(e);default:pt()}}function*Xt(e,t,n){yield*Et.Functions.initialize(e,t),yield*Jt(n);(yield*Et.Blocks.currentTerminator())||(yield*Et.Blocks.terminate({kind:"return",value:void 0,operationDebug:{}}));yield*Et.Blocks.syncCurrent();const s=function(e){const t=new Map;for(const[n,s]of e)t.set(n,{...s,predecessors:new Set});for(const[n,s]of e){const e=s.terminator;if(e)switch(e.kind){case"jump":{const s=t.get(e.target);s&&s.predecessors.add(n);break}case"branch":{const s=t.get(e.trueTarget);s&&s.predecessors.add(n);const o=t.get(e.falseTarget);o&&o.predecessors.add(n);break}}}return t}(yield*Et.Functions.currentBlocks()),o=yield*Et.Functions.currentParameters(),i=yield*Et.Functions.collectSsaMetadata();return{name:e,parameters:o,entry:"entry",blocks:s,ssaVariables:i.size>0?i:void 0}}function*Qt(e){const t=yield*Et.Errors.count(),n=yield*e;if(!((yield*Et.Errors.count())>t))return n}function en(e,t){const n=function(e,t){const n=[],s={name:e.name,functions:new Map,storageDeclarations:e.storage??[]},o={id:"",parameters:[],blocks:new Map},i={id:"entry",instructions:[],terminator:void 0,predecessors:new Set,phis:[]},r={stack:[{ssaVars:new Map,usedNames:new Map}]};return{module:s,function:o,block:i,scopes:r,loops:{stack:[]},counters:{temp:0,block:1},types:t,errors:n,warnings:[]}}(e,t),s=Et.run(function*(e,t){if(e.create){const t=yield*Qt(Xt("create",[],e.create));t&&!function(e){const{blocks:t}=e,n=t.get("entry");return 1===t.size&&!!n&&0===n.instructions.length&&"return"===n.terminator.kind&&!n.terminator.value}(t)&&(yield*Et.Functions.addToModule(mt.Module.create,t))}if(e.body){const t=yield*Qt(Xt("main",[],e.body));t&&(yield*Et.Functions.addToModule(mt.Module.main,t))}for(const a of e.definitions?.items??[])if("declaration:function"===a.kind){const e=a,n=t.get(e.id);if(!n||!k.isFunction(n)){yield*Et.Errors.report(new dt(`Missing type information for function: ${e.name}`,e.loc??void 0,B.Error));continue}const s=e.parameters.map(((e,t)=>({name:e.name,type:It(n.parameters[t])}))),o=yield*Qt(Xt(e.name,s,e.body));o&&(yield*Et.Functions.addToModule(e.name,o))}if((yield*Et.Errors.count())>0)return;const n=yield*Et.Modules.current(),s=wt(yield{type:"peek"},"0"),o=s.length>0?{variables:s.map(Tt)}:void 0,i={name:n.name,functions:n.functions,main:n.main||(r="main",{name:r,parameters:[],entry:"entry",blocks:new Map([["entry",{id:"entry",instructions:[],phis:[],terminator:{kind:"return",value:void 0,operationDebug:{}},predecessors:new Set,debug:{}}]])}),debugContext:o};var r;return n.create&&(i.create=n.create),i}(e,t),n),{state:o,value:i}=s,r=o.errors.length>0,a={};return o.errors.length>0&&(a[B.Error]=o.errors),o.warnings.length>0&&(a[B.Warning]=o.warnings),r||!i?{success:!1,messages:a}:{success:!0,value:i,messages:a}}class tn{constructor(){this.transformations=[],this.analysisCache=new Map}trackTransformation(e){this.transformations.push(e)}getTransformations(){return this.transformations}getAnalysis(e){return this.analysisCache.get(e)}setAnalysis(e,t){this.analysisCache.set(e,t)}}class nn{constructor(e){this.steps=e}optimize(e){const t=new tn,n=[];let s=e;for(const o of this.steps){const e=this.countInstructions(s),i=this.countBlocks(s),r=t.getTransformations().length;s=o.run(s,t);const a=this.countInstructions(s),c=this.countBlocks(s),l=t.getTransformations().length;n.push({passName:o.name,instructionsRemoved:Math.max(0,e-a),instructionsAdded:Math.max(0,a-e),blocksRemoved:Math.max(0,i-c),blocksAdded:Math.max(0,c-i),transformations:l-r})}return{module:s,stats:n,transformations:t.getTransformations()}}countInstructions(e){let t=0;for(const n of e.main.blocks.values())t+=n.instructions.length,t+=1;if(e.create)for(const n of e.create.blocks.values())t+=n.instructions.length,t+=1;if(e.functions)for(const n of e.functions.values())for(const e of n.blocks.values())t+=e.instructions.length,t+=1;return t}countBlocks(e){let t=e.main.blocks.size;if(e.create&&(t+=e.create.blocks.size),e.functions)for(const n of e.functions.values())t+=n.blocks.size;return t}}class sn{processAllFunctions(e,t){if(t(e.main,"main"),e.create&&t(e.create,"create"),e.functions)for(const[n,s]of e.functions.entries())t(s,n)}cloneModule(e){const t=this.cloneFunction(e.main);let n;e.create&&(n=this.cloneFunction(e.create));const s=new Map;if(e.functions)for(const[o,i]of e.functions.entries())s.set(o,this.cloneFunction(i));return{name:e.name,functions:s,create:n,main:t,loc:e.loc}}cloneFunction(e){const t=new Map;for(const[n,s]of e.blocks.entries())t.set(n,{id:s.id,phis:s.phis?[...s.phis]:[],instructions:[...s.instructions],terminator:{...s.terminator},predecessors:new Set(s.predecessors),debug:s.debug});return{name:e.name,parameters:[...e.parameters],entry:e.entry,blocks:t}}replaceInstruction(e,t,n,s,o){const i=[...e],r=e[t];return null===n?(i.splice(t,1),s.trackTransformation({type:"delete",pass:this.name,original:D(r),result:[],reason:o})):(i[t]=n,s.trackTransformation({type:"replace",pass:this.name,original:D(r),result:D(n),reason:o})),i}}var on=n(51329);class rn extends sn{constructor(){super(...arguments),this.name="constant-folding"}run(e,t){const n=this.cloneModule(e);return this.processAllFunctions(n,(e=>{const n=new Map;for(const s of e.blocks.values()){const e=[];for(let o=0;o<s.instructions.length;o++){const i=s.instructions[o];if("const"===i.kind)"dest"in i&&n.set(i.dest,i.value),e.push(i);else if("binary"===i.kind&&this.canFoldBinary(i,n)){const s=this.foldBinary(i,n);s?(e.push(s),"const"===s.kind&&n.set(s.dest,s.value),t.trackTransformation({type:"replace",pass:this.name,original:D(i),result:D(s),reason:`Folded ${i.op} operation on constants`})):e.push(i)}else if("hash"===i.kind&&this.canFoldHash(i,n)){const s=this.foldHash(i,n);s?(e.push(s),"const"===s.kind&&n.set(s.dest,s.value),t.trackTransformation({type:"replace",pass:this.name,original:D(i),result:D(s),reason:"Evaluated keccak256 on constant"})):e.push(i)}else if("length"===i.kind&&this.canFoldLength(i)){const s=this.foldLength(i);s?(e.push(s),"const"===s.kind&&n.set(s.dest,s.value),t.trackTransformation({type:"replace",pass:this.name,original:D(i),result:D(s),reason:"Evaluated length of fixed-size array"})):e.push(i)}else e.push(i)}s.instructions=e}})),n}canFoldBinary(e,t){if("binary"!==e.kind)return!1;const n=this.getConstantValue(e.left,t),s=this.getConstantValue(e.right,t);return void 0!==n&&void 0!==s}foldBinary(e,t){const n=this.getConstantValue(e.left,t),s=this.getConstantValue(e.right,t);if(void 0===n||void 0===s)return null;const o=this.evaluateBinary(e.op,n,s);return void 0===o?null:{kind:"const",value:o,type:this.getResultType(e.op,typeof o),dest:e.dest,operationDebug:A(e)}}getConstantValue(e,t){return"const"===e.kind?e.value:"temp"===e.kind?t.get(e.id):void 0}evaluateBinary(e,t,n){if("bigint"==typeof t&&"bigint"==typeof n)switch(e){case"add":return t+n;case"sub":return t-n;case"mul":return t*n;case"div":return 0n!==n?t/n:void 0;case"mod":return 0n!==n?t%n:void 0;case"shl":return t<<n;case"shr":return t>>n;case"lt":return t<n;case"gt":return t>n;case"le":return t<=n;case"ge":return t>=n;case"eq":return t===n;case"ne":return t!==n}if("boolean"==typeof t&&"boolean"==typeof n)switch(e){case"and":return t&&n;case"or":return t||n;case"eq":return t===n;case"ne":return t!==n}if("or"===e||"shl"===e||"shr"===e){const s="boolean"==typeof t?t?1n:0n:t,o="boolean"==typeof n?n?1n:0n:n;if("bigint"==typeof s&&"bigint"==typeof o)switch(e){case"or":return s|o;case"shl":return s<<o;case"shr":return s>>o}}}getResultType(e,t){return"boolean"===t?v.Scalar.bool:"bigint"===t?v.Scalar.uint256:v.Scalar.bool}canFoldHash(e,t){if("hash"!==e.kind)return!1;return"string"==typeof this.getConstantValue(e.value,t)}foldHash(e,t){const n=this.getConstantValue(e.value,t);if("string"!=typeof n)return null;const s=(new TextEncoder).encode(n),o=(0,on.So)(s);let i=0n;for(let r=0;r<o.length;r++)i=i<<8n|BigInt(o[r]);return{kind:"const",value:i,type:v.Scalar.bytes32,dest:e.dest,operationDebug:A(e)}}canFoldLength(e){return e.kind,!1}foldLength(e){return null}}class an extends sn{constructor(){super(...arguments),this.name="dead-code-elimination"}run(e,t){const n=this.cloneModule(e);return this.processAllFunctions(n,(e=>{const n=new Set;for(const t of e.blocks.values()){if(t.phis)for(const e of t.phis)this.collectUsedValues(e,n);for(const e of t.instructions)this.collectUsedValues(e,n);if("branch"===t.terminator.kind)this.collectValueUse(t.terminator.condition,n);else if("return"===t.terminator.kind&&t.terminator.value)this.collectValueUse(t.terminator.value,n);else if("call"===t.terminator.kind)for(const e of t.terminator.arguments)this.collectValueUse(e,n)}for(const s of e.blocks.values()){if(s.phis){const e=s.phis.filter((e=>!!n.has(e.dest)||(t.trackTransformation({type:"delete",pass:this.name,original:D(e),result:[],reason:`Removed unused phi node: ${e.dest}`}),!1)));s.phis=e}const e=[];for(const o of s.instructions)this.hasSideEffects(o)?e.push(o):"dest"in o&&o.dest&&!n.has(o.dest)?t.trackTransformation({type:"delete",pass:this.name,original:D(o),result:[],reason:`Removed unused instruction: ${o.kind} -> ${o.dest}`}):e.push(o);s.instructions=e}})),n}collectUsedValues(e,t){switch(e.kind){case"binary":this.collectValueUse(e.left,t),this.collectValueUse(e.right,t);break;case"unary":this.collectValueUse(e.operand,t);break;case"write":e.slot&&this.collectValueUse(e.slot,t),e.value&&this.collectValueUse(e.value,t),e.offset&&this.collectValueUse(e.offset,t),e.length&&this.collectValueUse(e.length,t);break;case"read":e.slot&&this.collectValueUse(e.slot,t),e.offset&&this.collectValueUse(e.offset,t),e.length&&this.collectValueUse(e.length,t);break;case"compute_slot":this.collectValueUse(e.base,t),w.ComputeSlot.isMapping(e)?this.collectValueUse(e.key,t):w.ComputeSlot.isArray(e);break;case"hash":case"cast":this.collectValueUse(e.value,t);break;case"length":this.collectValueUse(e.object,t);break;case"compute_offset":this.collectValueUse(e.base,t),w.ComputeOffset.isArray(e)?this.collectValueUse(e.index,t):w.ComputeOffset.isByte(e)&&this.collectValueUse(e.offset,t);break;case"allocate":this.collectValueUse(e.size,t);break;case"phi":for(const n of e.sources.values())this.collectValueUse(n,t)}}collectValueUse(e,t){"temp"===e.kind&&t.add(e.id)}hasSideEffects(e){switch(e.kind){case"write":case"allocate":return!0;default:return!1}}}class cn extends sn{constructor(){super(...arguments),this.name="common-subexpression-elimination"}run(e,t){const n=this.cloneModule(e);return this.processAllFunctions(n,(n=>{const s=(new T.Analyzer).analyze({...e,main:n}).dominatorTree,o=new Map,i=new Map,r=this.topologicalSort(n);for(const e of r){const r=n.blocks.get(e);if(!r)continue;const a=new Map,c=[];for(const n of r.instructions){const r=this.applyReplacements(n,o);if("binary"===r.kind||"unary"===r.kind||"compute_slot"===r.kind||"env"===r.kind){const n=this.getExpressionKey(r),l="compute_slot"===r.kind||"env"===r.kind;let u;if(l){const t=i.get(n);u=t&&this.dominates(t.block,e,s)?t.instruction:a.get(n)}else u=a.get(n);u&&"dest"in r&&"dest"in u?(u.operationDebug=N(u.operationDebug,r.operationDebug),o.set(r.dest,u.dest),t.trackTransformation({type:"delete",pass:this.name,original:D(r),result:[],reason:`Eliminated duplicate computation: ${n}`})):("dest"in r&&n&&(a.set(n,r),l&&i.set(n,{instruction:r,block:e})),c.push(r))}else this.hasSideEffects(r)?(a.clear(),c.push(r)):c.push(r)}r.instructions=c}for(const e of n.blocks.values()){for(const t of e.phis)if(t.sources)for(const[e,n]of t.sources){const s=this.applyValueReplacement(n,o);t.sources.set(e,s)}"branch"===e.terminator.kind?e.terminator.condition=this.applyValueReplacement(e.terminator.condition,o):"return"===e.terminator.kind&&e.terminator.value&&(e.terminator.value=this.applyValueReplacement(e.terminator.value,o))}})),n}applyValueReplacement(e,t){return"temp"===e.kind&&t.has(e.id)?{kind:"temp",id:t.get(e.id),type:e.type}:e}applyReplacements(e,t){const n={...e},s=e=>"temp"===e.kind&&t.has(e.id)?{kind:"temp",id:t.get(e.id),type:e.type}:e;switch(n.kind){case"binary":n.left=s(n.left),n.right=s(n.right);break;case"unary":n.operand=s(n.operand);break;case"write":n.slot&&(n.slot=s(n.slot)),n.value&&(n.value=s(n.value)),n.offset&&(n.offset=s(n.offset)),n.length&&(n.length=s(n.length));break;case"read":n.slot&&(n.slot=s(n.slot)),n.offset&&(n.offset=s(n.offset)),n.length&&(n.length=s(n.length));break;case"compute_slot":n.base=s(n.base),w.ComputeSlot.isMapping(n)?n.key=s(n.key):w.ComputeSlot.isArray(n);break;case"hash":n.value=s(n.value);break;case"length":n.object=s(n.object)}return n}getExpressionKey(e){if("binary"===e.kind){const t=this.getValueKey(e.left),n=this.getValueKey(e.right),s=this.getTypeKey(e.left.type),o=this.getTypeKey(e.right.type);return this.isCommutative(e.op)&&t>n?`${e.op}(${n}:${o},${t}:${s})`:`${e.op}(${t}:${s},${n}:${o})`}if("unary"===e.kind){const t=this.getValueKey(e.operand),n=this.getTypeKey(e.operand.type);return`${e.op}(${t}:${n})`}if("compute_slot"===e.kind){const t=this.getValueKey(e.base);if("field"===e.slotKind)return`compute_slot:field(${t},${e.fieldOffset})`;if("mapping"===e.slotKind){return`compute_slot:mapping(${t},${this.getValueKey(e.key)}:${e.keyType?this.getTypeKey(e.keyType):"unknown"})`}if("array"===e.slotKind)return`compute_slot:array(${t})`}else if("env"===e.kind)return`env:${e.op}`;return""}getValueKey(e){return"const"===e.kind?`const:${e.value}`:"temp"===e.kind?`temp:${e.id}`:"unknown"}getTypeKey(e){if(!e)return"unknown";switch(e.kind){case"scalar":return`scalar:${e.size}`;case"ref":return`ref:${e.location}`;default:return"unknown"}}isCommutative(e){return["add","mul","eq","ne","and","or"].includes(e)}hasSideEffects(e){return"write"===e.kind}topologicalSort(e){const t=new Set,n=[],s=o=>{if(t.has(o))return;t.add(o),n.push(o);const i=e.blocks.get(o);if(!i)return;const r=this.getSuccessors(i);for(const e of r)s(e)};s(e.entry);for(const o of e.blocks.keys())s(o);return n}getSuccessors(e){switch(e.terminator.kind){case"jump":return[e.terminator.target];case"branch":return[e.terminator.trueTarget,e.terminator.falseTarget];case"call":return[e.terminator.continuation];default:return[]}}dominates(e,t,n){let s=t;for(;null!==s;){if(s===e)return!0;s=n[s]||null}return!1}}class ln extends sn{constructor(){super(...arguments),this.name="constant-propagation"}run(e,t){const n=this.cloneModule(e);return this.processAllFunctions(n,(e=>{const n=new Map,s=new Map;for(const o of e.blocks.values()){const e=[];for(const i of o.instructions){let o=i;if("const"===i.kind&&"dest"in i)n.set(i.dest,i.value),i.operationDebug&&s.set(i.dest,i.operationDebug);else{const e=this.propagateConstantsIntoInstruction(i,n,s);e!==i&&(o=e,t.trackTransformation({type:"replace",pass:this.name,original:D(i),result:D(o),reason:"Propagated constants into instruction operands"})),this.hasSideEffects(i)&&(n.clear(),s.clear())}e.push(o)}o.instructions=e}})),n}propagateConstantsIntoInstruction(e,t,n){const s={...e},o=[],i=e=>{if("temp"===e.kind){const s=t.get(e.id);if(void 0!==s){const t=n.get(e.id);return t&&o.push(t),{kind:"const",value:s,type:e.type||this.getTypeForValue(s)}}}return e};switch(s.kind){case"binary":s.left=i(s.left),s.right=i(s.right);break;case"unary":s.operand=i(s.operand);break;case"write":s.slot&&(s.slot=i(s.slot)),s.value&&(s.value=i(s.value)),s.offset&&(s.offset=i(s.offset)),s.length&&(s.length=i(s.length));break;case"read":s.slot&&(s.slot=i(s.slot)),s.offset&&(s.offset=i(s.offset)),s.length&&(s.length=i(s.length));break;case"compute_slot":s.base=i(s.base),w.ComputeSlot.isMapping(s)?s.key=i(s.key):w.ComputeSlot.isArray(s);break;case"hash":case"cast":s.value=i(s.value);break;case"compute_offset":s.base=i(s.base),w.ComputeOffset.isArray(s)?s.index=i(s.index):w.ComputeOffset.isByte(s)&&(s.offset=i(s.offset));break;case"allocate":s.size=i(s.size);break;case"length":s.object=i(s.object)}const r=o.length>0;return r&&(s.operationDebug=N(e.operationDebug,...o)),r?s:e}getTypeForValue(e){return"boolean"==typeof e?v.Scalar.bool:"bigint"==typeof e?v.Scalar.uint256:v.Ref.memory()}hasSideEffects(e){return"write"===e.kind}}class un extends sn{constructor(){super(...arguments),this.name="jump-optimization"}run(e,t){const n=this.cloneModule(e);return this.processAllFunctions(n,(e=>{const n=new Map;for(const[t,r]of e.blocks)0===r.instructions.length&&"jump"===r.terminator.kind&&n.set(t,r.terminator.target);const s=new Map;for(const[r,a]of e.blocks)if("jump"===a.terminator.kind){const e=a.terminator.target,o=this.resolveJumpChain(e,n);o!==e&&(s.has(o)||s.set(o,new Map),s.get(o).set(r,e),t.trackTransformation({type:"replace",pass:this.name,original:D(a),result:D(a),reason:`Optimized jump chain: ${e} -> ${o}`}),a.terminator.target=o)}else if("branch"===a.terminator.kind){const e=a.terminator.trueTarget,o=this.resolveJumpChain(e,n),i=a.terminator.falseTarget,c=this.resolveJumpChain(i,n);o!==e&&(s.has(o)||s.set(o,new Map),s.get(o).set(r,e),t.trackTransformation({type:"replace",pass:this.name,original:D(a),result:D(a),reason:`Optimized true branch jump chain: ${e} -> ${o}`}),a.terminator.trueTarget=o),c!==i&&(s.has(c)||s.set(c,new Map),s.get(c).set(r,i),t.trackTransformation({type:"replace",pass:this.name,original:D(a),result:D(a),reason:`Optimized false branch jump chain: ${i} -> ${c}`}),a.terminator.falseTarget=c)}this.updatePhisForRedirections(e,s,n);const o=this.findReachableBlocks(e),i=[];for(const r of e.blocks.keys())if(!o.has(r)){i.push(r);const n=e.blocks.get(r);t.trackTransformation({type:"delete",pass:this.name,original:D(n),result:[],reason:`Removed unreachable block ${r}`})}for(const t of i)e.blocks.delete(t)})),n}resolveJumpChain(e,t){const n=new Set;let s=e;for(;t.has(s)&&!n.has(s);)n.add(s),s=t.get(s);return s}updatePhisForRedirections(e,t,n){for(const[s,o]of t){const t=e.blocks.get(s);if(!t)continue;for(const s of t.phis){const t=new Map(s.sources);for(const[i,r]of o)if(s.sources.has(r)){const o=s.sources.get(r),a=e.blocks.get(r);a&&a.phis.length,t.set(i,o),n.has(r)&&t.delete(r)}s.sources=t}const i=new Set;for(const e of t.predecessors){let t=!1;for(const[n,s]of o)s===e&&(i.add(n),t=!0);t||n.has(e)||i.add(e)}for(const e of o.keys())i.add(e);t.predecessors=i}}findReachableBlocks(e){const t=new Set,n=[e.entry];for(;n.length>0;){const s=n.pop();if(t.has(s))continue;t.add(s);const o=e.blocks.get(s);o&&("jump"===o.terminator.kind?n.push(o.terminator.target):"branch"===o.terminator.kind?(n.push(o.terminator.trueTarget),n.push(o.terminator.falseTarget)):"call"===o.terminator.kind&&n.push(o.terminator.continuation))}return t}}class dn extends sn{constructor(){super(...arguments),this.name="block-merging"}run(e,t){const n=this.cloneModule(e);return this.processAllFunctions(n,(e=>{const n=new Map;for(const[t,s]of e.blocks)if("jump"===s.terminator.kind&&1===s.predecessors.size){const o=e.blocks.get(s.terminator.target);o&&1===o.predecessors.size&&n.set(s.terminator.target,t)}for(const[s,o]of n){const n=e.blocks.get(s),i=e.blocks.get(o);if(n&&i){n.phis&&i.phis&&i.phis.push(...n.phis),i.instructions.push(...n.instructions),i.terminator=n.terminator,i.debug=N(i.debug,n.debug),t.trackTransformation({type:"merge",pass:this.name,original:D(i,n),result:D(i),reason:`Merged block ${s} into ${o}`}),e.blocks.delete(s);for(const t of e.blocks.values())t.predecessors.has(s)&&(t.predecessors.delete(s),t.predecessors.add(o)),"jump"===t.terminator.kind&&t.terminator.target===s?t.terminator.target=o:"branch"===t.terminator.kind&&(t.terminator.trueTarget===s&&(t.terminator.trueTarget=o),t.terminator.falseTarget===s&&(t.terminator.falseTarget=o))}}})),n}}class pn extends sn{constructor(){super(...arguments),this.name="return-merging"}run(e,t){const n=this.cloneModule(e);return this.processAllFunctions(n,(e=>{const n=new Map;for(const[t,s]of e.blocks)if("return"===s.terminator.kind){const e=this.getReturnSignature(s.terminator.value);n.has(e)||n.set(e,[]),n.get(e).push(t)}for(const[,s]of n)if(s.length>1){const n=s[0],o=e.blocks.get(n);for(let i=1;i<s.length;i++){const r=s[i],a=e.blocks.get(r);if(0===a.instructions.length){for(const[,s]of e.blocks)"jump"===s.terminator.kind&&s.terminator.target===r?(s.terminator.target=n,t.trackTransformation({type:"replace",pass:this.name,original:D(s),result:D(s),reason:`Redirected jump from ${r} to ${n} (return merging)`})):"branch"===s.terminator.kind&&(s.terminator.trueTarget===r&&(s.terminator.trueTarget=n,t.trackTransformation({type:"replace",pass:this.name,original:D(s),result:D(s),reason:`Redirected true branch from ${r} to ${n} (return merging)`})),s.terminator.falseTarget===r&&(s.terminator.falseTarget=n,t.trackTransformation({type:"replace",pass:this.name,original:D(s),result:D(s),reason:`Redirected false branch from ${r} to ${n} (return merging)`})));for(const e of a.predecessors)o.predecessors.add(e);o.predecessors.delete(r);for(const[,t]of e.blocks)t.predecessors.has(r)&&(t.predecessors.delete(r),t.predecessors.add(n));e.blocks.delete(r),t.trackTransformation({type:"delete",pass:this.name,original:D(a),result:[],reason:`Merged return block ${r} into ${n}`})}}}})),n}getReturnSignature(e){return e?"const"===e.kind?`const:${e.type.kind}:${e.value}`:"temp"===e.kind?`temp:${e.id}`:"unknown":"void"}}class mn extends sn{constructor(){super(...arguments),this.name="read-write-merging",this.nextTempCounter=0}run(e,t){const n=this.cloneModule(e);return this.nextTempCounter=this.findHighestTempNumber(n)+1,this.processAllFunctions(n,(e=>{for(const n of e.blocks.values()){const e=[];let s=0;for(;s<n.instructions.length;){const o=n.instructions[s];if("write"===o.kind){const i=this.findMergeableWrites(n.instructions,s);if(i.length>1){const n=this.mergeWrites(i,t);e.push(...n),s+=i.length}else e.push(o),s++}else e.push(o),s++}n.instructions=e}})),n}findHighestTempNumber(e){let t=-1;const n=e=>{if("temp"===e.kind){const n=e.id.match(/^t(\d+)$/);n&&(t=Math.max(t,parseInt(n[1],10)))}},s=e=>{if("dest"in e&&"string"==typeof e.dest){const n=e.dest.match(/^t(\d+)$/);n&&(t=Math.max(t,parseInt(n[1],10)))}"left"in e&&e.left&&"object"==typeof e.left&&n(e.left),"right"in e&&e.right&&"object"==typeof e.right&&n(e.right),"value"in e&&e.value&&"object"==typeof e.value&&n(e.value),"operand"in e&&e.operand&&"object"==typeof e.operand&&n(e.operand),"slot"in e&&e.slot&&"object"==typeof e.slot&&n(e.slot),"offset"in e&&e.offset&&"object"==typeof e.offset&&n(e.offset),"length"in e&&e.length&&"object"==typeof e.length&&n(e.length),"base"in e&&e.base&&"object"==typeof e.base&&n(e.base),"key"in e&&e.key&&"object"==typeof e.key&&n(e.key),"index"in e&&e.index&&"object"==typeof e.index&&n(e.index),"size"in e&&e.size&&"object"==typeof e.size&&n(e.size),"object"in e&&e.object&&"object"==typeof e.object&&n(e.object)};return this.processAllFunctions(e,(e=>{for(const o of e.blocks.values()){if(o.phis)for(const e of o.phis){const s=e.dest.match(/^t(\d+)$/);s&&(t=Math.max(t,parseInt(s[1],10)));for(const t of e.sources.values())n(t)}for(const e of o.instructions)s(e);"condition"in o.terminator&&o.terminator.condition&&n(o.terminator.condition),"value"in o.terminator&&o.terminator.value&&n(o.terminator.value)}})),t}findMergeableWrites(e,t){const n=[],s=e[t];if("write"!==s.kind)return n;n.push(s);for(let o=t+1;o<e.length;o++){const t=e[o];if("write"!==t.kind)break;if(!this.canMergeWith(s,t))break;n.push(t)}return n}canMergeWith(e,t){return e.location===t.location&&(("storage"===e.location||"transient"===e.location)&&(!(!e.slot||!t.slot)&&(!!this.isSameValue(e.slot,t.slot)&&("const"===e.offset?.kind&&"const"===e.length?.kind&&"const"===t.offset?.kind&&"const"===t.length?.kind))))}isSameValue(e,t){return e.kind===t.kind&&("const"===e.kind&&"const"===t.kind?e.value===t.value:"temp"===e.kind&&"temp"===t.kind&&e.id===t.id)}mergeWrites(e,t){if(1===e.length)return e;const n=e.map((e=>({write:e,offset:"const"===e.offset?.kind?BigInt(e.offset.value):0n,length:"const"===e.length?.kind?BigInt(e.length.value):32n})));n.sort(((e,t)=>Number(e.offset-t.offset)));if(!this.areWritesAdjacent(n))return e;const s=[];let o=this.nextTempCounter,i=null,r={};for(let u=0;u<n.length;u++){const e=n[u],t=8n*e.offset;if(r=N(r,e.write.operationDebug),t>0n){const n="t"+o++;s.push({kind:"binary",op:"shl",left:e.write.value,right:{kind:"const",value:t,type:v.Scalar.uint256},dest:n,operationDebug:r});const a={kind:"temp",id:n,type:v.Scalar.uint256};if(null===i)i=a;else{const e="t"+o++;s.push({kind:"binary",op:"or",left:i,right:a,dest:e,operationDebug:r}),i={kind:"temp",id:e,type:v.Scalar.uint256}}}else if(null===i)i=e.write.value;else{const t="t"+o++;s.push({kind:"binary",op:"or",left:i,right:e.write.value,dest:t,operationDebug:r}),i={kind:"temp",id:t,type:v.Scalar.uint256}}}const a=n[0].offset,c=n.reduce(((e,t)=>{const n=t.offset+t.length;return n>e?n:e}),a+n[0].length)-a,l={kind:"write",location:e[0].location,slot:e[0].slot,offset:a>0n?{kind:"const",value:a,type:v.Scalar.uint256}:void 0,length:{kind:"const",value:c,type:v.Scalar.uint256},value:i,operationDebug:r};return s.push(l),this.nextTempCounter=o,t.trackTransformation({type:"merge",pass:this.name,original:D(...e),result:D(...s),reason:`Merged ${e.length} writes to same location`}),s}areWritesAdjacent(e){for(let t=1;t<e.length;t++){const n=e[t-1];if(e[t].offset>n.offset+n.length)return!1}return!0}}class fn extends sn{constructor(){super(...arguments),this.name="tail-call-optimization"}run(e,t){const n=this.cloneModule(e);return this.processAllFunctions(n,((e,n)=>{const s=new Set,o=[];for(const[t,i]of e.blocks){if("call"!==i.terminator.kind)continue;const s=i.terminator;if(s.function!==n)continue;const r=e.blocks.get(s.continuation);if(!r)continue;if(r.phis.length>0||r.instructions.length>0||"return"!==r.terminator.kind)continue;const a=r.terminator;(void 0===s.dest&&void 0===a.value||void 0!==s.dest&&void 0!==a.value&&"temp"===a.value.kind&&a.value.id===s.dest)&&o.push(t)}if(o.length>0){const i=`${e.entry}_loop`;if(!e.blocks.get(e.entry))return;const r=[];for(let t=0;t<e.parameters.length;t++){const n=e.parameters[t],s=new Map;s.set(e.entry,{kind:"temp",id:n.tempId,type:n.type}),r.push({kind:"phi",sources:s,dest:`${n.tempId}_loop`,type:n.type,operationDebug:{context:void n.loc}})}const a={id:i,phis:r,instructions:[],terminator:{kind:"jump",target:e.entry,operationDebug:{}},predecessors:new Set([e.entry,...o]),debug:{}};e.blocks.set(i,a);for(const c of o){const o=e.blocks.get(c),a=o.terminator,l=e.blocks.get(a.continuation);for(let t=0;t<e.parameters.length;t++)t<a.arguments.length&&r[t].sources.set(c,a.arguments[t]);o.terminator={kind:"jump",target:i,operationDebug:a.operationDebug},t.trackTransformation({type:"replace",pass:this.name,original:[...D(o),...D(l)],result:D(o),reason:`Optimized tail-recursive call to ${n} into loop`});0===Array.from(l.predecessors).filter((e=>e!==c)).length?(s.add(a.continuation),t.trackTransformation({type:"delete",pass:this.name,original:D(l),result:[],reason:`Removed unused continuation block ${a.continuation}`})):l.predecessors.delete(c)}}for(const t of s)e.blocks.delete(t);for(const t of e.blocks.values())for(const e of s)t.predecessors.delete(e)})),n}}function yn(e,t){if(0===t)return e;const n=function(e){const t=[];if(0===e)return t;e>=1&&t.push(new rn,new ln,new an);e>=2&&t.push(new cn,new fn,new un);e>=3&&t.push(new dn,new pn,new mn);return t}(t),s=new nn(n);let o=e,i="";do{const e=JSON.stringify(o);if(e===i)break;i=e;o=s.optimize(o).module}while(t>=2);return o}const gn={async run({source:e}){const t=z(e);return L.map(t,(e=>({ast:e})))}},bn={run:async({ast:e})=>L.map(ct(e),(({types:e,bindings:t})=>({types:e,bindings:t})))},hn={run:async({ast:e,types:t})=>L.map(en(e,t),(e=>({ir:e})))},kn={run:async({ir:e,optimizer:{level:t=0}={}})=>L.ok({ir:yn(e,t)})},vn=E.makeControls({slice:(e,...t)=>({...e,stack:e.stack.slice(...t),brands:e.brands.slice(...t)}),prepend:(e,t)=>({...e,stack:[{id:t.id},...e.stack],brands:[t.brand,...e.brands]}),create:(e,t)=>({id:e,brand:t}),duplicate:(e,t)=>({...e,id:t}),rebrand:(e,t)=>({...e,brand:t}),readTop:(e,t)=>{const n=[];for(let s=0;s<t&&s<e.stack.length;s++)n.push({...e.stack[s],brand:e.brands[s]});return n},generateId:(e,t="id")=>({id:`${t}_${e.nextId}`,state:{...e,nextId:e.nextId+1}}),emit:(e,t)=>({...e,instructions:[...e.instructions,t]})}),xn=O(vn),wn=xn.rebrand,Tn=xn.rebrandTop,En=(e=>()=>new _(e,(e=>e)))(vn),Sn=(e=>{const{mapInstruction:t,makeOperationForInstruction:n,makeOperationWithImmediatesForInstruction:s}=S.makeUsing(e);return{...t({opcode:0,mnemonic:"STOP"},n({consumes:[],produces:[]})),...t({opcode:1,mnemonic:"ADD"},n({consumes:["a","b"],produces:["a + b"]})),...t({opcode:2,mnemonic:"MUL"},n({consumes:["a","b"],produces:["a * b"]})),...t({opcode:3,mnemonic:"SUB"},n({consumes:["a","b"],produces:["a - b"]})),...t({opcode:4,mnemonic:"DIV"},n({consumes:["a","b"],produces:["a // b"]})),...t({opcode:5,mnemonic:"SDIV"},n({consumes:["a","b"],produces:["a // b"]})),...t({opcode:6,mnemonic:"MOD"},n({consumes:["a","b"],produces:["a % b"]})),...t({opcode:7,mnemonic:"SMOD"},n({consumes:["a","b"],produces:["a % b"]})),...t({opcode:8,mnemonic:"ADDMOD"},n({consumes:["a","b","N"],produces:["(a + b) % N"]})),...t({opcode:9,mnemonic:"MULMOD"},n({consumes:["a","b","N"],produces:["(a * b) % N"]})),...t({opcode:10,mnemonic:"EXP"},n({consumes:["a","exponent"],produces:["a ** exponent"]})),...t({opcode:11,mnemonic:"SIGNEXTEND"},n({consumes:["b","x"],produces:["y"]})),...t({opcode:16,mnemonic:"LT"},n({consumes:["a","b"],produces:["a < b"]})),...t({opcode:17,mnemonic:"GT"},n({consumes:["a","b"],produces:["a > b"]})),...t({opcode:18,mnemonic:"SLT"},n({consumes:["a","b"],produces:["a < b"]})),...t({opcode:19,mnemonic:"SGT"},n({consumes:["a","b"],produces:["a > b"]})),...t({opcode:20,mnemonic:"EQ"},n({consumes:["a","b"],produces:["a == b"]})),...t({opcode:21,mnemonic:"ISZERO"},n({consumes:["a"],produces:["a == 0"]})),...t({opcode:22,mnemonic:"AND"},n({consumes:["a","b"],produces:["a & b"]})),...t({opcode:23,mnemonic:"OR"},n({consumes:["a","b"],produces:["a | b"]})),...t({opcode:24,mnemonic:"XOR"},n({consumes:["a","b"],produces:["a ^ b"]})),...t({opcode:25,mnemonic:"NOT"},n({consumes:["a"],produces:["~a"]})),...t({opcode:26,mnemonic:"BYTE"},n({consumes:["i","x"],produces:["y"]})),...t({opcode:27,mnemonic:"SHL"},n({consumes:["shift","value"],produces:["value << shift"]})),...t({opcode:28,mnemonic:"SHR"},n({consumes:["shift","value"],produces:["value >> shift"]})),...t({opcode:29,mnemonic:"SAR"},n({consumes:["shift","value"],produces:["value >> shift"]})),...t({opcode:32,mnemonic:"KECCAK256"},n({consumes:["offset","size"],produces:["hash"]})),...t({opcode:48,mnemonic:"ADDRESS"},n({consumes:[],produces:["address"]})),...t({opcode:49,mnemonic:"BALANCE"},n({consumes:["address"],produces:["balance"]})),...t({opcode:50,mnemonic:"ORIGIN"},n({consumes:[],produces:["address"]})),...t({opcode:51,mnemonic:"CALLER"},n({consumes:[],produces:["address"]})),...t({opcode:52,mnemonic:"CALLVALUE"},n({consumes:[],produces:["value"]})),...t({opcode:53,mnemonic:"CALLDATALOAD"},n({consumes:["i"],produces:["data[i]"]})),...t({opcode:54,mnemonic:"CALLDATASIZE"},n({consumes:[],produces:["size"]})),...t({opcode:55,mnemonic:"CALLDATACOPY"},n({consumes:["destOffset","offset","size"],produces:[]})),...t({opcode:56,mnemonic:"CODESIZE"},n({consumes:[],produces:["size"]})),...t({opcode:57,mnemonic:"CODECOPY"},n({consumes:["destOffset","offset","size"],produces:[]})),...t({opcode:58,mnemonic:"GASPRICE"},n({consumes:[],produces:["price"]})),...t({opcode:59,mnemonic:"EXTCODESIZE"},n({consumes:["address"],produces:["size"]})),...t({opcode:60,mnemonic:"EXTCODECOPY"},n({consumes:["address","destOffset","offset","size"],produces:[]})),...t({opcode:61,mnemonic:"RETURNDATASIZE"},n({consumes:[],produces:["size"]})),...t({opcode:62,mnemonic:"RETURNDATACOPY"},n({consumes:["destOffset","offset","size"],produces:[]})),...t({opcode:63,mnemonic:"EXTCODEHASH"},n({consumes:["address"],produces:["hash"]})),...t({opcode:64,mnemonic:"BLOCKHASH"},n({consumes:["blockNumber"],produces:["hash"]})),...t({opcode:65,mnemonic:"COINBASE"},n({consumes:[],produces:["address"]})),...t({opcode:66,mnemonic:"TIMESTAMP"},n({consumes:[],produces:["timestamp"]})),...t({opcode:67,mnemonic:"NUMBER"},n({consumes:[],produces:["blockNumber"]})),...t({opcode:68,mnemonic:"PREVRANDAO"},n({consumes:[],produces:["difficulty"]})),...t({opcode:69,mnemonic:"GASLIMIT"},n({consumes:[],produces:["gasLimit"]})),...t({opcode:70,mnemonic:"CHAINID"},n({consumes:[],produces:["chainId"]})),...t({opcode:71,mnemonic:"SELFBALANCE"},n({consumes:[],produces:["balance"]})),...t({opcode:72,mnemonic:"BASEFEE"},n({consumes:[],produces:["baseFee"]})),...t({opcode:73,mnemonic:"BLOBHASH"},n({consumes:["index"],produces:["blobVersionedHashesAtIndex"]})),...t({opcode:74,mnemonic:"BLOBBASEFEE"},n({consumes:[],produces:["blobBaseFee"]})),...t({opcode:80,mnemonic:"POP"},n({consumes:["y"],produces:[]})),...t({opcode:81,mnemonic:"MLOAD"},n({consumes:["offset"],produces:["value"]})),...t({opcode:82,mnemonic:"MSTORE"},n({consumes:["offset","value"],produces:[]})),...t({opcode:83,mnemonic:"MSTORE8"},n({consumes:["offset","value"],produces:[]})),...t({opcode:84,mnemonic:"SLOAD"},n({consumes:["key"],produces:["value"]})),...t({opcode:85,mnemonic:"SSTORE"},n({consumes:["key","value"],produces:[]})),...t({opcode:86,mnemonic:"JUMP"},n({consumes:["counter"],produces:[]})),...t({opcode:87,mnemonic:"JUMPI"},n({consumes:["counter","b"],produces:[]})),...t({opcode:88,mnemonic:"PC"},n({consumes:[],produces:["counter"]})),...t({opcode:89,mnemonic:"MSIZE"},n({consumes:[],produces:["size"]})),...t({opcode:90,mnemonic:"GAS"},n({consumes:[],produces:["gas"]})),...t({opcode:91,mnemonic:"JUMPDEST"},n({consumes:[],produces:[]})),...t({opcode:92,mnemonic:"TLOAD"},n({consumes:["key"],produces:["value"]})),...t({opcode:93,mnemonic:"TSTORE"},n({consumes:["key","value"],produces:[]})),...t({opcode:94,mnemonic:"MCOPY"},n({consumes:["destOffset","offset","size"],produces:[]})),...t({opcode:95,mnemonic:"PUSH0"},n({consumes:[],produces:["value"]})),...t({opcode:96,mnemonic:"PUSH1"},s({consumes:[],produces:["value"]})),...t({opcode:97,mnemonic:"PUSH2"},s({consumes:[],produces:["value"]})),...t({opcode:98,mnemonic:"PUSH3"},s({consumes:[],produces:["value"]})),...t({opcode:99,mnemonic:"PUSH4"},s({consumes:[],produces:["value"]})),...t({opcode:100,mnemonic:"PUSH5"},s({consumes:[],produces:["value"]})),...t({opcode:101,mnemonic:"PUSH6"},s({consumes:[],produces:["value"]})),...t({opcode:102,mnemonic:"PUSH7"},s({consumes:[],produces:["value"]})),...t({opcode:103,mnemonic:"PUSH8"},s({consumes:[],produces:["value"]})),...t({opcode:104,mnemonic:"PUSH9"},s({consumes:[],produces:["value"]})),...t({opcode:105,mnemonic:"PUSH10"},s({consumes:[],produces:["value"]})),...t({opcode:106,mnemonic:"PUSH11"},s({consumes:[],produces:["value"]})),...t({opcode:107,mnemonic:"PUSH12"},s({consumes:[],produces:["value"]})),...t({opcode:108,mnemonic:"PUSH13"},s({consumes:[],produces:["value"]})),...t({opcode:109,mnemonic:"PUSH14"},s({consumes:[],produces:["value"]})),...t({opcode:110,mnemonic:"PUSH15"},s({consumes:[],produces:["value"]})),...t({opcode:111,mnemonic:"PUSH16"},s({consumes:[],produces:["value"]})),...t({opcode:112,mnemonic:"PUSH17"},s({consumes:[],produces:["value"]})),...t({opcode:113,mnemonic:"PUSH18"},s({consumes:[],produces:["value"]})),...t({opcode:114,mnemonic:"PUSH19"},s({consumes:[],produces:["value"]})),...t({opcode:115,mnemonic:"PUSH20"},s({consumes:[],produces:["value"]})),...t({opcode:116,mnemonic:"PUSH21"},s({consumes:[],produces:["value"]})),...t({opcode:117,mnemonic:"PUSH22"},s({consumes:[],produces:["value"]})),...t({opcode:118,mnemonic:"PUSH23"},s({consumes:[],produces:["value"]})),...t({opcode:119,mnemonic:"PUSH24"},s({consumes:[],produces:["value"]})),...t({opcode:120,mnemonic:"PUSH25"},s({consumes:[],produces:["value"]})),...t({opcode:121,mnemonic:"PUSH26"},s({consumes:[],produces:["value"]})),...t({opcode:122,mnemonic:"PUSH27"},s({consumes:[],produces:["value"]})),...t({opcode:123,mnemonic:"PUSH28"},s({consumes:[],produces:["value"]})),...t({opcode:124,mnemonic:"PUSH29"},s({consumes:[],produces:["value"]})),...t({opcode:125,mnemonic:"PUSH30"},s({consumes:[],produces:["value"]})),...t({opcode:126,mnemonic:"PUSH31"},s({consumes:[],produces:["value"]})),...t({opcode:127,mnemonic:"PUSH32"},s({consumes:[],produces:["value"]})),...t({opcode:128,mnemonic:"DUP1"},(t=>n=>s=>{const[o]=e.topN(s,1),{id:i,state:r}=e.generateId(s,"dup"),a=e.push(r,e.duplicate(o,i));return e.emit(a,{...t,...n})})),...t({opcode:129,mnemonic:"DUP2"},(t=>n=>s=>{const[o,i]=e.topN(s,2),{id:r,state:a}=e.generateId(s,"dup"),c=e.push(a,e.duplicate(i,r));return e.emit(c,{...t,...n})})),...t({opcode:130,mnemonic:"DUP3"},(t=>n=>s=>{const[o,i,r]=e.topN(s,3),{id:a,state:c}=e.generateId(s,"dup"),l=e.push(c,e.duplicate(r,a));return e.emit(l,{...t,...n})})),...t({opcode:131,mnemonic:"DUP4"},(t=>n=>s=>{const[o,i,r,a]=e.topN(s,4),{id:c,state:l}=e.generateId(s,"dup"),u=e.push(l,e.duplicate(a,c));return e.emit(u,{...t,...n})})),...t({opcode:132,mnemonic:"DUP5"},(t=>n=>s=>{const[o,i,r,a,c]=e.topN(s,5),{id:l,state:u}=e.generateId(s,"dup"),d=e.push(u,e.duplicate(c,l));return e.emit(d,{...t,...n})})),...t({opcode:133,mnemonic:"DUP6"},(t=>n=>s=>{const[o,i,r,a,c,l]=e.topN(s,6),{id:u,state:d}=e.generateId(s,"dup"),p=e.push(d,e.duplicate(l,u));return e.emit(p,{...t,...n})})),...t({opcode:134,mnemonic:"DUP7"},(t=>n=>s=>{const[o,i,r,a,c,l,u]=e.topN(s,7),{id:d,state:p}=e.generateId(s,"dup"),m=e.push(p,e.duplicate(u,d));return e.emit(m,{...t,...n})})),...t({opcode:135,mnemonic:"DUP8"},(t=>n=>s=>{const[o,i,r,a,c,l,u,d]=e.topN(s,8),{id:p,state:m}=e.generateId(s,"dup"),f=e.push(m,e.duplicate(d,p));return e.emit(f,{...t,...n})})),...t({opcode:136,mnemonic:"DUP9"},(t=>n=>s=>{const[o,i,r,a,c,l,u,d,p]=e.topN(s,9),{id:m,state:f}=e.generateId(s,"dup"),y=e.push(f,e.duplicate(p,m));return e.emit(y,{...t,...n})})),...t({opcode:137,mnemonic:"DUP10"},(t=>n=>s=>{const[o,i,r,a,c,l,u,d,p,m]=e.topN(s,10),{id:f,state:y}=e.generateId(s,"dup"),g=e.push(y,e.duplicate(m,f));return e.emit(g,{...t,...n})})),...t({opcode:138,mnemonic:"DUP11"},(t=>n=>s=>{const[o,i,r,a,c,l,u,d,p,m,f]=e.topN(s,11),{id:y,state:g}=e.generateId(s,"dup"),b=e.push(g,e.duplicate(f,y));return e.emit(b,{...t,...n})})),...t({opcode:139,mnemonic:"DUP12"},(t=>n=>s=>{const[o,i,r,a,c,l,u,d,p,m,f,y]=e.topN(s,12),{id:g,state:b}=e.generateId(s,"dup"),h=e.push(b,e.duplicate(y,g));return e.emit(h,{...t,...n})})),...t({opcode:140,mnemonic:"DUP13"},(t=>n=>s=>{const[o,i,r,a,c,l,u,d,p,m,f,y,g]=e.topN(s,13),{id:b,state:h}=e.generateId(s,"dup"),k=e.push(h,e.duplicate(g,b));return e.emit(k,{...t,...n})})),...t({opcode:141,mnemonic:"DUP14"},(t=>n=>s=>{const[o,i,r,a,c,l,u,d,p,m,f,y,g,b]=e.topN(s,14),{id:h,state:k}=e.generateId(s,"dup"),v=e.push(k,e.duplicate(b,h));return e.emit(v,{...t,...n})})),...t({opcode:142,mnemonic:"DUP15"},(t=>n=>s=>{const[o,i,r,a,c,l,u,d,p,m,f,y,g,b,h]=e.topN(s,15),{id:k,state:v}=e.generateId(s,"dup"),x=e.push(v,e.duplicate(h,k));return e.emit(x,{...t,...n})})),...t({opcode:143,mnemonic:"DUP16"},(t=>n=>s=>{const[o,i,r,a,c,l,u,d,p,m,f,y,g,b,h,k]=e.topN(s,16),{id:v,state:x}=e.generateId(s,"dup"),w=e.push(x,e.duplicate(k,v));return e.emit(w,{...t,...n})})),...t({opcode:144,mnemonic:"SWAP1"},(t=>n=>s=>{const[o,i]=e.topN(s,2);let r=e.popN(s,2);return r=e.push(r,o),r=e.push(r,i),e.emit(r,{...t,...n})})),...t({opcode:145,mnemonic:"SWAP2"},(t=>n=>s=>{const[o,i,r]=e.topN(s,3);let a=e.popN(s,3);return a=e.push(a,o),a=e.push(a,i),a=e.push(a,r),e.emit(a,{...t,...n})})),...t({opcode:146,mnemonic:"SWAP3"},(t=>n=>s=>{const[o,i,r,a]=e.topN(s,4);let c=e.popN(s,4);return c=e.push(c,o),c=e.push(c,r),c=e.push(c,i),c=e.push(c,a),e.emit(c,{...t,...n})})),...t({opcode:147,mnemonic:"SWAP4"},(t=>n=>s=>{const[o,i,r,a,c]=e.topN(s,5);let l=e.popN(s,5);return l=e.push(l,o),l=e.push(l,a),l=e.push(l,r),l=e.push(l,i),l=e.push(l,c),e.emit(l,{...t,...n})})),...t({opcode:148,mnemonic:"SWAP5"},(t=>n=>s=>{const[o,i,r,a,c,l]=e.topN(s,6);let u=e.popN(s,6);return u=e.push(u,o),u=e.push(u,c),u=e.push(u,a),u=e.push(u,r),u=e.push(u,i),u=e.push(u,l),e.emit(u,{...t,...n})})),...t({opcode:149,mnemonic:"SWAP6"},(t=>n=>s=>{const[o,i,r,a,c,l,u]=e.topN(s,7);let d=e.popN(s,7);return d=e.push(d,o),d=e.push(d,l),d=e.push(d,c),d=e.push(d,a),d=e.push(d,r),d=e.push(d,i),d=e.push(d,u),e.emit(d,{...t,...n})})),...t({opcode:150,mnemonic:"SWAP7"},(t=>n=>s=>{const[o,i,r,a,c,l,u,d]=e.topN(s,8);let p=e.popN(s,8);return p=e.push(p,o),p=e.push(p,u),p=e.push(p,l),p=e.push(p,c),p=e.push(p,a),p=e.push(p,r),p=e.push(p,i),p=e.push(p,d),e.emit(p,{...t,...n})})),...t({opcode:151,mnemonic:"SWAP8"},(t=>n=>s=>{const[o,i,r,a,c,l,u,d,p]=e.topN(s,9);let m=e.popN(s,9);return m=e.push(m,o),m=e.push(m,d),m=e.push(m,u),m=e.push(m,l),m=e.push(m,c),m=e.push(m,a),m=e.push(m,r),m=e.push(m,i),m=e.push(m,p),e.emit(m,{...t,...n})})),...t({opcode:152,mnemonic:"SWAP9"},(t=>n=>s=>{const[o,i,r,a,c,l,u,d,p,m]=e.topN(s,10);let f=e.popN(s,10);return f=e.push(f,o),f=e.push(f,p),f=e.push(f,d),f=e.push(f,u),f=e.push(f,l),f=e.push(f,c),f=e.push(f,a),f=e.push(f,r),f=e.push(f,i),f=e.push(f,m),e.emit(f,{...t,...n})})),...t({opcode:153,mnemonic:"SWAP10"},(t=>n=>s=>{const[o,i,r,a,c,l,u,d,p,m,f]=e.topN(s,11);let y=e.popN(s,11);return y=e.push(y,o),y=e.push(y,m),y=e.push(y,p),y=e.push(y,d),y=e.push(y,u),y=e.push(y,l),y=e.push(y,c),y=e.push(y,a),y=e.push(y,r),y=e.push(y,i),y=e.push(y,f),e.emit(y,{...t,...n})})),...t({opcode:154,mnemonic:"SWAP11"},(t=>n=>s=>{const[o,i,r,a,c,l,u,d,p,m,f,y]=e.topN(s,12);let g=e.popN(s,12);return g=e.push(g,o),g=e.push(g,f),g=e.push(g,m),g=e.push(g,p),g=e.push(g,d),g=e.push(g,u),g=e.push(g,l),g=e.push(g,c),g=e.push(g,a),g=e.push(g,r),g=e.push(g,i),g=e.push(g,y),e.emit(g,{...t,...n})})),...t({opcode:155,mnemonic:"SWAP12"},(t=>n=>s=>{const[o,i,r,a,c,l,u,d,p,m,f,y,g]=e.topN(s,13);let b=e.popN(s,13);return b=e.push(b,o),b=e.push(b,y),b=e.push(b,f),b=e.push(b,m),b=e.push(b,p),b=e.push(b,d),b=e.push(b,u),b=e.push(b,l),b=e.push(b,c),b=e.push(b,a),b=e.push(b,r),b=e.push(b,i),b=e.push(b,g),e.emit(b,{...t,...n})})),...t({opcode:156,mnemonic:"SWAP13"},(t=>n=>s=>{const[o,i,r,a,c,l,u,d,p,m,f,y,g,b]=e.topN(s,14);let h=e.popN(s,14);return h=e.push(h,o),h=e.push(h,g),h=e.push(h,y),h=e.push(h,f),h=e.push(h,m),h=e.push(h,p),h=e.push(h,d),h=e.push(h,u),h=e.push(h,l),h=e.push(h,c),h=e.push(h,a),h=e.push(h,r),h=e.push(h,i),h=e.push(h,b),e.emit(h,{...t,...n})})),...t({opcode:157,mnemonic:"SWAP14"},(t=>n=>s=>{const[o,i,r,a,c,l,u,d,p,m,f,y,g,b,h]=e.topN(s,15);let k=e.popN(s,15);return k=e.push(k,o),k=e.push(k,b),k=e.push(k,g),k=e.push(k,y),k=e.push(k,f),k=e.push(k,m),k=e.push(k,p),k=e.push(k,d),k=e.push(k,u),k=e.push(k,l),k=e.push(k,c),k=e.push(k,a),k=e.push(k,r),k=e.push(k,i),k=e.push(k,h),e.emit(k,{...t,...n})})),...t({opcode:158,mnemonic:"SWAP15"},(t=>n=>s=>{const[o,i,r,a,c,l,u,d,p,m,f,y,g,b,h,k]=e.topN(s,16);let v=e.popN(s,16);return v=e.push(v,o),v=e.push(v,h),v=e.push(v,b),v=e.push(v,g),v=e.push(v,y),v=e.push(v,f),v=e.push(v,m),v=e.push(v,p),v=e.push(v,d),v=e.push(v,u),v=e.push(v,l),v=e.push(v,c),v=e.push(v,a),v=e.push(v,r),v=e.push(v,i),v=e.push(v,k),e.emit(v,{...t,...n})})),...t({opcode:159,mnemonic:"SWAP16"},(t=>n=>s=>{const[o,i,r,a,c,l,u,d,p,m,f,y,g,b,h,k,v]=e.topN(s,17);let x=e.popN(s,17);return x=e.push(x,o),x=e.push(x,k),x=e.push(x,h),x=e.push(x,b),x=e.push(x,g),x=e.push(x,y),x=e.push(x,f),x=e.push(x,m),x=e.push(x,p),x=e.push(x,d),x=e.push(x,u),x=e.push(x,l),x=e.push(x,c),x=e.push(x,a),x=e.push(x,r),x=e.push(x,i),x=e.push(x,v),e.emit(x,{...t,...n})})),...t({opcode:160,mnemonic:"LOG0"},n({consumes:["offset","size"],produces:[]})),...t({opcode:161,mnemonic:"LOG1"},n({consumes:["offset","size","topic"],produces:[]})),...t({opcode:162,mnemonic:"LOG2"},n({consumes:["offset","size","topic1","topic2"],produces:[]})),...t({opcode:163,mnemonic:"LOG3"},n({consumes:["offset","size","topic1","topic2","topic3"],produces:[]})),...t({opcode:164,mnemonic:"LOG4"},n({consumes:["offset","size","topic1","topic2","topic3","topic4"],produces:[]})),...t({opcode:240,mnemonic:"CREATE"},n({consumes:["value","offset","size"],produces:["address"]})),...t({opcode:241,mnemonic:"CALL"},n({consumes:["gas","address","value","argsOffset","argsSize","retOffset","retSize"],produces:["success"]})),...t({opcode:242,mnemonic:"CALLCODE"},n({consumes:["gas","address","value","argsOffset","argsSize","retOffset","retSize"],produces:["success"]})),...t({opcode:243,mnemonic:"RETURN"},n({consumes:["offset","size"],produces:[]})),...t({opcode:244,mnemonic:"DELEGATECALL"},n({consumes:["gas","address","argsOffset","argsSize","retOffset","retSize"],produces:["success"]})),...t({opcode:245,mnemonic:"CREATE2"},n({consumes:["value","offset","size","salt"],produces:["address"]})),...t({opcode:250,mnemonic:"STATICCALL"},n({consumes:["gas","address","argsOffset","argsSize","retOffset","retSize"],produces:["success"]})),...t({opcode:253,mnemonic:"REVERT"},n({consumes:["offset","size"],produces:[]})),...t({opcode:254,mnemonic:"INVALID"},n({consumes:[],produces:[]})),...t({opcode:255,mnemonic:"SELFDESTRUCT"},n({consumes:["address"],produces:[]}))}})(vn),In={...Sn,DUPn:(e,t)=>{if(e<1||e>16)throw new Error(`Cannot reach stack position ${e}`);const n=Sn[`DUP${e}`];return En().peek(((t,n)=>{if(t.stack.length<e)throw new Error("Stack too short");return n})).then(n(t),{as:"value"}).done()},PUSHn:(e,t)=>{if(0n===e)return Sn.PUSH0(t);const n=function(e){if(0n===e)return[];const t=e.toString(16),n=t.length%2?"0"+t:t,s=[];for(let o=0;o<n.length;o+=2)s.push(parseInt(n.substr(o,2),16));return s}(e);return(0,Sn[`PUSH${n.length}`])(n,t)}};function Nn(e){if("const"===e.kind)return`$const_${e.value}`;if("temp"===e.kind)return e.id;throw new Error(`Unknown value kind: ${e.kind}`)}const An=e=>t=>{if(0===t.stack.length)throw new Error("Cannot annotate empty stack");const n=[...t.stack];return n[0]={...n[0],irValue:e},{...t,stack:n}},Dn=(e,t)=>{const{PUSHn:n,DUPn:s,MLOAD:o}=In,i=Nn(e);return"const"===e.kind?En().then(n(BigInt(e.value),t)).then(An(i)).done():En().peek(((e,r)=>{const a=e.stack.findIndex((({irValue:e})=>e===i))+1;if(a>0&&a<=16)return r.then(s(a,t),{as:"value"});if(i in e.memory.allocations){const s=e.memory.allocations[i].offset;return r.then(n(BigInt(s),t),{as:"offset"}).then(o(t)).then(An(i))}throw new Error(`Cannot load value ${i} - not in stack or memory`)})).done()},$n=(e,t)=>{const{PUSHn:n,DUP2:s,SWAP1:o,MSTORE:i}=In;return En().then(An(e)).peek(((r,a)=>{const c=r.memory.allocations[e];return void 0===c?a:a.then(n(BigInt(c.offset),t),{as:"offset"}).then(s(t)).then(o(t)).then(i(t))})).done()},{ADD:Mn,SUB:jn,MUL:Cn,DIV:On,MOD:_n,EQ:Bn,LT:Un,GT:Ln,AND:Rn,OR:Pn,ISZERO:Vn,SHL:zn,SHR:Fn}=In;const{NOT:Hn,PUSHn:qn,SUB:Wn}=In;var Kn;!function(e){e.STACK_TOO_DEEP="MEMORY_STACK_TOO_DEEP",e.ALLOCATION_FAILED="MEMORY_ALLOCATION_FAILED",e.INVALID_LAYOUT="MEMORY_INVALID_LAYOUT"}(Kn||(Kn={}));class Yn extends R{constructor(e,t,n){super(t,e,n,B.Error)}}const Gn=64,Jn=128;var Zn,Xn,Qn,es,ts,ns;function ss(e,t){const n=[...e];switch(t.kind){case"binary":case"hash":n.pop(),n.pop();break;case"compute_slot":n.pop(),"compute_slot"===t.kind&&w.ComputeSlot.isMapping(t)&&n.pop();break;case"unary":case"cast":case"length":n.pop();break;case"read":t.slot&&n.pop(),t.offset&&n.pop(),t.length&&n.pop();break;case"write":t.slot&&n.pop(),t.offset&&n.pop(),t.length&&n.pop(),n.pop();break;case"compute_offset":n.pop(),(w.ComputeOffset.isArray(t)||w.ComputeOffset.isByte(t))&&n.pop()}return"dest"in t&&t.dest&&n.push(t.dest),n}function os(e){if("const"===e.kind)return`$const_${e.value}`;if("temp"===e.kind)return e.id;throw new Error(`Unknown value kind: ${e.kind}`)}function is(e){const t=new Set,n=e=>{e&&"const"!==e.kind&&t.add(os(e))};switch(e.kind){case"binary":n(e.left),n(e.right);break;case"unary":n(e.operand);break;case"compute_slot":n(e.base),w.ComputeSlot.isMapping(e)&&n(e.key);break;case"cast":case"hash":n(e.value);break;case"length":n(e.object)}return t}function rs(e,t){const n=e.lastIndexOf(t);return-1===n?-1:e.length-1-n}function as(e){return"scalar"===e.kind?e.size:32}function cs(e,t){for(const n of t.parameters||[])if(n.tempId===e)return n.type;for(const[n,s]of t.blocks){for(const t of s.phis)if(t.dest===e)return t.type;for(const t of s.instructions)if("dest"in t&&t.dest===e){if("type"in t&&t.type)return t.type;if("binary"===t.kind||"unary"===t.kind)return v.Scalar.uint256;if("env"===t.kind)return"msg_sender"===t.op?v.Scalar.address:v.Scalar.uint256}}}function ls(e){if("const"===e.kind)return`$const_${e.value}`;if("temp"===e.kind)return e.id;throw new Error(`Unknown value kind: ${e.kind}`)}function us(e){const t=new Set,n=e=>{e&&"const"!==e.kind&&t.add(ls(e))};switch(e.kind){case"binary":n(e.left),n(e.right);break;case"unary":n(e.operand);break;case"compute_slot":n(e.base),w.ComputeSlot.isMapping(e)&&n(e.key);break;case"hash":case"cast":n(e.value);break;case"length":n(e.object);break;case"allocate":n(e.size);break;case"read":n(e.slot),n(e.offset),n(e.length);break;case"write":n(e.slot),n(e.offset),n(e.length),n(e.value);break;case"compute_offset":n(e.base),w.ComputeOffset.isArray(e)?n(e.index):w.ComputeOffset.isByte(e)&&n(e.offset)}return t}function ds(e){switch(e.kind){case"const":case"binary":case"unary":case"read":case"compute_slot":case"compute_offset":case"env":case"hash":case"cast":case"length":case"allocate":return e.dest;case"write":return}}function ps(e,t,n=new Set){if(n.has(t))return[];n.add(t);const s=e.blocks.get(t);if(!s)return[];const o=s.terminator;if("jump"===o.kind)return[t,...ps(e,o.target,n)];if("branch"===o.kind){return[t,...ps(e,o.trueTarget,n),...ps(e,o.falseTarget,n)]}return[t]}!function(e){e.plan=function(e,t){const n={main:{},functions:{}};if(e.create&&t.create){const s=Xn.plan(e.create,t.create);if(!s.success)return s;n.create=s.value}if(!t.main)return L.err(new Yn(Kn.INVALID_LAYOUT,"Missing liveness info for main function"));const s=Xn.plan(e.main,t.main);if(!s.success)return s;n.main=s.value;for(const[o,i]of e.functions){const e=t.functions[o];if(!e)return L.err(new Yn(Kn.INVALID_LAYOUT,`Missing liveness info for function ${o}`));const s=Xn.plan(i,e);if(!s.success)return s;n.functions[o]=s.value}return L.ok(n)}}(Zn||(Zn={})),function(e){e.plan=function(e,t){try{const n={};let s=Jn;const o=function(e,t){const n=new Map;for(const s of t.crossBlockValues){const t=cs(s,e);t&&n.set(s,t)}for(const[s,o]of e.blocks)for(const e of o.phis)n.set(e.dest,e.type);for(const s of e.blocks.keys()){const o=e.blocks.get(s),i=t.liveIn.get(s)||new Set;let r=Array.from(i);for(const t of o.instructions){for(const s of is(t)){const t=rs(r,s);if(t>16||-1===t){const t=cs(s,e);t&&n.set(s,t)}}if("compute_slot"===t.kind&&"array"===t.slotKind){const s=os(t.base);if(i.has(s)){const t=cs(s,e);t&&n.set(s,t)}}if(r=ss(r,t),r.length>14)for(let t=0;t<r.length-14;t++){const s=cs(r[t],e);s&&n.set(r[t],s)}}const a=o.terminator;if("branch"===a.kind&&"const"!==a.condition.kind){const t=os(a.condition),s=rs(r,t);if(s>16||-1===s){const s=cs(t,e);s&&n.set(t,s)}}}return n}(e,t);for(const t of e.parameters||[])o.set(t.tempId,t.type);if(o.size>1e3)return L.err(new Yn(Kn.ALLOCATION_FAILED,`Too many values need memory allocation: ${o.size}`));const i=Array.from(o.entries()).sort((([e,t],[n,s])=>as(s)-as(t)));let r=s,a=0;const c=32;for(const[e,t]of i){const s=as(t);(s>=c||a+s>c)&&a>0&&(r+=c,a=0),n[e]={offset:r+a,size:s},a+=s,a>=c&&(r+=c,a=0)}return s=a>0?r+c:r,L.ok({allocations:n,nextStaticOffset:s})}catch(n){return L.err(new Yn(Kn.ALLOCATION_FAILED,n instanceof Error?n.message:"Unknown error"))}}}(Xn||(Xn={})),function(e){e.analyze=function(e){const t=new Map,n=new Map,s=new Map,o=new Set;for(const c of e.blocks.keys())t.set(c,new Set),n.set(c,new Set);const i=new Map,r=new Map;for(const[c,l]of e.blocks){const e=new Set,t=new Set;for(const s of l.phis)t.add(s.dest);for(const o of l.instructions){for(const i of us(o))t.has(i)||e.add(i),s.set(i,`${c}:${o.kind}`);const n=ds(o);n&&t.add(n)}const n=l.terminator;if("branch"===n.kind){const o=ls(n.condition);t.has(o)||e.add(o),s.set(o,`${c}:branch`)}else if("return"===n.kind&&n.value){const o=ls(n.value);t.has(o)||e.add(o),s.set(o,`${c}:return`)}i.set(c,e),r.set(c,t)}let a=!0;for(;a;){a=!1;for(const[s,c]of e.blocks){const l=t.get(s).size,u=n.get(s).size,d=new Set,p=c.terminator;if("jump"===p.kind){const n=t.get(p.target);if(n)for(const e of n)d.add(e);const i=e.blocks.get(p.target);if(i)for(const e of i.phis){const t=e.sources.get(s);t&&"const"!==t.kind&&(d.add(ls(t)),o.add(ls(t)))}}else if("branch"===p.kind){const n=t.get(p.trueTarget),i=t.get(p.falseTarget);if(n)for(const e of n)d.add(e);if(i)for(const e of i)d.add(e);for(const t of[p.trueTarget,p.falseTarget]){const n=e.blocks.get(t);if(n)for(const e of n.phis){const t=e.sources.get(s);t&&"const"!==t.kind&&(d.add(ls(t)),o.add(ls(t)))}}}n.set(s,d);const m=new Set(d),f=r.get(s),y=i.get(s);for(const e of f)m.delete(e);for(const e of y)m.add(e);t.set(s,m),m.size===l&&d.size===u||(a=!0)}}for(const c of n.values())for(const e of c)o.add(e);return{liveIn:t,liveOut:n,lastUse:s,crossBlockValues:o}}}(Qn||(Qn={})),function(e){e.analyze=function(e){const t={functions:{}};e.create&&(t.create=Qn.analyze(e.create)),t.main=Qn.analyze(e.main);for(const[n,s]of e.functions)t.functions[n]=Qn.analyze(s);return t}}(es||(es={})),function(e){e.perform=function(e){const t={main:{},functions:{}};if(e.create){const n=ns.perform(e.create);if(!n.success)return n;t.create=n.value}const n=ns.perform(e.main);if(!n.success)return n;t.main=n.value;for(const[s,o]of e.functions){const e=ns.perform(o);if(!e.success)return e;t.functions[s]=e.value}return L.ok(t)}}(ts||(ts={})),function(e){e.perform=function(e){try{const t=new Set,n=ps(e,e.entry,t),s=Array.from(e.blocks.keys()).filter((e=>!t.has(e)));return L.ok({order:[...n,...s],offsets:new Map})}catch(t){return L.err(new Yn(Kn.INVALID_LAYOUT,t instanceof Error?t.message:"Unknown error"))}}}(ns||(ns={}));function ms(e){const{PUSHn:t,SWAP1:n,DUP2:s,MLOAD:o,ADD:i,MSTORE:r}=In;return En().then(t(BigInt(Gn),e),{as:"offset"}).then(o(e),{as:"offset"}).then(n(e),{as:"b"}).then(s(e),{as:"a"}).then(i(e),{as:"value"}).then(t(BigInt(Gn),e),{as:"offset"}).then(r(e)).done()}const{PUSHn:fs,DUP2:ys,MSTORE:gs,ADD:bs}=In;function hs(e){const t=e.operationDebug;if("scalar"===e.type.kind){let n;return n="string"==typeof e.value&&e.value.startsWith("0x")?BigInt(e.value):"bigint"==typeof e.value?e.value:BigInt(e.value),En().then(fs(n,{debug:t})).then($n(e.dest,{debug:t})).done()}if("ref"===e.type.kind&&"memory"===e.type.location){let n,s;if("string"==typeof e.value&&e.value.startsWith("0x")){const t=e.value.slice(2),o=[];for(let e=0;e<t.length;e+=2)o.push(parseInt(t.substr(e,2),16));n=new Uint8Array(o),s=BigInt(n.length)}else{const t=String(e.value),o=new TextEncoder;n=o.encode(t),s=BigInt(n.length)}const o=(s+31n)/32n,i=32n+32n*o;return En().then(function(e,t){const{PUSHn:n}=In;return En().then(n(e,t),{as:"size"}).then(ms(t)).done()}(i,{debug:t}),{as:"offset"}).then(fs(BigInt(s),{debug:t}),{as:"value"}).then(ys({debug:t}),{as:"offset"}).then(gs({debug:t})).peek(((i,r)=>{let a=r;for(let e=0n;e<o;e++){const o=32n*e,i=s<o+32n?s:o+32n;let r=0n;for(let e=o;e<i;e++)r=r<<8n|BigInt(n[Number(e)]);r<<=8n*(32n-(i-o));const c=32n+32n*e;a=a.then(fs(r,{debug:t}),{as:"value"}).then(ys({debug:t}),{as:"b"}).then(fs(c,{debug:t}),{as:"a"}).then(bs({debug:t}),{as:"offset"}).then(gs({debug:t}))}return a.then(Tn("value")).then($n(e.dest,{debug:t}))})).done()}return En().then(fs(BigInt(e.value),{debug:t})).then($n(e.dest,{debug:t})).done()}const{CALLER:ks,CALLVALUE:vs,PUSH0:xs,TIMESTAMP:ws,NUMBER:Ts}=In;const{PUSHn:Es,MSTORE:Ss,KECCAK256:Is}=In;var Ns;!function(e){e.STACK_OVERFLOW="EVM001",e.STACK_UNDERFLOW="EVM002",e.INVALID_STACK_ACCESS="EVM003",e.MEMORY_ALLOCATION_FAILED="EVM004",e.JUMP_TARGET_NOT_FOUND="EVM005",e.PHI_NODE_UNRESOLVED="EVM006",e.UNSUPPORTED_INSTRUCTION="EVM007",e.INTERNAL_ERROR="EVM999"}(Ns||(Ns={}));const As={[Ns.STACK_OVERFLOW]:"Stack depth exceeds EVM limit of 1024",[Ns.STACK_UNDERFLOW]:"Stack underflow: attempted to access non-existent stack item",[Ns.INVALID_STACK_ACCESS]:"Invalid stack access: position out of range",[Ns.MEMORY_ALLOCATION_FAILED]:"Failed to allocate memory for value",[Ns.JUMP_TARGET_NOT_FOUND]:"Jump target block not found",[Ns.PHI_NODE_UNRESOLVED]:"Phi node value not resolved for predecessor",[Ns.UNSUPPORTED_INSTRUCTION]:"Unsupported IR instruction",[Ns.INTERNAL_ERROR]:"Internal code generation error"};class Ds extends R{constructor(e,t,n,s=B.Error){const o=As[e];super(t?`${o}: ${t}`:o,e,n,s)}}const{PUSHn:$s,CALLDATASIZE:Ms,SLOAD:js,MLOAD:Cs,SUB:Os,SHR:_s}=In;const{SWAP1:Bs,PUSHn:Us,SLOAD:Ls,SSTORE:Rs,MLOAD:Ps,MSTORE:Vs,SHL:zs,SHR:Fs,AND:Hs,OR:qs,NOT:Ws,SUB:Ks,DUP1:Ys}=In;const{PUSHn:Gs,MSTORE:Js,KECCAK256:Zs,ADD:Xs}=In;const{MUL:Qs,ADD:eo}=In;function to(e){const t=e.operationDebug;if(w.ComputeOffset.isArray(e))return En().then(Dn(e.base,{debug:t}),{as:"base"}).then(Dn(e.index,{debug:t}),{as:"index"}).then(Dn(x.constant(BigInt(e.stride),v.Scalar.uint256),{debug:t}),{as:"stride"}).then(wn({1:"a",2:"b"})).then(Qs({debug:t}),{as:"scaled_index"}).then(wn({1:"a",2:"b"})).then(eo({debug:t}),{as:"value"}).then($n(e.dest,{debug:t})).done();if(w.ComputeOffset.isField(e))return 0===e.fieldOffset?En().then(Dn(e.base,{debug:t}),{as:"value"}).then($n(e.dest,{debug:t})).done():En().then(Dn(e.base,{debug:t}),{as:"base"}).then(Dn(x.constant(BigInt(e.fieldOffset),v.Scalar.uint256),{debug:t}),{as:"field_offset"}).then(wn({1:"a",2:"b"})).then(eo({debug:t}),{as:"value"}).then($n(e.dest,{debug:t})).done();if(w.ComputeOffset.isByte(e))return En().then(Dn(e.base,{debug:t}),{as:"base"}).then(Dn(e.offset,{debug:t}),{as:"byte_offset"}).then(wn({1:"a",2:"b"})).then(eo({debug:t}),{as:"value"}).then($n(e.dest,{debug:t})).done();throw function(e){throw new Ds(Ns.INTERNAL_ERROR,"Unexpected code path; expected exhaustive conditionals",void 0,B.Error)}(),new Error("Unknown compute_offset type")}function no(e){switch(e.kind){case"const":return hs(e);case"binary":return function(e){const t=e.operationDebug,n={add:Mn({debug:t}),sub:jn({debug:t}),mul:Cn({debug:t}),div:On({debug:t}),mod:_n({debug:t}),shl:En().then(wn({1:"shift",2:"value"})).then(zn({debug:t})).done(),shr:En().then(wn({1:"shift",2:"value"})).then(Fn({debug:t})).done(),eq:Bn({debug:t}),ne:En().then(Bn({debug:t}),{as:"a"}).then(Vn({debug:t})).done(),lt:Ln({debug:t}),le:En().then(Un({debug:t}),{as:"a"}).then(Vn({debug:t})).done(),gt:Un({debug:t}),ge:En().then(Ln({debug:t}),{as:"a"}).then(Vn({debug:t})).done(),and:Rn({debug:t}),or:Pn({debug:t})};return En().then(Dn(e.left,{debug:t}),{as:"b"}).then(Dn(e.right,{debug:t}),{as:"a"}).then(n[e.op],{as:"value"}).then($n(e.dest,{debug:t})).done()}(e);case"unary":return function(e){const t=e.operationDebug,n={not:Hn({debug:t}),neg:En().then(Tn("b")).then(qn(0n,{debug:t}),{as:"a"}).then(Wn({debug:t})).done()};return En().then(Dn(e.operand,{debug:t}),{as:"a"}).then(n[e.op],{as:"value"}).then($n(e.dest,{debug:t})).done()}(e);case"read":return function(e){const t=e.operationDebug;if("storage"===e.location&&e.slot){const n="const"===e.offset?.kind?e.offset.value:0n,s="const"===e.length?.kind?e.length.value:32n;return 0n===n&&32n===s?En().then(Dn(e.slot,{debug:t}),{as:"key"}).then(Ls({debug:t}),{as:"value"}).then($n(e.dest,{debug:t})).done():En().then(Dn(e.slot,{debug:t}),{as:"key"}).then(Ls({debug:t}),{as:"value"}).then(Us(8n*(32n-BigInt(n)-BigInt(s)),{debug:t}),{as:"shift"}).then(Fs({debug:t}),{as:"shiftedValue"}).then(Us(1n,{debug:t}),{as:"b"}).then(Us(1n,{debug:t}),{as:"value"}).then(Us(8n*BigInt(s),{debug:t}),{as:"shift"}).then(zs({debug:t}),{as:"a"}).then(Ks({debug:t}),{as:"mask"}).then(wn({1:"a",2:"b"})).then(Hs({debug:t}),{as:"value"}).then($n(e.dest,{debug:t})).done()}return"memory"===e.location&&e.offset?En().then(Dn(e.offset,{debug:t}),{as:"offset"}).then(Ps({debug:t}),{as:"value"}).then($n(e.dest,{debug:t})).done():En().then(Us(0n,{debug:t}),{as:"value"}).done()}(e);case"write":return function(e){const t=e.operationDebug;if("storage"===e.location&&e.slot&&e.value){const n="const"===e.offset?.kind?e.offset.value:0n,s="const"===e.length?.kind?e.length.value:32n;return 0n===n&&32n===s?En().then(Dn(e.value,{debug:t}),{as:"value"}).then(Dn(e.slot,{debug:t}),{as:"key"}).then(Rs({debug:t})).done():En().then(Dn(e.slot,{debug:t}),{as:"key"}).then(Ys({debug:t})).then(Ls({debug:t}),{as:"current"}).then(Us(1n,{debug:t}),{as:"b"}).then(Us(1n,{debug:t}),{as:"value"}).then(Us(8n*BigInt(s),{debug:t}),{as:"shift"}).then(zs({debug:t}),{as:"a"}).then(Ks({debug:t}),{as:"lengthMask"}).then(Us(8n*BigInt(n),{debug:t}),{as:"bitOffset"}).then(wn({1:"shift",2:"value"})).then(zs({debug:t}),{as:"a"}).then(Ws({debug:t}),{as:"clearMask"}).then(wn({1:"a",2:"b"})).then(Hs({debug:t}),{as:"clearedCurrent"}).then(Dn(e.value,{debug:t}),{as:"value"}).then(Us(8n*BigInt(n),{debug:t}),{as:"shift"}).then(zs({debug:t}),{as:"shiftedValue"}).then(wn({1:"a",2:"b"})).then(qs({debug:t}),{as:"value"}).then(Bs({debug:t})).then(Rs({debug:t})).done()}return"memory"===e.location&&e.offset&&e.value?En().then(Dn(e.value,{debug:t}),{as:"value"}).then(Dn(e.offset,{debug:t}),{as:"offset"}).then(Vs({debug:t})).done():e=>e}(e);case"env":return function(e){const t=e.operationDebug,n={msg_sender:ks({debug:t}),msg_value:vs({debug:t}),msg_data:xs({debug:t}),block_timestamp:ws({debug:t}),block_number:Ts({debug:t})};return En().then(n[e.op],{as:"value"}).then($n(e.dest,{debug:t})).done()}(e);case"hash":return function(e){const t=e.operationDebug;return En().then(Dn(e.value,{debug:t})).then(Es(0n,{debug:t}),{as:"offset"}).then(Ss({debug:t})).then(Es(32n,{debug:t}),{as:"size"}).then(Es(0n,{debug:t}),{as:"offset"}).then(Is({debug:t}),{as:"value"}).then($n(e.dest,{debug:t})).done()}(e);case"length":return function(e){const t=e.operationDebug,n=Nn(e.object);if(n.includes("calldata")||n.includes("msg_data")||n.includes("msg.data"))return En().then(Ms({debug:t}),{as:"value"}).then($n(e.dest,{debug:t})).done();const s=e.object.type;if("ref"===s.kind)return En().peek(((o,i)=>n in o.memory.allocations||o.stack.findIndex((({irValue:e})=>e===n))>-1||"memory"===s.location?i.then(Dn(e.object,{debug:t}),{as:"offset"}).then(Cs({debug:t}),{as:"value"}).then($n(e.dest,{debug:t})):i.then(Dn(e.object,{debug:t}),{as:"key"}).then(js({debug:t}),{as:"b"}).then($s(1n,{debug:t}),{as:"a"}).then(Os({debug:t}),{as:"value"}).then($s(1n,{debug:t}),{as:"shift"}).then(_s({debug:t}),{as:"value"}).then($n(e.dest,{debug:t})))).done();if("scalar"===s.kind)return En().then($s(BigInt(s.size),{debug:t})).then($n(e.dest,{debug:t})).done();throw new Ds(Ns.UNSUPPORTED_INSTRUCTION,"length operation not supported for type")}(e);case"compute_slot":return function(e){const t=e.operationDebug;if(w.ComputeSlot.isMapping(e)){if(!e.key)throw new Error("Mapping compute_slot requires key");return En().then(Dn(e.key,{debug:t})).then(Gs(0n,{debug:t}),{as:"offset"}).then(Js({debug:t})).then(Dn(e.base,{debug:t})).then(Gs(32n,{debug:t}),{as:"offset"}).then(Js({debug:t})).then(Gs(64n,{debug:t}),{as:"size"}).then(Gs(0n,{debug:t}),{as:"offset"}).then(Zs({debug:t}),{as:"value"}).then($n(e.dest,{debug:t})).done()}if(w.ComputeSlot.isArray(e))return En().then(Dn(e.base,{debug:t})).then(Gs(0n,{debug:t}),{as:"offset"}).then(Js({debug:t})).then(Gs(32n,{debug:t}),{as:"size"}).then(Gs(0n,{debug:t}),{as:"offset"}).then(Zs({debug:t}),{as:"value"}).then($n(e.dest,{debug:t})).done();if(w.ComputeSlot.isField(e)){if(void 0===e.fieldOffset)throw new Error("Field compute_slot requires fieldOffset");const n=Math.floor(e.fieldOffset/32);return En().then(Dn(e.base,{debug:t}),{as:"b"}).then(Gs(BigInt(n),{debug:t}),{as:"a"}).then(Xs({debug:t}),{as:"value"}).then($n(e.dest,{debug:t})).done()}throw new Error("Unknown compute_slot kind")}(e);case"cast":return function(e){const t=e.operationDebug;return En().then(Dn(e.value,{debug:t}),{as:"value"}).then($n(e.dest,{debug:t})).done()}(e);case"allocate":return function(e){const t=e.operationDebug;return En().then(Dn(e.size,{debug:t}),{as:"size"}).then(ms({debug:t}),{as:"value"}).then($n(e.dest,{debug:t})).done()}(e);case"compute_offset":return to(e);default:return e}}function so(e){const t=[];for(const n of e)t.push(n.opcode),n.immediates&&t.push(...n.immediates);return t}function oo(e){return e.reduce(((e,t)=>e+function(e){let t=1;return e.immediates&&(t+=e.immediates.length),t}(t)),0)}function io(e,t,n=!1,s=!1,o=!1,i){const{JUMPDEST:r}=In;return En().peek(((a,c)=>{const l=oo(a.instructions);let u=c.then((t=>({...t,blockOffsets:{...t.blockOffsets,[e.id]:l}})));if(s&&(u=u.then(function(e){const{PUSHn:t,MSTORE:n}=In;return En().then(t(BigInt(e)),{as:"value"}).then(t(BigInt(Gn)),{as:"offset"}).then(n()).done()}(a.memory.nextStaticOffset))),!s){let n=!1,s="";if(i&&t){const o=i.blocks.get(t);"call"===o?.terminator.kind&&o.terminator.continuation===e.id&&(n=!0,s=o.terminator.function)}if(n){const e={context:{remark:`call-continuation: resume after call to ${s}`}};u=u.then(r({debug:e}))}else u=u.then(r());if(i&&t){const n=i.blocks.get(t);"call"===n?.terminator.kind&&n.terminator.continuation===e.id&&n.terminator.dest&&(u=u.then(An(n.terminator.dest)))}}t&&e.phis.length>0&&(u=u.then(function(e,t){return e.reduce(((e,n)=>e.then(function(e,t){const{PUSHn:n,MSTORE:s}=In,o=e.sources.get(t);if(!o)throw new Ds(Ns.PHI_NODE_UNRESOLVED,`Phi ${e.dest} missing source from ${t}`);return En().then(Dn(o)).peek(((t,o)=>{const i=t.memory.allocations[e.dest];if(void 0===i)throw new Ds(Ns.MEMORY_ALLOCATION_FAILED,`Phi destination ${e.dest} not allocated`);return o.then(n(BigInt(i.offset)),{as:"offset"}).then(s())})).done()}(n,t))),En()).done()}(e.phis,t)));for(const t of e.instructions)u=u.then(no(t));return u="call"===e.terminator.kind?u.then(function(e){const t=e.function,n=e.arguments,s=e.continuation;return e=>{let o=e;const i=o.instructions.length,r={context:{remark:`call-preparation: store return address for ${t}`}};o={...o,instructions:[...o.instructions,{mnemonic:"PUSH2",opcode:97,immediates:[0,0],debug:r},{mnemonic:"PUSH1",opcode:96,immediates:[96]},{mnemonic:"MSTORE",opcode:82}],patches:[...o.patches,{type:"continuation",index:i,target:s}]};const a={context:{remark:`call-arguments: push ${n.length} argument(s) for ${t}`}};for(const t of n)o=Dn(t,{debug:a})(o);const c=o.instructions.length,l={context:{remark:`call-invocation: jump to function ${t}`}};return o={...o,instructions:[...o.instructions,{mnemonic:"PUSH2",opcode:97,immediates:[0,0],debug:l},{mnemonic:"JUMP",opcode:86}],patches:[...o.patches,{type:"function",index:c,target:t}]},o}}(e.terminator)):u.then(function(e,t=!1,n=!1){const{PUSHn:s,PUSH2:o,MSTORE:i,MLOAD:r,RETURN:a,STOP:c,JUMP:l,JUMPI:u}=In;switch(e.kind){case"return":if(n){const t={context:{remark:e.value?"function-return: return with value":"function-return: void return"}};return e.value,En().then(s(0x60n,{debug:t}),{as:"offset"}).then(r({debug:t}),{as:"counter"}).then(l({debug:t})).done()}if(e.value){const t=e.value,n=Nn(t);return En().peek(((e,o)=>{const r=e.memory.allocations[n];if(void 0===r){const n=e.memory.nextStaticOffset;return o.then(Dn(t)).then(s(BigInt(n)),{as:"offset"}).then(i()).then(s(32n),{as:"size"}).then(s(BigInt(n)),{as:"offset"}).then(a())}{const e=r.offset;return o.then(s(32n),{as:"size"}).then(s(BigInt(e)),{as:"offset"}).then(a())}})).done()}return t?e=>e:En().then(c()).done();case"jump":return En().peek(((t,n)=>{const s=t.instructions.length;return n.then(o([0,0]),{as:"counter"}).then(l()).then((t=>({...t,patches:[...t.patches,{index:s,target:e.target}]})))})).done();case"branch":return En().then(Dn(e.condition),{as:"b"}).peek(((t,n)=>{const s=t.instructions.length;return n.then(o([0,0]),{as:"counter"}).then(u()).peek(((t,n)=>{const i=t.instructions.length;return n.then(o([0,0]),{as:"counter"}).then(l()).then((t=>({...t,patches:[...t.patches,{index:s,target:e.trueTarget},{index:i,target:e.falseTarget}]})))}))})).done();case"call":throw new Error("Call terminator should be handled by generateCallTerminator")}}(e.terminator,n,o)),u})).done()}function ro(e,t,n,s={}){const o={brands:[],stack:[],instructions:[],memory:t,nextId:0,patches:[],blockOffsets:{},warnings:[],functionRegistry:{},callStackPointer:96};let i=o;if(s.isUserFunction){const t=function(e){const t=e.parameters||[];return n=>{let s=n;const o={context:{remark:`function-entry: ${e.name||"anonymous"}`}};s={...s,instructions:[...s.instructions,{mnemonic:"JUMPDEST",opcode:91,debug:o}]};const i={context:{remark:`prologue: store ${t.length} parameter(s) to memory`}};for(let e=t.length-1;e>=0;e--){const n=t[e],o=s.memory.allocations[n.tempId];if(!o)continue;const r=o.offset>>8&255,a=255&o.offset;s={...s,instructions:[...s.instructions,{mnemonic:"PUSH2",opcode:97,immediates:[r,a],debug:i}]},s={...s,instructions:[...s.instructions,{mnemonic:"MSTORE",opcode:82}]}}return{...s,stack:[],brands:[]}}}(e);i=t(o)}const r=n.order.reduce(((t,o,i)=>{const r=e.blocks.get(o);if(!r)return t;const a=0===i;return io(r,i>0?n.order[i-1]:void 0,i===n.order.length-1,a,s.isUserFunction||!1,e)(t)}),i),a=function(e){const t=[...e.instructions];for(const n of e.patches){if("function"===n.type)continue;const s=e.blockOffsets[n.target];if(void 0===s)throw new Error(`Jump target ${n.target} not found`);const o=s>>8&255,i=255&s,r=t[n.index];r&&r.immediates&&(r.immediates=[o,i])}return{...e,instructions:t}}(r),c=so(a.instructions);return{instructions:a.instructions,bytecode:c,warnings:a.warnings,patches:r.patches}}function ao(e,t,n,s){const o=[...t],i=[...e];for(const r of n){if("function"!==r.type)continue;const e=s[r.target];if(void 0===e)throw new Error(`Function ${r.target} not found in registry`);const n=e>>8&255,a=255&e,c=o[r.index];c&&c.immediates&&(c.immediates=[n,a]);let l=0;for(let s=0;s<r.index;s++){const e=t[s];l+=1,e.immediates&&(l+=e.immediates.length)}l+=1,i[l]=n,i[l+1]=a}return{bytecode:i,instructions:o}}function co(e,t,n){const s=ro(e.main,t.main,n.main);let o=[...s.warnings];const i=[];for(const[g,b]of e.functions.entries()){const e=t.functions?.[g],s=n.functions?.[g];if(e&&s){const t=ro(b,e,s,{isUserFunction:!0});i.push({name:g,bytecode:t.bytecode,instructions:t.instructions,patches:t.patches}),o=[...o,...t.warnings]}}const r={};let a=s.bytecode.length;for(const g of i)r[g.name]=a,a+=g.bytecode.length;const c=ao(s.bytecode,s.instructions,s.patches,r),l=i.map((e=>ao(e.bytecode,e.instructions,e.patches,r))),u=[...c.bytecode,...l.flatMap((e=>e.bytecode))],d=[...c.instructions,...l.flatMap((e=>e.instructions))];let p=[],m=[];if(e.create&&t.create&&n.create){const s=ro(e.create,t.create,n.create);p=s.bytecode,m=[...s.instructions],o=[...o,...s.warnings]}const{deployBytes:f,deploymentWrapperInstructions:y}=function(e,t){const n={brands:[],stack:[],instructions:[],memory:{allocations:{},nextStaticOffset:128},nextId:0,patches:[],blockOffsets:{},warnings:[],functionRegistry:{},callStackPointer:96},s=function(e,t){const n={brands:[],stack:[],instructions:[],memory:{allocations:{},nextStaticOffset:128},nextId:0,patches:[],blockOffsets:{},warnings:[],functionRegistry:{},callStackPointer:96};let s=0,o=-1;for(;s!==o;){o=s;s=oo(lo(BigInt(e+s),BigInt(t))(n).instructions)}return e+s}(e.length,t.length),o=BigInt(s),i=BigInt(t.length),r=lo(o,i)(n),a=so(r.instructions),c=[...e,...a,...t];return{deployBytes:c,deploymentWrapperInstructions:r.instructions}}(p,u);return{create:f,runtime:u,createInstructions:m.length>0||y.length>0?[...m,...y]:void 0,runtimeInstructions:d,warnings:o}}function lo(e,t){const{PUSHn:n,CODECOPY:s,RETURN:o}=In;return En().then(n(t),{as:"size"}).then(n(e),{as:"offset"}).then(n(0n),{as:"destOffset"}).then(s()).then(n(t),{as:"size"}).then(n(0n),{as:"offset"}).then(o()).done()}function uo(e,t,n){const s=function(e){const t=[];let n=0;for(const s of e)t.push(n),n+=1+(s.immediates?.length??0);return t}(e),o=e.map(((e,t)=>function(e,t){const n={offset:t};if(e.mnemonic){const t={mnemonic:e.mnemonic};if(e.immediates&&e.immediates.length>0){const n="0x"+e.immediates.map((e=>e.toString(16).padStart(2,"0"))).join("");t.arguments=[n]}n.operation=t}return e.debug?.context&&(n.context=e.debug.context),n}(e,s[t]))),i={contract:{name:n.name,definition:{source:{id:"0"},range:n.loc??{offset:0,length:0}}},environment:t,instructions:o};return n.debugContext&&(i.context=n.debugContext),i}const po={async run({ir:e}){try{const t=es.analyze(e),n=Zn.plan(e,t);if(!n.success)return L.err(new Ds(Ns.INTERNAL_ERROR,n.messages.error?.[0]?.message??"Memory analysis failed"));const s=ts.perform(e);if(!s.success)return L.err(new Ds(Ns.INTERNAL_ERROR,s.messages.error?.[0]?.message??"Block layout analysis failed"));const o=co(e,n.value,s.value),i=new Uint8Array(o.runtime),r=o.create?new Uint8Array(o.create):void 0,a=uo(o.runtimeInstructions,"call",e),c=o.createInstructions?uo(o.createInstructions,"create",e):void 0;return L.okWith({bytecode:{runtime:i,create:r,runtimeInstructions:o.runtimeInstructions,createInstructions:o.createInstructions,runtimeProgram:a,createProgram:c}},o.warnings)}catch(t){return t instanceof Ds?L.err(t):L.err(new Ds(Ns.INTERNAL_ERROR,t instanceof Error?t.message:String(t)))}}},mo=[gn,bn,hn,kn],fo={ast:[gn],types:[gn,bn],ir:mo,bytecode:[...mo,po]};async function yo(e){const{to:t,...n}=e,s=(o=fo[t],{async run(e){let t=e,n={};for(const s of o){const e=await s.run(t);if(n=L.mergeMessages(n,e.messages),!e.success)return{success:!1,messages:n};t={...t,...e.value}}return{success:!0,value:t,messages:n}}});var o;return await s.run(n)}},39612(e,t,n){n.d(t,{yZ:()=>u,dV:()=>l,MT:()=>$,KE:()=>L,TE:()=>E,sH:()=>a});var s=n(14041);function o(){const[e,t]=(0,s.useState)(null),n=(0,s.useCallback)(((e,n)=>{const s=e.currentTarget.getBoundingClientRect();t({content:n,x:s.left,y:s.bottom,pinned:!1})}),[]),o=(0,s.useCallback)(((e,n)=>{const s=e.currentTarget.getBoundingClientRect();t({content:n,x:s.left,y:s.bottom,pinned:!0})}),[]),i=(0,s.useCallback)((()=>{t((e=>e?.pinned?e:null))}),[]),r=(0,s.useCallback)((()=>{t(null)}),[]);return{tooltip:e,setTooltip:t,showTooltip:n,pinTooltip:o,hideTooltip:i,closeTooltip:r}}var i=n(31085);function r({tooltip:e,onUpdate:t,onClose:n}){const o=(0,s.useRef)(null);return(0,s.useEffect)((()=>{if(e&&o.current){const n=o.current.getBoundingClientRect(),s=window.innerWidth,i=window.innerHeight;let{x:r,y:a}=e;r+n.width>s&&(r=s-n.width-10),r<10&&(r=10),a+n.height>i&&(a=i-n.height-10),a<10&&(a=10),r===e.x&&a===e.y||t?.({...e,x:r,y:a})}}),[e,t]),e?(0,i.jsxs)("div",{ref:o,className:"ethdebug-tooltip "+(e.pinned?"pinned":""),style:{left:`${e.x}px`,top:`${e.y}px`},children:[e.pinned&&(0,i.jsx)("button",{className:"tooltip-close-btn",onClick:n,title:"Close (Esc)",children:"\xd7"}),(0,i.jsx)("pre",{children:e.content})]}):null}function a(e){if(!e||"object"!=typeof e)return[];const t=e;if(t.code&&"object"==typeof t.code){const e=t.code;if(e.range&&"object"==typeof e.range){const t=e.range;if("number"==typeof t.offset&&"number"==typeof t.length)return[{offset:t.offset,length:t.length}]}}if(t.gather&&Array.isArray(t.gather)){const e=[];for(const n of t.gather)e.push(...a(n));return e}if(t.pick&&Array.isArray(t.pick)){const e=[];for(const n of t.pick)e.push(...a(n));return e}return t.frame&&"object"==typeof t.frame?a(t.frame):t.context?a(t.context):[]}function c({instructions:e,onOpcodeHover:t}){const{tooltip:n,setTooltip:s,showTooltip:c,pinTooltip:l,hideTooltip:u,closeTooltip:d}=o();let p=0;const m=()=>{t?.([])};return(0,i.jsxs)("div",{className:"bytecode-disassembly-interactive",children:[e.map(((e,n)=>{const s=p;p+=1+(e.immediates?.length||0);const o=a(e.debug?.context),r=!!e.debug?.context;return(0,i.jsxs)("div",{className:"opcode-line "+(r?"has-debug-info":""),onMouseEnter:()=>(e=>{t?.(e)})(o),onMouseLeave:m,children:[r?(0,i.jsx)("span",{className:"debug-info-icon",onMouseEnter:t=>((e,t)=>{t.debug?.context&&c(e,JSON.stringify(t.debug.context,null,2))})(t,e),onMouseLeave:u,onClick:t=>((e,t)=>{t.debug?.context&&l(e,JSON.stringify(t.debug.context,null,2))})(t,e),children:"\u2139"}):(0,i.jsx)("span",{className:"debug-info-spacer"}),(0,i.jsx)("span",{className:"pc",children:s.toString().padStart(4,"0")}),(0,i.jsx)("span",{className:"opcode",children:e.mnemonic}),e.immediates&&e.immediates.length>0&&(0,i.jsxs)("span",{className:"immediates",children:["0x",e.immediates.map((e=>e.toString(16).padStart(2,"0"))).join("")]})]},n)})),(0,i.jsx)(r,{tooltip:n,onUpdate:s,onClose:d})]})}function l({bytecode:e,onOpcodeHover:t}){const n=Array.from(e.runtime).map((e=>e.toString(16).padStart(2,"0"))).join(""),s=e.create?Array.from(e.create).map((e=>e.toString(16).padStart(2,"0"))).join(""):null;return(0,i.jsxs)("div",{className:"bytecode-view",children:[e.create&&(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)("div",{className:"bytecode-header",children:[(0,i.jsx)("h3",{children:"Constructor Bytecode"}),(0,i.jsx)("div",{className:"bytecode-stats",children:(0,i.jsxs)("span",{children:["Size: ",e.create.length/2," bytes"]})})]}),(0,i.jsxs)("div",{className:"bytecode-content",children:[(0,i.jsxs)("div",{className:"bytecode-section",children:[(0,i.jsx)("h4",{children:"Hex"}),(0,i.jsx)("pre",{className:"bytecode-hex",children:s})]}),(0,i.jsxs)("div",{className:"bytecode-section",children:[(0,i.jsx)("h4",{children:"Instructions"}),e.createInstructions&&(0,i.jsx)(c,{instructions:e.createInstructions,onOpcodeHover:t})]})]}),(0,i.jsx)("hr",{className:"bytecode-separator"})]}),(0,i.jsxs)("div",{className:"bytecode-header",children:[(0,i.jsx)("h3",{children:e.create?"Runtime Bytecode":"EVM Bytecode"}),(0,i.jsx)("div",{className:"bytecode-stats",children:(0,i.jsxs)("span",{children:["Size: ",e.runtime.length/2," bytes"]})})]}),(0,i.jsxs)("div",{className:"bytecode-content",children:[(0,i.jsxs)("div",{className:"bytecode-section",children:[(0,i.jsx)("h4",{children:"Hex"}),(0,i.jsx)("pre",{className:"bytecode-hex",children:n})]}),(0,i.jsxs)("div",{className:"bytecode-section",children:[(0,i.jsx)("h4",{children:"Instructions"}),(0,i.jsx)(c,{instructions:e.runtimeInstructions,onOpcodeHover:t})]})]})]})}function u({ast:e}){const t=JSON.stringify(e,((e,t)=>{if("parent"!==e)return t}),2);return(0,i.jsx)("div",{className:"ast-view",children:(0,i.jsx)("pre",{className:"ast-json",children:t})})}var d=n(9921);function p(e){const t={};e.operation?.context&&(t.operation=e.operation.context);const n=e.operands.filter((e=>e.debug?.context));return n.length>0&&(t.operands=Object.fromEntries(n.map((e=>[e.label,e.debug.context])))),JSON.stringify(t,null,2)}function m(e){const t=[];e.operation?.context&&t.push(...a(e.operation.context));for(const n of e.operands)n.debug?.context&&t.push(...a(n.debug.context));return t}function f(e,t){const n=e.operands.find((e=>e.label===t));return n?.debug?.context?a(n.debug.context):[]}function y({part:e,onHover:t,onLeave:n,onDebugIconHover:s,showDebugIcon:o}){return(0,i.jsxs)("span",{className:`hoverable-part ${e.className||""} ${e.ranges.length>0?"has-debug":""}`,onMouseEnter:()=>t(e.ranges),onMouseLeave:n,children:[e.text,o&&e.ranges.length>0&&s&&(0,i.jsx)("span",{className:"debug-info-icon inline",onMouseEnter:s,children:"\u2139"})]})}function g(e){if("bigint"==typeof e)return e.toString();if("string"==typeof e)return e.startsWith("0x")?e:JSON.stringify(e);if("boolean"==typeof e)return e.toString();switch(e.kind){case"const":return g(e.value);case"temp":return`%${e.id}`;default:return"?"}}function b(e){return e.kind}function h(e,t){const n=`${e.startsWith("t")?"%":"^"}${e}`;return t?`${n}: ${b(t)}`:n}function k({instruction:e,onHover:t,onLeave:n,showTooltip:s,pinTooltip:o,hideTooltip:r}){const a=function(e){const t=[];switch(e.kind){case"read":e.slot&&t.push({label:"slot",debug:e.slotDebug}),e.offset&&t.push({label:"offset",debug:e.offsetDebug}),e.length&&t.push({label:"length",debug:e.lengthDebug});break;case"write":e.slot&&t.push({label:"slot",debug:e.slotDebug}),e.offset&&t.push({label:"offset",debug:e.offsetDebug}),e.length&&t.push({label:"length",debug:e.lengthDebug}),t.push({label:"value",debug:e.valueDebug});break;case"compute_offset":t.push({label:"base",debug:e.baseDebug}),"index"in e&&e.index&&t.push({label:"index",debug:e.indexDebug}),"offset"in e&&e.offset&&t.push({label:"offset",debug:e.offsetDebug});break;case"compute_slot":t.push({label:"base",debug:e.baseDebug}),"key"in e&&e.key&&t.push({label:"key",debug:e.keyDebug});break;case"const":case"hash":case"cast":t.push({label:"value",debug:e.valueDebug});break;case"allocate":t.push({label:"size",debug:e.sizeDebug});break;case"binary":t.push({label:"left",debug:e.leftDebug}),t.push({label:"right",debug:e.rightDebug});break;case"unary":t.push({label:"operand",debug:e.operandDebug});break;case"length":t.push({label:"object",debug:e.objectDebug})}return{operation:e.operationDebug,operands:t}}(e),c=a.operation?.context?m({operation:a.operation,operands:[]}):[],l=[],u=(e,t,n)=>{const s=f(a,e);l.push({text:t,ranges:s,className:n})},k=e=>{l.push(e)};switch(e.kind){case"const":k(`${h(e.dest,e.type)} = const `),u("value",g(e.value));break;case"allocate":k(`${h(e.dest,d.Ir.ZU.Scalar.uint256)} = allocate.${e.location}, size=`),u("size",g(e.size));break;case"binary":k(`${h(e.dest)} = ${e.op} `),u("left",g(e.left)),k(", "),u("right",g(e.right));break;case"unary":k(`${h(e.dest)} = ${e.op} `),u("operand",g(e.operand));break;case"env":k(`${h(e.dest)} = env ${e.op}`);break;case"hash":k(`${h(e.dest)} = hash `),u("value",g(e.value));break;case"cast":k(`${h(e.dest,e.targetType)} = cast `),u("value",g(e.value)),k(` to ${b(e.targetType)}`);break;case"length":k(`${h(e.dest)} = length `),u("object",g(e.object));break;case"compute_slot":{const t=g(e.base);k(`${h(e.dest,d.Ir.ZU.Scalar.uint256)} = slot[`),u("base",t),"key"in e&&e.key?(k("].mapping["),u("key",g(e.key)),k("]")):"slotKind"in e&&"array"===e.slotKind?k("].array"):k("fieldOffset"in e?`].field[${e.fieldOffset}]`:"]");break}case"compute_offset":{const t=g(e.base);k(`${e.dest.startsWith("t")?`%${e.dest}`:e.dest} = offset[`),u("base",t),"index"in e&&e.index?32===e.stride?(k("].array["),u("index",g(e.index)),k("]")):(k("].array[index: "),u("index",g(e.index)),k(`, stride: ${e.stride}]`)):"offset"in e&&e.offset?(k("].byte["),u("offset",g(e.offset)),k("]")):k("fieldOffset"in e?`].field[${e.fieldOffset}]`:"]");break}case"read":{const t=e.location,n=!e.offset||"const"===e.offset.kind&&0n===e.offset.value,s=!e.length||"const"===e.length.kind&&32n===e.length.value;if(k(`${h(e.dest,e.type)} = `),"storage"===t||"transient"===t){const o=e.slot?g(e.slot):"0";n&&s?(k(`${t}[`),u("slot",o),k("*]")):(k(`${t}[slot: `),u("slot",o),!n&&e.offset&&(k(", offset: "),u("offset",g(e.offset))),!s&&e.length&&(k(", length: "),u("length",g(e.length))),k("]"))}else if(e.offset){const n=g(e.offset);if(s)k(`${t}[`),u("offset",n),k("*]");else{k(`${t}[offset: `),u("offset",n);const s=e.length?g(e.length):"32";k(", length: "),u("length",s),k("]")}}else k(`${t}[]`);break}case"write":{const t=e.location,n=g(e.value),s=!e.offset||"const"===e.offset.kind&&0n===e.offset.value,o=!e.length||"const"===e.length.kind&&32n===e.length.value;if("storage"===t||"transient"===t){const n=e.slot?g(e.slot):"0";s&&o?(k(`${t}[`),u("slot",n),k("*] = ")):(k(`${t}[slot: `),u("slot",n),!s&&e.offset&&(k(", offset: "),u("offset",g(e.offset))),!o&&e.length&&(k(", length: "),u("length",g(e.length))),k("] = "))}else if(e.offset){const n=g(e.offset);if(o)k(`${t}[`),u("offset",n),k("*] = ");else{k(`${t}[offset: `),u("offset",n);const s=e.length?g(e.length):"32";k(", length: "),u("length",s),k("] = ")}}else k(`${t}[] = `);u("value",n);break}default:k(`; unknown instruction: ${e.kind}`)}const v=c.length>0||a.operands.some((e=>e.debug?.context));return(0,i.jsxs)("div",{className:"ir-instruction",children:[v&&(0,i.jsx)("span",{className:"debug-info-icon",onMouseEnter:e=>{const t=p(a);s(e,t)},onMouseLeave:r,onClick:e=>{const t=p(a);o(e,t)},children:"\u2139"}),!v&&(0,i.jsx)("span",{className:"debug-info-spacer"}),(0,i.jsx)("span",{className:"instruction-operation",onMouseEnter:()=>t(c),onMouseLeave:n,children:l.map(((e,s)=>"string"==typeof e?(0,i.jsx)("span",{children:e},s):(0,i.jsx)(y,{part:e,onHover:t,onLeave:n},s)))})]})}function v({terminator:e,onHover:t,onLeave:n,showTooltip:s,pinTooltip:o,hideTooltip:r}){const a=function(e){const t=[];switch(e.kind){case"branch":t.push({label:"condition",debug:e.conditionDebug});break;case"return":e.value&&t.push({label:"value",debug:e.valueDebug});break;case"call":e.argumentsDebug&&e.arguments.forEach(((n,s)=>{t.push({label:`arg[${s}]`,debug:e.argumentsDebug?.[s]})}))}return{operation:e.operationDebug,operands:t}}(e),c=a.operation?.context?m({operation:a.operation,operands:[]}):[],l=[],u=(e,t,n)=>{const s=f(a,e);l.push({text:t,ranges:s,className:n})},d=e=>{l.push(e)};switch(e.kind){case"jump":d(`jump ${e.target}`);break;case"branch":d("branch "),u("condition",g(e.condition)),d(` ? ${e.trueTarget} : ${e.falseTarget}`);break;case"return":e.value?(d("return "),u("value",g(e.value))):d("return void");break;case"call":e.dest&&d(`${e.dest} = `),d(`call ${e.function}(`),e.arguments.forEach(((e,t)=>{t>0&&d(", "),u(`arg[${t}]`,g(e))})),d(`) -> ${e.continuation}`)}const b=c.length>0||a.operands.some((e=>e.debug?.context));return(0,i.jsxs)("div",{className:"ir-terminator",children:[b&&(0,i.jsx)("span",{className:"debug-info-icon",onMouseEnter:e=>{const t=p(a);s(e,t)},onMouseLeave:r,onClick:e=>{const t=p(a);o(e,t)},children:"\u2139"}),!b&&(0,i.jsx)("span",{className:"debug-info-spacer"}),(0,i.jsx)("span",{className:"terminator-operation",onMouseEnter:()=>t(c),onMouseLeave:n,children:l.map(((e,s)=>"string"==typeof e?(0,i.jsx)("span",{children:e},s):(0,i.jsx)(y,{part:e,onHover:t,onLeave:n},s)))})]})}function x({phi:e,onHover:t,onLeave:n,showTooltip:s,pinTooltip:o,hideTooltip:r}){const a=function(e){const t=[];if(e.sourcesDebug)for(const n of e.sources.keys()){const s=e.sourcesDebug.get(n);t.push({label:`from ${n}`,debug:s})}return{operation:e.operationDebug,operands:t}}(e),c=a.operation?.context?m({operation:a.operation,operands:[]}):[],l=c.length>0||a.operands.some((e=>e.debug?.context)),u=[],d=e=>u.push(e),h=e.dest.startsWith("t")?`%${e.dest}`:`^${e.dest}`,k=e.type?`: ${b(e.type)}`:"";d(`${h}${k} = phi `);return Array.from(e.sources.entries()).forEach((([e,t],n)=>{n>0&&d(", ");const s=f(a,`from ${e}`);u.push({text:`[${e}: ${g(t)}]`,ranges:s})})),(0,i.jsxs)("div",{className:"ir-phi",children:[l&&(0,i.jsx)("span",{className:"debug-info-icon",onMouseEnter:e=>{const t=p(a);s(e,t)},onMouseLeave:r,onClick:e=>{const t=p(a);o(e,t)},children:"\u2139"}),!l&&(0,i.jsx)("span",{className:"debug-info-spacer"}),(0,i.jsx)("span",{className:"phi-operation",onMouseEnter:()=>t(c),onMouseLeave:n,children:u.map(((e,s)=>"string"==typeof e?(0,i.jsx)("span",{children:e},s):(0,i.jsx)(y,{part:e,onHover:t,onLeave:n},s)))})]})}function w({blockId:e,block:t,isEntry:n,onHover:s,onLeave:o,showTooltip:r,pinTooltip:a,hideTooltip:c}){return(0,i.jsxs)("div",{className:"ir-block",children:[(0,i.jsxs)("div",{className:"block-header",children:[(0,i.jsxs)("strong",{children:[e,":"]}),n&&(0,i.jsx)("span",{className:"entry-badge",children:"entry"})]}),(0,i.jsxs)("div",{className:"block-body",children:[t.phis.map(((e,t)=>(0,i.jsx)(x,{phi:e,onHover:s,onLeave:o,showTooltip:r,pinTooltip:a,hideTooltip:c},t))),t.instructions.map(((e,t)=>(0,i.jsx)(k,{instruction:e,onHover:s,onLeave:o,showTooltip:r,pinTooltip:a,hideTooltip:c},t))),(0,i.jsx)(v,{terminator:t.terminator,onHover:s,onLeave:o,showTooltip:r,pinTooltip:a,hideTooltip:c})]})]})}function T({name:e,func:t,onHover:n,onLeave:o,showTooltip:r,pinTooltip:a,hideTooltip:c}){const l=(0,s.useMemo)((()=>{const e=[],n=new Set,s=new Set,o=i=>{if(s.has(i))return;if(n.has(i))return;s.add(i);const r=t.blocks.get(i);if(!r)return;const a=r.terminator;"jump"===a.kind?o(a.target):"branch"===a.kind?(o(a.trueTarget),o(a.falseTarget)):"call"===a.kind&&o(a.continuation),s.delete(i),n.add(i),e.unshift([i,r])};o(t.entry);for(const[i,r]of t.blocks)n.has(i)||e.push([i,r]);return e}),[t]);return(0,i.jsxs)("div",{className:"ir-function",children:[(0,i.jsx)("div",{className:"function-header",children:(0,i.jsxs)("h4",{children:[e,":"]})}),l.map((([e,s])=>(0,i.jsx)(w,{blockId:e,block:s,isEntry:e===t.entry,onHover:n,onLeave:o,showTooltip:r,pinTooltip:a,hideTooltip:c},e)))]})}function E({ir:e,onOpcodeHover:t}){const{tooltip:n,setTooltip:s,showTooltip:a,pinTooltip:c,hideTooltip:l,closeTooltip:u}=o(),d=e=>{t?.(e)},p=()=>{t?.([])},m=e.main.blocks.size,f=e.create?.blocks.size||0,y=e.functions?.size||0;let g=0;if(e.functions)for(const o of e.functions.values())g+=o.blocks.size;return(0,i.jsxs)("div",{className:"ir-view",children:[(0,i.jsxs)("div",{className:"ir-header",children:[(0,i.jsx)("h3",{children:"IR"}),(0,i.jsxs)("div",{className:"ir-stats",children:[y>0&&(0,i.jsxs)("span",{children:["Functions: ",y," (",g," blocks)"]}),e.create&&(0,i.jsxs)("span",{children:["Create: ",f," blocks"]}),(0,i.jsxs)("span",{children:["Main: ",m," blocks"]})]})]}),(0,i.jsxs)("div",{className:"ir-content",children:[e.functions&&e.functions.size>0&&(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)("div",{className:"section-label",children:"User Functions:"}),Array.from(e.functions.entries()).map((([e,t])=>(0,i.jsx)(T,{name:e,func:t,onHover:d,onLeave:p,showTooltip:a,pinTooltip:c,hideTooltip:l},e)))]}),e.create&&(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)("div",{className:"section-label",children:"Constructor:"}),(0,i.jsx)(T,{name:"create",func:e.create,onHover:d,onLeave:p,showTooltip:a,pinTooltip:c,hideTooltip:l})]}),(0,i.jsx)("div",{className:"section-label",children:"Main (Runtime):"}),(0,i.jsx)(T,{name:"main",func:e.main,onHover:d,onLeave:p,showTooltip:a,pinTooltip:c,hideTooltip:l})]}),(0,i.jsx)(r,{tooltip:n,onUpdate:s,onClose:u})]})}let S,I,N=!1;function A(e){const{data:t,selected:n}=e;if(!S)return(0,i.jsx)("div",{children:"Loading..."});const{Handle:s,Position:o}=S;return(0,i.jsxs)("div",{className:`cfg-node ${t.isEntry?"entry":""} ${n?"selected":""}`,children:[(0,i.jsx)(s,{type:"target",position:o.Top,id:"top"}),(0,i.jsx)(s,{type:"target",position:o.Left,id:"left"}),(0,i.jsxs)("div",{className:"cfg-node-header",children:[(0,i.jsxs)("strong",{children:[t.functionName,"::",t.label]}),t.isEntry&&(0,i.jsx)("span",{className:"entry-badge",children:"entry"})]}),(0,i.jsxs)("div",{className:"cfg-node-stats",children:[t.instructionCount," instruction",1!==t.instructionCount?"s":""]}),(0,i.jsx)(s,{type:"source",position:o.Bottom,id:"bottom"}),(0,i.jsx)(s,{type:"source",position:o.Right,id:"right"})]})}function D({ir:e}){const[t,n]=(0,s.useState)(null);if(!S||!I)return(0,i.jsxs)("div",{className:"cfg-view",children:[(0,i.jsx)("div",{className:"cfg-header",children:(0,i.jsx)("h3",{children:"Control Flow Graph"})}),(0,i.jsx)("div",{className:"cfg-content",children:(0,i.jsx)("p",{children:"Loading dependencies..."})})]});const{default:o,Controls:r,Background:a,useNodesState:c,useEdgesState:l,useReactFlow:u,MarkerType:d}=S,p=I,m=u(),{initialNodes:f,initialEdges:y}=(0,s.useMemo)((()=>{const t=[],n=[],s=(e,s)=>{const o=Array.from(e.blocks.entries());o.forEach((([n,o])=>{const i=`${s}:${n}`;t.push({id:i,type:"block",position:{x:0,y:0},data:{label:n,block:o,isEntry:n===e.entry,instructionCount:o.instructions.length+1,functionName:s}})})),o.forEach((([e,t])=>{const o=`${s}:${e}`,i=t.terminator;if("jump"===i.kind){const e=`${s}:${i.target}`;n.push({id:`${o}-${e}`,source:o,target:e,sourceHandle:"bottom",targetHandle:"top",markerEnd:{type:d.ArrowClosed}})}else if("branch"===i.kind){const e=`${s}:${i.trueTarget}`,t=`${s}:${i.falseTarget}`;n.push({id:`${o}-${e}-true`,source:o,target:e,sourceHandle:"bottom",targetHandle:"top",label:"true",labelBgStyle:{fill:"#e8f5e9"},style:{stroke:"#4caf50"},markerEnd:{type:d.ArrowClosed,color:"#4caf50"}}),n.push({id:`${o}-${t}-false`,source:o,target:t,sourceHandle:"bottom",targetHandle:"top",label:"false",labelBgStyle:{fill:"#ffebee"},style:{stroke:"#f44336"},markerEnd:{type:d.ArrowClosed,color:"#f44336"}})}else if("call"===i.kind){const e=`${s}:${i.continuation}`;n.push({id:`${o}-${e}-call-cont`,source:o,target:e,sourceHandle:"bottom",targetHandle:"top",label:`after ${i.function}()`,labelBgStyle:{fill:"#f3e8ff"},style:{stroke:"#9333ea"},markerEnd:{type:d.ArrowClosed,color:"#9333ea"}})}}))};if(e.functions)for(const[i,r]of e.functions.entries())s(r,i);e.create&&s(e.create,"create"),s(e.main,"main");const o=new p.graphlib.Graph;o.setDefaultEdgeLabel((()=>({}))),o.setGraph({rankdir:"TB",nodesep:80,ranksep:120,edgesep:50}),t.forEach((e=>{o.setNode(e.id,{width:200,height:80})})),n.forEach((e=>{o.setEdge(e.source,e.target)})),p.layout(o);return{initialNodes:t.map((e=>{const t=o.node(e.id);return{...e,position:{x:t.x-100,y:t.y-40}}})),initialEdges:n}}),[e,d,p]),[g,b,h]=c(f),[k,v,x]=l(y);(0,s.useEffect)((()=>{b(f),v(y),setTimeout((()=>{m?.fitView?.({padding:.2,minZoom:.1,maxZoom:2})}),50)}),[f,y,b,v,m]);const w=(0,s.useCallback)(((e,t)=>{n(t.id)}),[]),T=(0,s.useMemo)((()=>{if(!t)return null;const e=g.find((e=>e.id===t));return e?.data.block??null}),[t,g]),E=(0,s.useMemo)((()=>!t||t.includes("-label")?null:t.replace(":","::")),[t]),N=(0,s.useCallback)((e=>{const t=e=>{if("bigint"==typeof e)return e.toString();if("string"==typeof e)return JSON.stringify(e);if("boolean"==typeof e)return e.toString();const t=e;if(!t.kind)return"?";switch(t.kind){case"const":return String(t.value||"?");case"temp":return`%${t.id||"?"}`;case"local":return`$${t.name||"?"}`;default:return"?"}};switch(e.kind){case"const":return`${e.dest} = ${e.value}`;case"binary":return`${e.dest} = ${t(e.left)} ${e.op} ${t(e.right)}`;case"unary":return`${e.dest} = ${e.op}${t(e.operand)}`;case"read":return"storage"===e.location&&e.slot?`${e.dest} = storage[${t(e.slot)}]`:`${e.dest} = read.${e.location}`;case"write":return"storage"===e.location&&e.slot?`storage[${t(e.slot)}] = ${t(e.value)}`:`write.${e.location} = ${t(e.value)}`;case"env":{const t=e;switch(t.op){case"msg_sender":return`${t.dest} = msg.sender`;case"msg_value":return`${t.dest} = msg.value`;case"msg_data":return`${t.dest} = msg.data`;case"block_timestamp":return`${t.dest} = block.timestamp`;case"block_number":return`${t.dest} = block.number`;default:return`${t.dest} = ${t.op}`}}case"hash":return`${e.dest} = keccak256(${t(e.value)})`;case"cast":return`${e.dest} = cast ${t(e.value)} to ${e.targetType.kind}`;case"compute_slot":if("mapping"===e.slotKind){const n=e;return`${n.dest} = compute_slot[mapping](${t(n.base)}, ${t(n.key)})`}if("array"===e.slotKind){const n=e;return`${n.dest} = compute_slot[array](${t(n.base)})`}if("field"===e.slotKind){const n=e;return`${n.dest} = compute_slot[field](${t(n.base)}, offset_${n.fieldOffset})`}return"unknown compute_slot";default:{const t=e;return`${t.dest||"?"} = ${t.kind||"unknown"}(...)`}}}),[]),D=(0,s.useCallback)((e=>{const t=e=>{if("bigint"==typeof e)return e.toString();if("string"==typeof e)return JSON.stringify(e);if("boolean"==typeof e)return e.toString();const t=e;if(!t.kind)return"?";switch(t.kind){case"const":return String(t.value||"?");case"temp":return`%${t.id||"?"}`;case"local":return`$${t.name||"?"}`;default:return"?"}};switch(e.kind){case"jump":return`jump ${e.target}`;case"branch":return`branch ${t(e.condition)} ? ${e.trueTarget} : ${e.falseTarget}`;case"return":return e.value?`return ${t(e.value)}`:"return void";case"call":{const n=e.arguments.map(t).join(", ");return`${e.dest?`${e.dest} = call ${e.function}(${n})`:`call ${e.function}(${n})`} -> ${e.continuation}`}default:return"unknown terminator"}}),[]),$=(0,s.useMemo)((()=>({block:A})),[]);return(0,i.jsxs)("div",{className:"cfg-view",children:[(0,i.jsx)("div",{className:"cfg-header",children:(0,i.jsx)("h3",{children:"Control Flow Graph"})}),(0,i.jsxs)("div",{className:"cfg-content",children:[(0,i.jsx)("div",{className:"cfg-graph",children:(0,i.jsxs)(o,{nodes:g,edges:k,onNodesChange:h,onEdgesChange:x,onNodeClick:w,nodeTypes:$,fitView:!0,fitViewOptions:{padding:.2,includeHiddenNodes:!1,minZoom:.1,maxZoom:2},minZoom:.05,maxZoom:4,children:[(0,i.jsx)(a,{}),(0,i.jsx)(r,{})]})}),T&&E&&(0,i.jsxs)("div",{className:"cfg-sidebar",children:[(0,i.jsxs)("h4",{children:["Block ",E,(0,i.jsx)("button",{className:"cfg-sidebar-close",onClick:()=>n(null),"aria-label":"Close sidebar",children:"\xd7"})]}),(0,i.jsxs)("div",{className:"block-instructions",children:[(0,i.jsx)("h5",{children:"Instructions:"}),(0,i.jsxs)("pre",{className:"instruction-list",children:[T.instructions.map(((e,t)=>(0,i.jsx)("div",{className:"instruction",children:N(e)},t))),(0,i.jsx)("div",{className:"instruction terminator",children:D(T.terminator)})]})]})]})]})]})}function $(e){const[t,o]=(0,s.useState)(N),[r,a]=(0,s.useState)(null);if((0,s.useEffect)((()=>{t||async function(){if(N)return!0;try{return S=await n.e(6780).then(n.bind(n,16780)),I=await Promise.all([n.e(4841),n.e(7991)]).then(n.t.bind(n,67991,19)),N=!0,!0}catch{return!1}}().then((e=>{e?o(!0):a("CfgView requires react-flow-renderer and dagre packages. Please install them: npm install react-flow-renderer dagre")})).catch((()=>{a("Failed to load CfgView dependencies")}))}),[t]),r)return(0,i.jsxs)("div",{className:"cfg-view",children:[(0,i.jsx)("div",{className:"cfg-header",children:(0,i.jsx)("h3",{children:"Control Flow Graph"})}),(0,i.jsx)("div",{className:"cfg-content",children:(0,i.jsx)("p",{style:{color:"var(--bugc-accent-red)",padding:"1rem"},children:r})})]});if(!t||!S)return(0,i.jsxs)("div",{className:"cfg-view",children:[(0,i.jsx)("div",{className:"cfg-header",children:(0,i.jsx)("h3",{children:"Control Flow Graph"})}),(0,i.jsx)("div",{className:"cfg-content",children:(0,i.jsx)("p",{style:{padding:"1rem"},children:"Loading..."})})]});const{ReactFlowProvider:c}=S;return(0,i.jsx)(c,{children:(0,i.jsx)(D,{...e})})}const M="bug",j={keywords:["contract","function","let","if","else","while","return","storage","memory","calldata","emit","event","mapping","struct","public","private","internal","external","view","pure","payable","constant","immutable"],typeKeywords:["uint256","uint128","uint64","uint32","uint16","uint8","int256","int128","int64","int32","int16","int8","bool","address","bytes32","bytes","string"],operators:["=",">","<","!","~","?",":","==","<=",">=","!=","&&","||","++","--","+","-","*","/","&","|","^","%","<<",">>","+=","-=","*=","/=","&=","|=","^=","%=","<<=",">>="],symbols:/[=><!~?:&|+\-*/^%]+/,escapes:/\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,tokenizer:{root:[[/[a-zA-Z_$][\w$]*/,{cases:{"@keywords":"keyword","@typeKeywords":"type","@default":"identifier"}}],{include:"@whitespace"},[/[{}()[\]]/,"@brackets"],[/[<>](?!@symbols)/,"@brackets"],[/@symbols/,{cases:{"@operators":"operator","@default":""}}],[/\d*\.\d+([eE][-+]?\d+)?/,"number.float"],[/0[xX][0-9a-fA-F]+/,"number.hex"],[/\d+/,"number"],[/[;,.]/,"delimiter"],[/"([^"\\]|\\.)*$/,"string.invalid"],[/"/,{token:"string.quote",bracket:"@open",next:"@string"}],[/'[^\\']'/,"string"],[/(')(@escapes)(')/,["string","string.escape","string"]],[/'/,"string.invalid"]],comment:[[/[^/*]+/,"comment"],[/\/\*/,"comment","@push"],["\\*/","comment","@pop"],[/[/*]/,"comment"]],string:[[/[^\\"]+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/"/,{token:"string.quote",bracket:"@close",next:"@pop"}]],whitespace:[[/[ \t\r\n]+/,"white"],[/\/\*/,"comment","@comment"],[/\/\/.*$/,"comment"]]}},C={comments:{lineComment:"//",blockComment:["/*","*/"]},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}]};let O,_,B=!1;async function U(){if(B)return!0;try{return O=await n.e(6952).then(n.bind(n,86952)),_=await Promise.all([n.e(1869),n.e(1720),n.e(5051)]).then(n.bind(n,91720)),(e=_).languages.register({id:M}),e.languages.setLanguageConfiguration(M,C),e.languages.setMonarchTokensProvider(M,j),B=!0,!0}catch{return!1}var e}function L({value:e,onChange:t,language:n="bug",highlightedRanges:o=[],theme:r="auto",height:a="100%"}){const c=(0,s.useRef)(null),l=(0,s.useRef)([]),[u,d]=(0,s.useState)(B),[p,m]=(0,s.useState)(null),[f,y]=(0,s.useState)("dark");(0,s.useEffect)((()=>{if("auto"===r){const e=()=>{const e=document.documentElement.getAttribute("data-theme");y("dark"===e?"dark":"light")};e();const t=new MutationObserver(e);return t.observe(document.documentElement,{attributes:!0,attributeFilter:["data-theme"]}),()=>t.disconnect()}}),[r]);const g="dark"===("auto"===r?f:r)?"vs-dark":"vs";(0,s.useEffect)((()=>{u||U().then((e=>{e?d(!0):m("Editor requires @monaco-editor/react package. Please install it: npm install @monaco-editor/react")})).catch((()=>{m("Failed to load Monaco editor")}))}),[u]),(0,s.useEffect)((()=>{const e=c.current;if(!e)return;const t=e.getModel();if(t&&(l.current=e.deltaDecorations(l.current,[]),o.length>0)){const n=o.map(((e,n)=>{const s=t.getPositionAt(e.offset),o=t.getPositionAt(e.offset+e.length),i=0===n,r=i?"opcode-hover-highlight":"opcode-hover-highlight-alternative",a=i?"opcode-hover-highlight-inline":"opcode-hover-highlight-alternative-inline";return{range:{startLineNumber:s.lineNumber,startColumn:s.column,endLineNumber:o.lineNumber,endColumn:o.column},options:{className:r,isWholeLine:!1,inlineClassName:a}}}));l.current=e.deltaDecorations([],n);const s=o[0],i=t.getPositionAt(s.offset),r=t.getPositionAt(s.offset+s.length);e.revealRangeInCenter({startLineNumber:i.lineNumber,startColumn:i.column,endLineNumber:r.lineNumber,endColumn:r.column})}}),[o]);if(p)return(0,i.jsx)("div",{style:{padding:"1rem",color:"var(--bugc-accent-red, #cf222e)"},children:p});if(!u||!O)return(0,i.jsx)("div",{style:{padding:"1rem"},children:"Loading editor..."});const b=O.default;return(0,i.jsx)(b,{height:a,language:n,theme:g,value:e,onChange:e=>t(e||""),onMount:e=>{c.current=e},options:{minimap:{enabled:!1},fontSize:14,lineNumbers:"on",scrollBeyondLastLine:!1,automaticLayout:!0,tabSize:2}})}},48974(e,t,n){n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>d,default:()=>y,frontMatter:()=>u,metadata:()=>s,toc:()=>m});const s=JSON.parse('{"id":"examples/bug-playground","title":"BUG playground","description":"BUG is a minimal smart contract language designed for demonstrating and testing","source":"@site/docs/examples/bug-playground.mdx","sourceDirName":"examples","slug":"/examples/bug-playground","permalink":"/format/pr-preview/pr-168/docs/examples/bug-playground","draft":false,"unlisted":false,"editUrl":"https://github.com/ethdebug/format/tree/main/packages/web/docs/examples/bug-playground.mdx","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Examples","permalink":"/format/pr-preview/pr-168/docs/examples/"},"next":{"title":"Goals","permalink":"/format/pr-preview/pr-168/docs/reference/goals"}}');var o=n(31085),i=n(71184),r=n(39612),a=n(14041),c=n(9921);function l({initialCode:e="name Counter;\n\nstorage {\n  [0] count: uint256;\n  [1] threshold: uint256;\n}\n\ncreate {\n  count = 0;\n  threshold = 100;\n}\n\ncode {\n  // Increment the counter\n  count = count + 1;\n\n  // Check threshold\n  if (count >= threshold) {\n    count = 0;\n  }\n}\n",defaultOptimizationLevel:t=3,showOptimizationSelector:n=!0,height:s="600px"}){const[i,l]=(0,a.useState)(e),[u,d]=(0,a.useState)(t),[p,m]=(0,a.useState)(null),[f,y]=(0,a.useState)(!1),[g,b]=(0,a.useState)("ast"),[h,k]=(0,a.useState)([]),v=(0,a.useCallback)((e=>{k(e)}),[]),x=(0,a.useCallback)((async()=>{y(!0);try{const e=await async function(e,t){const n=await(0,c.wE)({to:"ast",source:e});if(!n.success){const e=n.messages[c.AI.Error]||[],t=n.messages[c.AI.Warning]||[];return{success:!1,error:e[0]?.message||"Parse failed",warnings:t.map((e=>e.message))}}const s=n.value.ast,o=await(0,c.wE)({to:"ir",source:e,optimizer:{level:t}});if(!o.success){const e=o.messages[c.AI.Error]||[],t=o.messages[c.AI.Warning]||[];return{success:!1,error:e[0]?.message||"IR generation failed",ast:s,warnings:t.map((e=>e.message))}}const i=o.value.ir,r=await(0,c.wE)({to:"bytecode",source:e,optimizer:{level:t}});if(!r.success){const e=r.messages[c.AI.Error]||[],t=r.messages[c.AI.Warning]||[];return{success:!1,error:e[0]?.message||"Bytecode generation failed",ast:s,warnings:t.map((e=>e.message))}}const a={runtime:r.value.bytecode.runtime,create:r.value.bytecode.create,runtimeInstructions:r.value.bytecode.runtimeInstructions,createInstructions:r.value.bytecode.createInstructions},l=[...n.messages[c.AI.Warning]||[],...o.messages[c.AI.Warning]||[],...r.messages[c.AI.Warning]||[]].map((e=>e.message));return{success:!0,ast:s,ir:i,bytecode:a,warnings:[...new Set(l)]}}(i,u);m(e),e.success||b("ast")}catch(e){m({success:!1,error:e instanceof Error?e.message:"Unknown error",warnings:[]})}finally{y(!1)}}),[i,u]);(0,a.useEffect)((()=>{x()}),[]);return(0,o.jsxs)("div",{className:"bug-playground",style:{height:s},children:[(0,o.jsx)("div",{className:"bug-playground-header",children:(0,o.jsxs)("div",{className:"bug-playground-controls",children:[n&&(0,o.jsxs)("label",{className:"bug-playground-opt-control",children:[(0,o.jsx)("span",{children:"Optimization:"}),(0,o.jsxs)("select",{value:u,onChange:e=>d(Number(e.target.value)),children:[(0,o.jsx)("option",{value:"0",children:"0 - None"}),(0,o.jsx)("option",{value:"1",children:"1 - Basic"}),(0,o.jsx)("option",{value:"2",children:"2 - Standard"}),(0,o.jsx)("option",{value:"3",children:"3 - Full"})]})]}),(0,o.jsx)("button",{onClick:x,disabled:f,className:"bug-playground-compile-btn",children:f?"Compiling...":"Compile"})]})}),(0,o.jsxs)("div",{className:"bug-playground-content",children:[(0,o.jsx)("div",{className:"bug-playground-editor",children:(0,o.jsx)(r.KE,{value:i,onChange:l,language:"bug",highlightedRanges:h})}),(0,o.jsxs)("div",{className:"bug-playground-output",children:[p&&!p.success&&(0,o.jsxs)("div",{className:"bug-playground-error",children:[(0,o.jsx)("h4",{children:"Compilation Error"}),(0,o.jsx)("pre",{children:p.error})]}),p?.success&&(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)("div",{className:"bug-playground-tabs",children:[{id:"ast",label:"AST"},{id:"ir",label:"IR"},{id:"cfg",label:"CFG"},{id:"bytecode",label:"Bytecode"}].map((e=>(0,o.jsx)("button",{className:"bug-playground-tab "+(g===e.id?"active":""),onClick:()=>b(e.id),children:e.label},e.id)))}),(0,o.jsxs)("div",{className:"bug-playground-tab-content",children:["ast"===g&&p.ast&&(0,o.jsx)(r.yZ,{ast:p.ast}),"ir"===g&&p.ir&&(0,o.jsx)(r.TE,{ir:p.ir,onOpcodeHover:v}),"cfg"===g&&p.ir&&(0,o.jsx)(r.MT,{ir:p.ir}),"bytecode"===g&&p.bytecode&&(0,o.jsx)(r.dV,{bytecode:p.bytecode,onOpcodeHover:v})]})]}),p&&p.warnings.length>0&&(0,o.jsxs)("div",{className:"bug-playground-warnings",children:[(0,o.jsx)("h4",{children:"Warnings"}),(0,o.jsx)("ul",{children:p.warnings.map(((e,t)=>(0,o.jsx)("li",{children:e},t)))})]})]})]})]})}const u={sidebar_position:2},d="BUG playground",p={},m=[{value:"About BUG",id:"about-bug",level:2},{value:"Things to try",id:"things-to-try",level:2},{value:"Compilation views",id:"compilation-views",level:2}];function f(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"bug-playground",children:"BUG playground"})}),"\n",(0,o.jsxs)(t.p,{children:["BUG is a minimal smart contract language designed for demonstrating and testing\n",(0,o.jsx)(t.strong,{children:"ethdebug/format"}),". It compiles to EVM bytecode and produces rich debug\ninformation."]}),"\n",(0,o.jsx)(t.p,{children:"Use the interactive playground below to explore how BUG code compiles to\nintermediate representations and EVM bytecode."}),"\n","\n",(0,o.jsx)(l,{height:"700px"}),"\n",(0,o.jsx)(t.h2,{id:"about-bug",children:"About BUG"}),"\n",(0,o.jsxs)(t.p,{children:["BUG is intentionally minimal\u2014it provides just enough\nlanguage features to demonstrate the debugging challenges that\n",(0,o.jsx)(t.strong,{children:"ethdebug/format"})," addresses:"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Storage variables"})," with automatic slot allocation"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Functions"})," with parameters and return values"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Control flow"})," (if/else, while loops)"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Basic types"})," (uint256, bool, address, bytes32)"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Complex types"})," (arrays, mappings, structs)"]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"things-to-try",children:"Things to try"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Edit the source code"})," in the left panel and watch the outputs\nupdate. Try adding a new storage variable or changing a loop\nbound."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Switch between views"})," (AST, IR, CFG, Bytecode) to see how\nsource code transforms through each compilation stage."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Hover over instructions"})," in the IR or Bytecode views to see\nwhich source code they correspond to."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Inspect the Bytecode view"})," to see ",(0,o.jsx)(t.strong,{children:"ethdebug/format"})," program\nannotations \u2014 each instruction shows its offset, operation, and\ncontext (source ranges, variables in scope)."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Look at the CFG"})," to understand control flow structure \u2014 useful\nfor seeing how ",(0,o.jsx)(t.code,{children:"if"}),"/",(0,o.jsx)(t.code,{children:"while"})," compiles to branching bytecode."]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"compilation-views",children:"Compilation views"}),"\n",(0,o.jsx)(t.p,{children:"The playground shows several stages of compilation:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"AST"})," \u2014 The abstract syntax tree after parsing"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"IR"})," \u2014 The intermediate representation used for optimization"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"CFG"})," \u2014 The control flow graph visualizing program structure"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Bytecode"})," \u2014 The final EVM bytecode with debug annotations"]}),"\n"]})]})}function y(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(f,{...e})}):f(e)}}}]);