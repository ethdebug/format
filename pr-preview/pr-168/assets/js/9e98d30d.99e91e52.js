"use strict";(globalThis.webpackChunk_ethdebug_format_web=globalThis.webpackChunk_ethdebug_format_web||[]).push([[5589],{47282(e){e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"docsSidebar":[{"type":"link","href":"/format/pr-preview/pr-168/docs/overview","label":"Project overview","docId":"overview","unlisted":false},{"type":"category","label":"Getting Started","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/format/pr-preview/pr-168/docs/getting-started/for-debugger-authors","label":"For debugger authors","docId":"getting-started/for-debugger-authors","unlisted":false},{"type":"link","href":"/format/pr-preview/pr-168/docs/getting-started/for-compiler-authors","label":"For compiler authors","docId":"getting-started/for-compiler-authors","unlisted":false}],"href":"/format/pr-preview/pr-168/docs/getting-started/"},{"type":"category","label":"Concepts","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/format/pr-preview/pr-168/docs/concepts/data-locations","label":"Data locations","docId":"concepts/data-locations","unlisted":false}],"href":"/format/pr-preview/pr-168/docs/concepts/"},{"type":"category","label":"Types","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/format/pr-preview/pr-168/docs/types/elementary","label":"Elementary types","docId":"types/elementary","unlisted":false},{"type":"link","href":"/format/pr-preview/pr-168/docs/types/composite","label":"Composite types","docId":"types/composite","unlisted":false},{"type":"link","href":"/format/pr-preview/pr-168/docs/types/representation","label":"Representation","docId":"types/representation","unlisted":false}],"href":"/format/pr-preview/pr-168/docs/types/"},{"type":"category","label":"Pointers","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/format/pr-preview/pr-168/docs/pointers/regions","label":"Regions","docId":"pointers/regions","unlisted":false},{"type":"link","href":"/format/pr-preview/pr-168/docs/pointers/expressions","label":"Expressions","docId":"pointers/expressions","unlisted":false},{"type":"link","href":"/format/pr-preview/pr-168/docs/pointers/collections","label":"Collections","docId":"pointers/collections","unlisted":false}],"href":"/format/pr-preview/pr-168/docs/pointers/"},{"type":"category","label":"Programs","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/format/pr-preview/pr-168/docs/programs/instructions","label":"Instructions","docId":"programs/instructions","unlisted":false},{"type":"link","href":"/format/pr-preview/pr-168/docs/programs/variables","label":"Variables","docId":"programs/variables","unlisted":false},{"type":"link","href":"/format/pr-preview/pr-168/docs/programs/tracing","label":"Tracing execution","docId":"programs/tracing","unlisted":false}],"href":"/format/pr-preview/pr-168/docs/programs/"},{"type":"category","label":"Implementation Guides","collapsible":true,"collapsed":true,"items":[{"type":"category","label":"Dereferencing pointers","collapsible":true,"collapsed":true,"items":[{"type":"category","label":"Essential type definitions","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/format/pr-preview/pr-168/docs/implementation-guides/pointers/types/pointer-types","label":"Pointer types","docId":"implementation-guides/pointers/types/pointer-types","unlisted":false},{"type":"link","href":"/format/pr-preview/pr-168/docs/implementation-guides/pointers/types/data-and-machines","label":"Data and machines","docId":"implementation-guides/pointers/types/data-and-machines","unlisted":false},{"type":"link","href":"/format/pr-preview/pr-168/docs/implementation-guides/pointers/types/cursors","label":"Cursor objects","docId":"implementation-guides/pointers/types/cursors","unlisted":false}],"href":"/format/pr-preview/pr-168/docs/implementation-guides/pointers/types/"},{"type":"link","href":"/format/pr-preview/pr-168/docs/implementation-guides/pointers/reading-from-regions","label":"Reading from pointer regions","docId":"implementation-guides/pointers/reading-from-regions","unlisted":false},{"type":"link","href":"/format/pr-preview/pr-168/docs/implementation-guides/pointers/evaluating-expressions","label":"Evaluating pointer expressions","docId":"implementation-guides/pointers/evaluating-expressions","unlisted":false},{"type":"category","label":"The dereference function","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/format/pr-preview/pr-168/docs/implementation-guides/pointers/dereference-logic/generating-regions","label":"Generating regions on the fly","docId":"implementation-guides/pointers/dereference-logic/generating-regions","unlisted":false},{"type":"link","href":"/format/pr-preview/pr-168/docs/implementation-guides/pointers/dereference-logic/making-regions-concrete","label":"Making regions concrete","docId":"implementation-guides/pointers/dereference-logic/making-regions-concrete","unlisted":false}],"href":"/format/pr-preview/pr-168/docs/implementation-guides/pointers/dereference-logic/"},{"type":"category","label":"End-to-end testing","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/format/pr-preview/pr-168/docs/implementation-guides/pointers/testing/example-pointers","label":"Finding example pointers","docId":"implementation-guides/pointers/testing/example-pointers","unlisted":false},{"type":"link","href":"/format/pr-preview/pr-168/docs/implementation-guides/pointers/testing/compilation","label":"Invoking the compiler","docId":"implementation-guides/pointers/testing/compilation","unlisted":false},{"type":"link","href":"/format/pr-preview/pr-168/docs/implementation-guides/pointers/testing/blockchain-simulation","label":"Simulating a blockchain","docId":"implementation-guides/pointers/testing/blockchain-simulation","unlisted":false},{"type":"link","href":"/format/pr-preview/pr-168/docs/implementation-guides/pointers/testing/deployment","label":"Deploying contracts","docId":"implementation-guides/pointers/testing/deployment","unlisted":false},{"type":"link","href":"/format/pr-preview/pr-168/docs/implementation-guides/pointers/testing/machine-observation","label":"Observing the machine","docId":"implementation-guides/pointers/testing/machine-observation","unlisted":false},{"type":"category","label":"Test cases","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/format/pr-preview/pr-168/docs/implementation-guides/pointers/testing/test-cases/struct-storage","label":"<struct> storage","docId":"implementation-guides/pointers/testing/test-cases/struct-storage","unlisted":false},{"type":"link","href":"/format/pr-preview/pr-168/docs/implementation-guides/pointers/testing/test-cases/string-storage","label":"string storage","docId":"implementation-guides/pointers/testing/test-cases/string-storage","unlisted":false},{"type":"link","href":"/format/pr-preview/pr-168/docs/implementation-guides/pointers/testing/test-cases/uint256-array-memory","label":"uint256[] memory","docId":"implementation-guides/pointers/testing/test-cases/uint256-array-memory","unlisted":false}],"href":"/format/pr-preview/pr-168/docs/implementation-guides/pointers/testing/test-cases/"},{"type":"link","href":"/format/pr-preview/pr-168/docs/implementation-guides/pointers/testing/jest","label":"Hooking up Jest","docId":"implementation-guides/pointers/testing/jest","unlisted":false}],"href":"/format/pr-preview/pr-168/docs/implementation-guides/pointers/testing/"}],"href":"/format/pr-preview/pr-168/docs/implementation-guides/pointers/"},{"type":"category","label":"Compiler Guides","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/format/pr-preview/pr-168/docs/implementation-guides/compiler/case-study-bug","label":"Case Study: BUG","docId":"implementation-guides/compiler/case-study-bug","unlisted":false}],"href":"/format/pr-preview/pr-168/docs/implementation-guides/compiler/"}],"href":"/format/pr-preview/pr-168/docs/implementation-guides/"},{"type":"category","label":"Examples","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/format/pr-preview/pr-168/docs/examples/bug-playground","label":"BUG Playground","docId":"examples/bug-playground","unlisted":false}],"href":"/format/pr-preview/pr-168/docs/examples/"},{"type":"category","label":"Reference","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/format/pr-preview/pr-168/docs/reference/goals","label":"Goals","docId":"reference/goals","unlisted":false},{"type":"link","href":"/format/pr-preview/pr-168/docs/reference/challenges","label":"Challenges","docId":"reference/challenges","unlisted":false},{"type":"link","href":"/format/pr-preview/pr-168/docs/reference/glossary","label":"Glossary","docId":"reference/glossary","unlisted":false}]}]},"docs":{"concepts/data-locations":{"id":"concepts/data-locations","title":"Data locations","description":"The EVM stores data in several distinct locations, each with different","sidebar":"docsSidebar"},"concepts/index":{"id":"concepts/index","title":"Concepts","description":"This section introduces the core concepts behind ethdebug/format. Understanding","sidebar":"docsSidebar"},"examples/bug-playground":{"id":"examples/bug-playground","title":"BUG Playground","description":"BUG is a minimal smart contract language designed for demonstrating and testing","sidebar":"docsSidebar"},"examples/index":{"id":"examples/index","title":"Examples","description":"Interactive examples demonstrating ethdebug/format concepts.","sidebar":"docsSidebar"},"getting-started/for-compiler-authors":{"id":"getting-started/for-compiler-authors","title":"For compiler authors","description":"You\'re building a compiler or toolchain that produces EVM bytecode. Here\'s how","sidebar":"docsSidebar"},"getting-started/for-debugger-authors":{"id":"getting-started/for-debugger-authors","title":"For debugger authors","description":"You\'re building a debugger, transaction tracer, or analysis tool. Here\'s how","sidebar":"docsSidebar"},"getting-started/index":{"id":"getting-started/index","title":"Getting started","description":"Welcome to ethdebug/format! This section helps you get started based on what","sidebar":"docsSidebar"},"implementation-guides/compiler/case-study-bug":{"id":"implementation-guides/compiler/case-study-bug","title":"Case Study: BUG Compiler","description":"BUG is a small experimental language designed to demonstrate ethdebug/format","sidebar":"docsSidebar"},"implementation-guides/compiler/index":{"id":"implementation-guides/compiler/index","title":"Compiler Implementation Guides","description":"Guides for implementing ethdebug/format support in compilers.","sidebar":"docsSidebar"},"implementation-guides/implementation-guides":{"id":"implementation-guides/implementation-guides","title":"Implementation guides","description":"These guides help you implement ethdebug/format support in your project.","sidebar":"docsSidebar"},"implementation-guides/pointers/dereference-logic/dereference-logic":{"id":"implementation-guides/pointers/dereference-logic/dereference-logic","title":"The dereference() function","description":"Summary","sidebar":"docsSidebar"},"implementation-guides/pointers/dereference-logic/generating-regions":{"id":"implementation-guides/pointers/dereference-logic/generating-regions","title":"Generating regions on the fly","description":"The dereference() function internally creates an","sidebar":"docsSidebar"},"implementation-guides/pointers/dereference-logic/making-regions-concrete":{"id":"implementation-guides/pointers/dereference-logic/making-regions-concrete","title":"Making regions concrete","description":"There are two main aspects involved when converting from a Pointer.Region,","sidebar":"docsSidebar"},"implementation-guides/pointers/evaluating-expressions":{"id":"implementation-guides/pointers/evaluating-expressions","title":"Evaluating pointer expressions","description":"Expression evaluation is a bit more interesting than reading raw region data,","sidebar":"docsSidebar"},"implementation-guides/pointers/pointers":{"id":"implementation-guides/pointers/pointers","title":"Dereferencing pointers","description":"_An implementation guide for resolving ethdebug/format/pointers","sidebar":"docsSidebar"},"implementation-guides/pointers/reading-from-regions":{"id":"implementation-guides/pointers/reading-from-regions","title":"Reading from pointer regions","description":"Being able to read a particular pointer region\'s data from a machine state","sidebar":"docsSidebar"},"implementation-guides/pointers/testing/blockchain-simulation":{"id":"implementation-guides/pointers/testing/blockchain-simulation","title":"Simulating a blockchain","description":"In case you missed the","sidebar":"docsSidebar"},"implementation-guides/pointers/testing/compilation":{"id":"implementation-guides/pointers/testing/compilation","title":"Invoking the compiler","description":"In being able to test a pointer dereference implementation, it is necessary to","sidebar":"docsSidebar"},"implementation-guides/pointers/testing/deployment":{"id":"implementation-guides/pointers/testing/deployment","title":"Deploying contracts","description":"Deploying a contract with some EVM bytecode is straightforward with","sidebar":"docsSidebar"},"implementation-guides/pointers/testing/example-pointers":{"id":"implementation-guides/pointers/testing/example-pointers","title":"Finding example pointers","description":"These integration tests seek to minimize the use of bespoke data whose","sidebar":"docsSidebar"},"implementation-guides/pointers/testing/jest":{"id":"implementation-guides/pointers/testing/jest","title":"Hooking up Jest","description":"Putting all the pieces together, the following code listing shows the top-level","sidebar":"docsSidebar"},"implementation-guides/pointers/testing/machine-observation":{"id":"implementation-guides/pointers/testing/machine-observation","title":"Observing the machine","description":"These integration tests leverage the observeTrace() helper function to","sidebar":"docsSidebar"},"implementation-guides/pointers/testing/test-cases/string-storage":{"id":"implementation-guides/pointers/testing/test-cases/string-storage","title":"Test case: string storage","description":"Representing a Solidity string storage using an ethdebug/format/pointer","sidebar":"docsSidebar"},"implementation-guides/pointers/testing/test-cases/struct-storage":{"id":"implementation-guides/pointers/testing/test-cases/struct-storage","title":"Test case: <struct> storage","description":"Solidity tightly packs struct storage words starting from the right-hand side.","sidebar":"docsSidebar"},"implementation-guides/pointers/testing/test-cases/test-cases":{"id":"implementation-guides/pointers/testing/test-cases/test-cases","title":"Test cases","description":"This reference implementation currently defines the following integration test","sidebar":"docsSidebar"},"implementation-guides/pointers/testing/test-cases/uint256-array-memory":{"id":"implementation-guides/pointers/testing/test-cases/uint256-array-memory","title":"Test case: uint256[] memory","description":"Memory arrays are primarily referenced using stack-located memory offset values,","sidebar":"docsSidebar"},"implementation-guides/pointers/testing/testing":{"id":"implementation-guides/pointers/testing/testing","title":"End-to-end testing","description":"Summary","sidebar":"docsSidebar"},"implementation-guides/pointers/types/cursors":{"id":"implementation-guides/pointers/types/cursors","title":"Cursor objects","description":"The core functionality that @ethdebug/pointers provides is the","sidebar":"docsSidebar"},"implementation-guides/pointers/types/data-and-machines":{"id":"implementation-guides/pointers/types/data-and-machines","title":"Data and machines","description":"The @ethdebug/pointers package includes two abstractions that it uses for","sidebar":"docsSidebar"},"implementation-guides/pointers/types/pointer-types":{"id":"implementation-guides/pointers/types/pointer-types","title":"Pointer types","description":"Types and type guards for all kinds of pointers","sidebar":"docsSidebar"},"implementation-guides/pointers/types/types":{"id":"implementation-guides/pointers/types/types","title":"Essential type definitions","description":"This reference implementation uses a few fundamental types/interfaces for","sidebar":"docsSidebar"},"overview":{"id":"overview","title":"Project overview","description":"ethdebug/format is an open specification for debugging information in","sidebar":"docsSidebar"},"pointers/collections":{"id":"pointers/collections","title":"Collections","description":"While regions describe single contiguous byte ranges, collections","sidebar":"docsSidebar"},"pointers/expressions":{"id":"pointers/expressions","title":"Expressions","description":"Static offsets work for simple variables, but most interesting data has","sidebar":"docsSidebar"},"pointers/index":{"id":"pointers/index","title":"Pointers","description":"Pointers describe where data lives in the EVM. They\'re recipes that tell a","sidebar":"docsSidebar"},"pointers/regions":{"id":"pointers/regions","title":"Regions","description":"A region represents a contiguous block of bytes in a specific EVM data","sidebar":"docsSidebar"},"programs/index":{"id":"programs/index","title":"Programs","description":"Programs describe the high-level context at each point in EVM bytecode","sidebar":"docsSidebar"},"programs/instructions":{"id":"programs/instructions","title":"Instructions","description":"Each instruction record in a program corresponds to one EVM opcode in the","sidebar":"docsSidebar"},"programs/tracing":{"id":"programs/tracing","title":"Tracing execution","description":"Tracing brings together programs, pointers, and types to show what\'s happening","sidebar":"docsSidebar"},"programs/variables":{"id":"programs/variables","title":"Variables","description":"Variables connect source-level identifiers to runtime locations. They\'re the","sidebar":"docsSidebar"},"reference/challenges":{"id":"reference/challenges","title":"Challenges","description":"The fundamental challenge for an Ethereum debugging data format is that, on the","sidebar":"docsSidebar"},"reference/glossary":{"id":"reference/glossary","title":"Glossary","description":"This page defines key terms used throughout the ethdebug/format specification","sidebar":"docsSidebar"},"reference/goals":{"id":"reference/goals","title":"Goals","description":"Create a universal format","sidebar":"docsSidebar"},"types/composite":{"id":"types/composite","title":"Composite types","description":"Composite types (also called complex types) contain other types. They use the","sidebar":"docsSidebar"},"types/elementary":{"id":"types/elementary","title":"Elementary types","description":"Elementary types are atomic\u2014they don\'t contain other types. These form the","sidebar":"docsSidebar"},"types/index":{"id":"types/index","title":"Types","description":"Types in ethdebug/format describe the structure and interpretation of raw","sidebar":"docsSidebar"},"types/representation":{"id":"types/representation","title":"Representation","description":"Types in ethdebug/format describe what data is, but compilers must also","sidebar":"docsSidebar"}}}}')}}]);