"use strict";(globalThis.webpackChunk_ethdebug_format_web=globalThis.webpackChunk_ethdebug_format_web||[]).push([[4380],{80220(e,n,s){s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"programs/variables","title":"Variables","description":"Variables connect source-level identifiers to runtime locations. They\'re the","source":"@site/docs/programs/variables.mdx","sourceDirName":"programs","slug":"/programs/variables","permalink":"/format/pr-preview/pr-168/docs/programs/variables","draft":false,"unlisted":false,"editUrl":"https://github.com/ethdebug/format/tree/main/packages/web/docs/programs/variables.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Instructions","permalink":"/format/pr-preview/pr-168/docs/programs/instructions"},"next":{"title":"Tracing execution","permalink":"/format/pr-preview/pr-168/docs/programs/tracing"}}');var r=s(31085),t=s(71184);const l={sidebar_position:3},a="Variables",o={},c=[{value:"Variable structure",id:"variable-structure",level:2},{value:"Types tell debuggers how to decode",id:"types-tell-debuggers-how-to-decode",level:2},{value:"Pointers tell debuggers where to look",id:"pointers-tell-debuggers-where-to-look",level:2},{value:"Scope and lifetime",id:"scope-and-lifetime",level:2},{value:"Example: Local variable lifecycle",id:"example-local-variable-lifecycle",level:2},{value:"Multiple variables",id:"multiple-variables",level:2},{value:"Learn more",id:"learn-more",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"variables",children:"Variables"})}),"\n",(0,r.jsx)(n.p,{children:"Variables connect source-level identifiers to runtime locations. They're the\nkey to showing developers meaningful values instead of raw bytes."}),"\n",(0,r.jsx)(n.h2,{id:"variable-structure",children:"Variable structure"}),"\n",(0,r.jsx)(n.p,{children:"A variable declaration includes three parts:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "name": "balance",\n  "type": { "kind": "uint", "bits": 256 },\n  "pointer": {\n    "location": "storage",\n    "slot": 0\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"name"})}),": the identifier from source code"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"type"})}),": how to interpret the bytes (an ethdebug/format type)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"pointer"})}),": where to find the bytes (an ethdebug/format pointer)"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"types-tell-debuggers-how-to-decode",children:"Types tell debuggers how to decode"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"type"})," field references the type system. A debugger uses this to:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Know how many bytes to read"}),"\n",(0,r.jsx)(n.li,{children:"Interpret those bytes correctly (signed vs unsigned, struct layout, etc.)"}),"\n",(0,r.jsx)(n.li,{children:"Display the value in a readable format"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"For complex types, the type definition guides the debugger through nested\nstructures:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "name": "user",\n  "type": {\n    "kind": "struct",\n    "contains": [\n      { "name": "id", "type": { "kind": "uint", "bits": 256 } },\n      { "name": "active", "type": { "kind": "bool" } }\n    ]\n  },\n  "pointer": { ... }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"pointers-tell-debuggers-where-to-look",children:"Pointers tell debuggers where to look"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"pointer"})," field specifies the data's location. This can be simple:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "pointer": {\n    "location": "stack",\n    "slot": 0\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Or complex, for data spread across multiple locations:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "pointer": {\n    "group": [\n      { "name": "id", "location": "storage", "slot": 5 },\n      { "name": "active", "location": "storage", "slot": 5, "offset": 31 }\n    ]\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"scope-and-lifetime",children:"Scope and lifetime"}),"\n",(0,r.jsxs)(n.p,{children:["Variables appear in context when they're valid. The instruction's context\nrepresents what's true ",(0,r.jsx)(n.em,{children:"after"})," that instruction executes."]}),"\n",(0,r.jsx)(n.p,{children:"A variable might:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Become available when a function is entered"}),"\n",(0,r.jsx)(n.li,{children:"Change location as it moves from stack to memory"}),"\n",(0,r.jsx)(n.li,{children:"Go out of scope when a block ends"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The instruction list captures these transitions. As a debugger steps through\nexecution, it accumulates and discards variables based on each instruction's\ncontext."}),"\n",(0,r.jsx)(n.h2,{id:"example-local-variable-lifecycle",children:"Example: Local variable lifecycle"}),"\n",(0,r.jsx)(n.p,{children:"Consider this Solidity snippet:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"function transfer(address to, uint256 amount) {\n    uint256 balance = balances[msg.sender];\n    // ... use balance ...\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"The compiled bytecode might have:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Instruction at offset 50"}),": ",(0,r.jsx)(n.code,{children:"balance"})," comes into scope, stored on stack"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Instructions 51-100"}),": ",(0,r.jsx)(n.code,{children:"balance"})," remains in scope"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Instruction at offset 101"}),": ",(0,r.jsx)(n.code,{children:"balance"})," leaves scope (function returns)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The program captures this by including ",(0,r.jsx)(n.code,{children:"balance"})," in the variables list for\ninstructions 50-100 and omitting it afterward."]}),"\n",(0,r.jsx)(n.h2,{id:"multiple-variables",children:"Multiple variables"}),"\n",(0,r.jsx)(n.p,{children:"An instruction's context can declare multiple variables:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "offset": 75,\n  "context": {\n    "variables": [\n      {\n        "name": "sender",\n        "type": { "kind": "address" },\n        "pointer": { "location": "stack", "slot": 2 }\n      },\n      {\n        "name": "value",\n        "type": { "kind": "uint", "bits": 256 },\n        "pointer": { "location": "stack", "slot": 1 }\n      },\n      {\n        "name": "success",\n        "type": { "kind": "bool" },\n        "pointer": { "location": "stack", "slot": 0 }\n      }\n    ]\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"learn-more",children:"Learn more"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"../types",children:"Types documentation"})," for type representation details"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"../pointers",children:"Pointers documentation"})," for location specification"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/spec/program/context/variables",children:"Context schema"})," for the full schema"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);