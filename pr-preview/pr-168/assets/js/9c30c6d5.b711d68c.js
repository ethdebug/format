"use strict";(globalThis.webpackChunk_ethdebug_format_web=globalThis.webpackChunk_ethdebug_format_web||[]).push([[888],{55225(e,n,t){t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"programs/instructions","title":"Instructions","description":"Each instruction record in a program corresponds to one EVM opcode in the","source":"@site/docs/programs/instructions.mdx","sourceDirName":"programs","slug":"/programs/instructions","permalink":"/format/pr-preview/pr-168/docs/programs/instructions","draft":false,"unlisted":false,"editUrl":"https://github.com/ethdebug/format/tree/main/packages/web/docs/programs/instructions.mdx","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Programs","permalink":"/format/pr-preview/pr-168/docs/programs/"},"next":{"title":"Variables","permalink":"/format/pr-preview/pr-168/docs/programs/variables"}}');var s=t(31085),i=t(71184);const o={sidebar_position:2},c="Instructions",a={},d=[{value:"Structure",id:"structure",level:2},{value:"Context types",id:"context-types",level:2},{value:"Code context",id:"code-context",level:3},{value:"Variables context",id:"variables-context",level:3},{value:"Frame context",id:"frame-context",level:3},{value:"Composing contexts",id:"composing-contexts",level:2},{value:"Gather",id:"gather",level:3},{value:"Pick",id:"pick",level:3},{value:"Remark",id:"remark",level:3},{value:"Instruction ordering",id:"instruction-ordering",level:2},{value:"Learn more",id:"learn-more",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"instructions",children:"Instructions"})}),"\n",(0,s.jsx)(n.p,{children:"Each instruction record in a program corresponds to one EVM opcode in the\nbytecode. Instructions carry the context information that debuggers need."}),"\n",(0,s.jsx)(n.h2,{id:"structure",children:"Structure"}),"\n",(0,s.jsx)(n.p,{children:"An instruction has two required fields:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "offset": 42,\n  "context": { ... }\n}\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"offset"})}),": byte position in the bytecode (the program counter value when\nthis instruction executes)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"context"})}),": high-level information valid after this instruction"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"context-types",children:"Context types"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"context"})," field can take several forms:"]}),"\n",(0,s.jsx)(n.h3,{id:"code-context",children:"Code context"}),"\n",(0,s.jsx)(n.p,{children:"Maps the instruction to source code:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "offset": 42,\n  "context": {\n    "code": {\n      "source": {\n        "id": 0,\n        "range": {\n          "start": { "line": 10, "column": 4 },\n          "end": { "line": 10, "column": 20 }\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"source"})," field references a source file by ID and specifies the exact\ncharacter range."]}),"\n",(0,s.jsx)(n.h3,{id:"variables-context",children:"Variables context"}),"\n",(0,s.jsx)(n.p,{children:"Declares variables that are in scope:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "offset": 100,\n  "context": {\n    "variables": [\n      {\n        "name": "amount",\n        "type": { "kind": "uint", "bits": 256 },\n        "pointer": {\n          "location": "stack",\n          "slot": 0\n        }\n      }\n    ]\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Each variable includes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"name"}),": the identifier from source code"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"type"}),": an ethdebug/format type reference"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"pointer"}),": where to find the variable's value"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"frame-context",children:"Frame context"}),"\n",(0,s.jsx)(n.p,{children:"Indicates call stack changes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "offset": 200,\n  "context": {\n    "frame": "step-in"\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Frame values include:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:'"step-in"'}),": entering a function"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:'"step-out"'}),": returning from a function"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"composing-contexts",children:"Composing contexts"}),"\n",(0,s.jsx)(n.h3,{id:"gather",children:"Gather"}),"\n",(0,s.jsx)(n.p,{children:"Combine multiple contexts (like nested scopes):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "offset": 150,\n  "context": {\n    "gather": [\n      {\n        "code": {\n          "source": { "id": 0, "range": { ... } }\n        }\n      },\n      {\n        "variables": [\n          { "name": "x", "type": { ... }, "pointer": { ... } }\n        ]\n      }\n    ]\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"pick",children:"Pick"}),"\n",(0,s.jsx)(n.p,{children:"Choose between contexts based on runtime conditions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "offset": 175,\n  "context": {\n    "pick": [\n      {\n        "guard": { "$read": "condition-flag" },\n        "context": {\n          "variables": [\n            { "name": "result", "type": { ... }, "pointer": { ... } }\n          ]\n        }\n      },\n      {\n        "context": {\n          "variables": []\n        }\n      }\n    ]\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"The debugger evaluates guards at runtime and uses the first matching context.\nA context without a guard acts as the default."}),"\n",(0,s.jsx)(n.h3,{id:"remark",children:"Remark"}),"\n",(0,s.jsx)(n.p,{children:"Add metadata without affecting scope:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "offset": 180,\n  "context": {\n    "remark": "loop iteration boundary"\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"instruction-ordering",children:"Instruction ordering"}),"\n",(0,s.jsx)(n.p,{children:"Instructions must be listed in bytecode order, matching the sequence of\nopcodes. The list is indexed by offset, so debuggers can quickly find the\ninstruction for any program counter value."}),"\n",(0,s.jsx)(n.p,{children:"Not every byte offset needs an instruction\u2014only positions where opcodes begin.\nPush data, for instance, doesn't get its own instruction entry."}),"\n",(0,s.jsx)(n.h2,{id:"learn-more",children:"Learn more"}),"\n",(0,s.jsx)(n.p,{children:"For complete schemas, see:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/spec/program/instruction",children:"Instruction schema"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/spec/program/context",children:"Context schema"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);