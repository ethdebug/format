"use strict";(globalThis.webpackChunk_ethdebug_format_web=globalThis.webpackChunk_ethdebug_format_web||[]).push([[588],{792(e,n,s){s.d(n,{A:()=>d});s(14041);var r=s(40665);const t="container_Hrln",i="link_y57m",o="label_feh8",l="schema_kJnE",a="arrow_YbSg";var c=s(31085);function d({schema:e,href:n}){return(0,c.jsx)("div",{className:t,children:(0,c.jsxs)(r.A,{to:n,className:i,children:[(0,c.jsx)("span",{className:o,children:"Schema:"}),(0,c.jsx)("span",{className:l,children:e}),(0,c.jsx)("span",{className:a,children:"\u2192"})]})})}},75267(e,n,s){s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"concepts/pointers","title":"Pointers","description":"This page explains the mental model behind ethdebug/format pointer","source":"@site/docs/concepts/pointers.mdx","sourceDirName":"concepts","slug":"/concepts/pointers","permalink":"/format/pr-preview/pr-168/docs/concepts/pointers","draft":false,"unlisted":false,"editUrl":"https://github.com/ethdebug/format/tree/main/packages/web/docs/concepts/pointers.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"Types","permalink":"/format/pr-preview/pr-168/docs/concepts/types"},"next":{"title":"Programs","permalink":"/format/pr-preview/pr-168/docs/concepts/programs"}}');var t=s(31085),i=s(71184),o=s(792),l=s(87270);const a={sidebar_position:4},c="Pointers",d={},h=[{value:"Pointers are recipes for finding bytes",id:"pointers-are-recipes-for-finding-bytes",level:2},{value:"EVM data locations",id:"evm-data-locations",level:2},{value:"Storage",id:"storage",level:3},{value:"Memory",id:"memory",level:3},{value:"Stack",id:"stack",level:3},{value:"Calldata",id:"calldata",level:3},{value:"Returndata",id:"returndata",level:3},{value:"Code",id:"code",level:3},{value:"Transient storage",id:"transient-storage",level:3},{value:"Summary",id:"summary",level:3},{value:"A pointer is a region or a collection",id:"a-pointer-is-a-region-or-a-collection",level:2},{value:"Regions",id:"regions",level:3},{value:"Collections",id:"collections",level:3},{value:"Expressions enable dynamic computation",id:"expressions-enable-dynamic-computation",level:2},{value:"Addressing schemes",id:"addressing-schemes",level:2},{value:"Named regions enable composition",id:"named-regions-enable-composition",level:2},{value:"Next steps",id:"next-steps",level:2}];function x(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"pointers",children:"Pointers"})}),"\n",(0,t.jsx)(o.A,{schema:"ethdebug/format/pointer",href:"/spec/pointer/overview"}),"\n",(0,t.jsxs)(n.p,{children:["This page explains the mental model behind ",(0,t.jsx)(n.strong,{children:"ethdebug/format"})," pointer\nrepresentations. For reference documentation on regions, expressions, and\ncollections, see the ",(0,t.jsx)(n.a,{href:"/docs/core-schemas/pointers",children:"Pointers reference"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"pointers-are-recipes-for-finding-bytes",children:"Pointers are recipes for finding bytes"}),"\n",(0,t.jsxs)(n.p,{children:["A pointer describes ",(0,t.jsx)(n.strong,{children:"where"})," data lives, not what it means. It's a recipe that\na debugger can follow to locate bytes in EVM state."]}),"\n",(0,t.jsx)(n.p,{children:"Simple pointers specify static locations:"}),"\n",(0,t.jsx)(l.A,{schema:"pointer/region/storage",href:"/spec/pointer/region/location/storage",children:'{\n  "location": "storage",\n  "slot": "0x0"\n}'}),"\n",(0,t.jsx)(n.p,{children:'This says "the data is in storage slot 0." The debugger can resolve this\ndirectly against the EVM state.'}),"\n",(0,t.jsx)(n.p,{children:"Complex pointers describe dynamic locations that depend on runtime values:"}),"\n",(0,t.jsx)(l.A,{schema:"pointer/region/storage",href:"/spec/pointer/region/location/storage",title:"Dynamic storage slot",children:'{\n  "location": "storage",\n  "slot": {\n    "$keccak256": [{ "$read": "key-value" }, { "$wordsized": 3 }]\n  }\n}'}),"\n",(0,t.jsx)(n.p,{children:'This says "compute the slot by hashing a runtime value with the number 3." The\ndebugger must evaluate this expression against the current machine state.'}),"\n",(0,t.jsx)(n.p,{children:"Pointers are self-contained \u2014 they include everything needed to resolve the\nlocation."}),"\n",(0,t.jsx)(n.h2,{id:"evm-data-locations",children:"EVM data locations"}),"\n",(0,t.jsx)(n.p,{children:"The EVM stores data in several distinct locations. Understanding these is\nessential for working with pointers."}),"\n",(0,t.jsx)(n.h3,{id:"storage",children:"Storage"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Storage"})," is persistent data associated with a contract. It survives\ntransaction boundaries and is where contracts store their state."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Persistent"})," \u2014 values remain until explicitly changed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Slot-based"})," \u2014 organized into 32-byte slots numbered from 0"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Contract-specific"})," \u2014 each contract has its own storage space"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Storage is where you find contract state variables, mapping contents, and\ndynamic array contents."}),"\n",(0,t.jsx)(n.h3,{id:"memory",children:"Memory"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Memory"})," is temporary data that exists only during execution. It's cleared\nbetween calls."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Temporary"})," \u2014 cleared after each external call returns"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Byte-addressable"})," \u2014 accessed by byte offset, not slots"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Linear"})," \u2014 grows as needed from offset 0"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Memory holds function arguments, return data being prepared, and temporary\nvalues."}),"\n",(0,t.jsx)(n.h3,{id:"stack",children:"Stack"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"The stack"})," is where the EVM performs computations. It holds operands and\nintermediate results."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"256-bit words"})," \u2014 each stack item is 32 bytes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Limited depth"})," \u2014 maximum 1024 items"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"LIFO"})," \u2014 last in, first out access pattern"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The stack contains function arguments (for internal calls), local variables,\nand intermediate computation results."}),"\n",(0,t.jsx)(n.h3,{id:"calldata",children:"Calldata"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Calldata"})," is the read-only input data sent to a contract when called."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Read-only"})," \u2014 cannot be modified during execution"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Byte-addressable"})," \u2014 accessed by byte offset"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cheap to read"})," \u2014 cheaper than memory or storage reads"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Calldata contains the function selector (first 4 bytes) and ABI-encoded\nfunction arguments."}),"\n",(0,t.jsx)(n.h3,{id:"returndata",children:"Returndata"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Returndata"})," is the output from the most recent external call."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Read-only"})," \u2014 set by called contract, read by caller"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Replaced on each call"})," \u2014 each external call overwrites previous returndata"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Byte-addressable"})," \u2014 accessed by byte offset"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"code",children:"Code"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Code"})," refers to the contract's bytecode itself. Sometimes data is embedded\nin bytecode."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Immutable"})," \u2014 cannot change after deployment"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Byte-addressable"})," \u2014 accessed by byte offset"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Code is where you find immutable variables and embedded constants."}),"\n",(0,t.jsx)(n.h3,{id:"transient-storage",children:"Transient storage"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Transient storage"})," (EIP-1153) is storage that persists within a transaction\nbut is cleared afterward."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Transaction-scoped"})," \u2014 persists across calls within a transaction"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cleared after transaction"})," \u2014 does not persist to the next transaction"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Slot-based"})," \u2014 like storage, organized into 32-byte slots"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"summary",children:"Summary"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Location"}),(0,t.jsx)(n.th,{children:"Persistence"}),(0,t.jsx)(n.th,{children:"Addressing"}),(0,t.jsx)(n.th,{children:"Primary use"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Storage"}),(0,t.jsx)(n.td,{children:"Permanent"}),(0,t.jsx)(n.td,{children:"32-byte slots"}),(0,t.jsx)(n.td,{children:"Contract state"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Memory"}),(0,t.jsx)(n.td,{children:"Single call"}),(0,t.jsx)(n.td,{children:"Byte offset"}),(0,t.jsx)(n.td,{children:"Temporary data"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Stack"}),(0,t.jsx)(n.td,{children:"Instruction-level"}),(0,t.jsx)(n.td,{children:"Position index"}),(0,t.jsx)(n.td,{children:"Computation"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Calldata"}),(0,t.jsx)(n.td,{children:"Single call"}),(0,t.jsx)(n.td,{children:"Byte offset"}),(0,t.jsx)(n.td,{children:"Input parameters"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Returndata"}),(0,t.jsx)(n.td,{children:"Until next call"}),(0,t.jsx)(n.td,{children:"Byte offset"}),(0,t.jsx)(n.td,{children:"Call results"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Code"}),(0,t.jsx)(n.td,{children:"Permanent"}),(0,t.jsx)(n.td,{children:"Byte offset"}),(0,t.jsx)(n.td,{children:"Bytecode/immutables"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Transient"}),(0,t.jsx)(n.td,{children:"Single transaction"}),(0,t.jsx)(n.td,{children:"32-byte slots"}),(0,t.jsx)(n.td,{children:"Tx-scoped state"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"a-pointer-is-a-region-or-a-collection",children:"A pointer is a region or a collection"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:"ethdebug/format/pointer"})," schema is recursive: a pointer is either a\n",(0,t.jsx)(n.strong,{children:"region"})," (a single continuous byte range) or a ",(0,t.jsx)(n.strong,{children:"collection"})," (an\naggregation of other pointers)."]}),"\n",(0,t.jsx)(n.h3,{id:"regions",children:"Regions"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.strong,{children:"region"})," represents a single continuous range of bytes at a specific\nlocation. Different locations use different region schemas:"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Slice-based regions"})," (memory, calldata, returndata, code) specify an offset\nand length:"]}),"\n",(0,t.jsx)(l.A,{schema:"pointer/region/memory",href:"/spec/pointer/region/location/memory",children:'{\n  "location": "memory",\n  "offset": "0x80",\n  "length": 32\n}'}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Segment-based regions"})," (storage, stack, transient) specify a slot, with\noptional offset and length for packed values:"]}),"\n",(0,t.jsx)(l.A,{schema:"pointer/region/storage",href:"/spec/pointer/region/location/storage",title:"Packed storage value",children:'{\n  "location": "storage",\n  "slot": 5,\n  "offset": 0,\n  "length": 16\n}'}),"\n",(0,t.jsxs)(n.p,{children:["Regions can be ",(0,t.jsx)(n.strong,{children:"named"})," for reference elsewhere in the pointer:"]}),"\n",(0,t.jsx)(l.A,{schema:"pointer/region/storage",href:"/spec/pointer/region/location/storage",title:"Named region",children:'{\n  "name": "array-length",\n  "location": "storage",\n  "slot": 0\n}'}),"\n",(0,t.jsx)(n.h3,{id:"collections",children:"Collections"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.strong,{children:"collection"})," aggregates multiple pointers. Six collection types exist\nfor different purposes:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"group"})," \u2014 combine pointers statically (e.g., struct members)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"list"})," \u2014 generate a sequence of pointers (e.g., array elements)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"conditional"})," \u2014 choose between pointers based on a runtime condition"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"scope"})," \u2014 define variables for use in nested pointers"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"reference"})," \u2014 refer to a previously defined template"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"templates"})," \u2014 define reusable pointer patterns with expected variables"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"expressions-enable-dynamic-computation",children:"Expressions enable dynamic computation"}),"\n",(0,t.jsx)(n.p,{children:"Static offsets and slots aren't enough for real-world data. Array elements,\nmapping values, and many other locations depend on runtime values."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Expressions"})," let pointers compute addresses dynamically:"]}),"\n",(0,t.jsx)(l.A,{schema:"pointer/expression",href:"/spec/pointer/expression",title:"Dynamic slot computation",children:'{\n  "location": "storage",\n  "slot": {\n    "$sum": [{ "$keccak256": [{ "$wordsized": 5 }] }, "element-index"]\n  }\n}'}),"\n",(0,t.jsx)(n.p,{children:"Expressions support:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Arithmetic"}),": ",(0,t.jsx)(n.code,{children:"$sum"}),", ",(0,t.jsx)(n.code,{children:"$difference"}),", ",(0,t.jsx)(n.code,{children:"$product"}),", ",(0,t.jsx)(n.code,{children:"$quotient"}),", ",(0,t.jsx)(n.code,{children:"$remainder"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reading values"}),": ",(0,t.jsx)(n.code,{children:"$read"})," retrieves bytes from a named region"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Region properties"}),": ",(0,t.jsx)(n.code,{children:".offset"}),", ",(0,t.jsx)(n.code,{children:".length"}),", ",(0,t.jsx)(n.code,{children:".slot"})," reference region fields"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Hashing"}),": ",(0,t.jsx)(n.code,{children:"$keccak256"})," computes storage slots for dynamic data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data manipulation"}),": ",(0,t.jsx)(n.code,{children:"$concat"}),", ",(0,t.jsx)(n.code,{children:"$sized<N>"}),", ",(0,t.jsx)(n.code,{children:"$wordsized"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Variables in expressions come from list iteration (",(0,t.jsx)(n.code,{children:"each"}),") or scope definitions\n(",(0,t.jsx)(n.code,{children:"define"}),")."]}),"\n",(0,t.jsx)(n.h2,{id:"addressing-schemes",children:"Addressing schemes"}),"\n",(0,t.jsx)(n.p,{children:"Regions use one of two addressing schemes based on their location:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Slice-based addressing"})," (memory, calldata, returndata, code):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"offset"})," \u2014 byte position from the start"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"length"})," \u2014 number of bytes"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Segment-based addressing"})," (storage, stack, transient):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"slot"})," \u2014 256-bit slot number"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"offset"})," (optional) \u2014 byte offset within the slot for packed values"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"length"})," (optional) \u2014 number of bytes for packed values"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"named-regions-enable-composition",children:"Named regions enable composition"}),"\n",(0,t.jsxs)(n.p,{children:["Giving a region a ",(0,t.jsx)(n.code,{children:"name"})," lets you reference it elsewhere:"]}),"\n",(0,t.jsx)(l.A,{schema:"pointer/collection/group",href:"/spec/pointer/collection/group",title:"Reading pointer from stack",children:'{\n  "group": [\n    {\n      "name": "base-pointer",\n      "location": "stack",\n      "slot": 0\n    },\n    {\n      "location": "memory",\n      "offset": { "$read": "base-pointer" },\n      "length": 32\n    }\n  ]\n}'}),"\n",(0,t.jsx)(n.p,{children:"The second region's offset comes from reading the value in the first region.\nThis pattern is essential for describing data whose location is stored in\nanother location (like memory pointers on the stack)."}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/core-schemas/pointers/regions",children:"Regions"})})," \u2014 Reference for all region types"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/core-schemas/pointers/expressions",children:"Expressions"})})," \u2014 Reference for expression\nsyntax"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/core-schemas/pointers/collections",children:"Collections"})})," \u2014 Reference for collection\ntypes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/spec/pointer",children:"Pointer specification"})})," \u2014 Formal schema definitions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/reference/challenges",children:"Challenges"})})," \u2014 Why EVM data\nlocations are complex enough to need this"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(x,{...e})}):x(e)}},87270(e,n,s){s.d(n,{A:()=>p});s(14041);var r=s(40665),t=s(54034),i=s.n(t);const o="container_eo8G",l="header_CGit",a="title_NhXp",c="schemaLink_R3qF",d="schemaName_hPpq",h="schemaLabel_TlZH";var x=s(31085);function p({schema:e,href:n,children:s,title:t}){const p="string"==typeof s?s:JSON.stringify(s,null,2),j=e.startsWith("ethdebug/format/")?e:`ethdebug/format/${e}`;return(0,x.jsxs)("div",{className:o,children:[(0,x.jsxs)("div",{className:l,children:[t&&(0,x.jsx)("span",{className:a,children:t}),(0,x.jsxs)(r.A,{to:n,className:c,children:[(0,x.jsx)("span",{className:h,children:"Schema:"}),(0,x.jsx)("span",{className:d,children:j})]})]}),(0,x.jsx)(i(),{language:"json",children:p})]})}}}]);