(globalThis.webpackChunk_ethdebug_format_web=globalThis.webpackChunk_ethdebug_format_web||[]).push([[2076],{11431(e,t){function n(e){let t,n=[];for(let s of e.split(",").map((e=>e.trim())))if(/^-?\d+$/.test(s))n.push(parseInt(s,10));else if(t=s.match(/^(-?\d+)(-|\.\.\.?|\u2025|\u2026|\u22EF)(-?\d+)$/)){let[e,s,i,o]=t;if(s&&o){s=parseInt(s),o=parseInt(o);const e=s<o?1:-1;"-"!==i&&".."!==i&&"\u2025"!==i||(o+=e);for(let t=s;t!==o;t+=e)n.push(t)}}return n}t.default=n,e.exports=n},31917(e,t,n){"use strict";n.d(t,{t8:()=>In,gm:()=>Kn,BP:()=>Wn,hZ:()=>Nn,jo:()=>On});var s={};n.r(s),n.d(s,{isComplex:()=>Ln,isElementary:()=>_n,isType:()=>Cn,isWrapper:()=>qn});const i=Symbol.for("yaml.alias"),o=Symbol.for("yaml.document"),r=Symbol.for("yaml.map"),a=Symbol.for("yaml.pair"),c=Symbol.for("yaml.scalar"),l=Symbol.for("yaml.seq"),p=Symbol.for("yaml.node.type"),d=e=>!!e&&"object"==typeof e&&e[p]===i,f=e=>!!e&&"object"==typeof e&&e[p]===o,h=e=>!!e&&"object"==typeof e&&e[p]===r,u=e=>!!e&&"object"==typeof e&&e[p]===a,m=e=>!!e&&"object"==typeof e&&e[p]===c,g=e=>!!e&&"object"==typeof e&&e[p]===l;function y(e){if(e&&"object"==typeof e)switch(e[p]){case r:case l:return!0}return!1}function b(e){if(e&&"object"==typeof e)switch(e[p]){case i:case r:case c:case l:return!0}return!1}const v=e=>(m(e)||y(e))&&!!e.anchor,k=Symbol("break visit"),w=Symbol("skip children"),x=Symbol("remove node");function $(e,t){const n=N(t);if(f(e)){j(null,e.contents,n,Object.freeze([e]))===x&&(e.contents=null)}else j(null,e,n,Object.freeze([]))}function j(e,t,n,s){const i=E(e,t,n,s);if(b(i)||u(i))return O(e,s,i),j(e,i,n,s);if("symbol"!=typeof i)if(y(t)){s=Object.freeze(s.concat(t));for(let e=0;e<t.items.length;++e){const i=j(e,t.items[e],n,s);if("number"==typeof i)e=i-1;else{if(i===k)return k;i===x&&(t.items.splice(e,1),e-=1)}}}else if(u(t)){s=Object.freeze(s.concat(t));const e=j("key",t.key,n,s);if(e===k)return k;e===x&&(t.key=null);const i=j("value",t.value,n,s);if(i===k)return k;i===x&&(t.value=null)}return i}async function S(e,t){const n=N(t);if(f(e)){await A(null,e.contents,n,Object.freeze([e]))===x&&(e.contents=null)}else await A(null,e,n,Object.freeze([]))}async function A(e,t,n,s){const i=await E(e,t,n,s);if(b(i)||u(i))return O(e,s,i),A(e,i,n,s);if("symbol"!=typeof i)if(y(t)){s=Object.freeze(s.concat(t));for(let e=0;e<t.items.length;++e){const i=await A(e,t.items[e],n,s);if("number"==typeof i)e=i-1;else{if(i===k)return k;i===x&&(t.items.splice(e,1),e-=1)}}}else if(u(t)){s=Object.freeze(s.concat(t));const e=await A("key",t.key,n,s);if(e===k)return k;e===x&&(t.key=null);const i=await A("value",t.value,n,s);if(i===k)return k;i===x&&(t.value=null)}return i}function N(e){return"object"==typeof e&&(e.Collection||e.Node||e.Value)?Object.assign({Alias:e.Node,Map:e.Node,Scalar:e.Node,Seq:e.Node},e.Value&&{Map:e.Value,Scalar:e.Value,Seq:e.Value},e.Collection&&{Map:e.Collection,Seq:e.Collection},e):e}function E(e,t,n,s){return"function"==typeof n?n(e,t,s):h(t)?n.Map?.(e,t,s):g(t)?n.Seq?.(e,t,s):u(t)?n.Pair?.(e,t,s):m(t)?n.Scalar?.(e,t,s):d(t)?n.Alias?.(e,t,s):void 0}function O(e,t,n){const s=t[t.length-1];if(y(s))s.items[e]=n;else if(u(s))"key"===e?s.key=n:s.value=n;else{if(!f(s)){const e=d(s)?"alias":"scalar";throw new Error(`Cannot replace node with ${e} parent`)}s.contents=n}}$.BREAK=k,$.SKIP=w,$.REMOVE=x,S.BREAK=k,S.SKIP=w,S.REMOVE=x;const T={"!":"%21",",":"%2C","[":"%5B","]":"%5D","{":"%7B","}":"%7D"};class I{constructor(e,t){this.docStart=null,this.docEnd=!1,this.yaml=Object.assign({},I.defaultYaml,e),this.tags=Object.assign({},I.defaultTags,t)}clone(){const e=new I(this.yaml,this.tags);return e.docStart=this.docStart,e}atDocument(){const e=new I(this.yaml,this.tags);switch(this.yaml.version){case"1.1":this.atNextDocument=!0;break;case"1.2":this.atNextDocument=!1,this.yaml={explicit:I.defaultYaml.explicit,version:"1.2"},this.tags=Object.assign({},I.defaultTags)}return e}add(e,t){this.atNextDocument&&(this.yaml={explicit:I.defaultYaml.explicit,version:"1.1"},this.tags=Object.assign({},I.defaultTags),this.atNextDocument=!1);const n=e.trim().split(/[ \t]+/),s=n.shift();switch(s){case"%TAG":{if(2!==n.length&&(t(0,"%TAG directive should contain exactly two parts"),n.length<2))return!1;const[e,s]=n;return this.tags[e]=s,!0}case"%YAML":{if(this.yaml.explicit=!0,1!==n.length)return t(0,"%YAML directive should contain exactly one part"),!1;const[e]=n;if("1.1"===e||"1.2"===e)return this.yaml.version=e,!0;return t(6,`Unsupported YAML version ${e}`,/^\d+\.\d+$/.test(e)),!1}default:return t(0,`Unknown directive ${s}`,!0),!1}}tagName(e,t){if("!"===e)return"!";if("!"!==e[0])return t(`Not a valid tag: ${e}`),null;if("<"===e[1]){const n=e.slice(2,-1);return"!"===n||"!!"===n?(t(`Verbatim tags aren't resolved, so ${e} is invalid.`),null):(">"!==e[e.length-1]&&t("Verbatim tags must end with a >"),n)}const[,n,s]=e.match(/^(.*!)([^!]*)$/s);s||t(`The ${e} tag has no suffix`);const i=this.tags[n];if(i)try{return i+decodeURIComponent(s)}catch(o){return t(String(o)),null}return"!"===n?e:(t(`Could not resolve tag: ${e}`),null)}tagString(e){for(const[t,n]of Object.entries(this.tags))if(e.startsWith(n))return t+e.substring(n.length).replace(/[!,[\]{}]/g,(e=>T[e]));return"!"===e[0]?e:`!<${e}>`}toString(e){const t=this.yaml.explicit?[`%YAML ${this.yaml.version||"1.2"}`]:[],n=Object.entries(this.tags);let s;if(e&&n.length>0&&b(e.contents)){const t={};$(e.contents,((e,n)=>{b(n)&&n.tag&&(t[n.tag]=!0)})),s=Object.keys(t)}else s=[];for(const[i,o]of n)"!!"===i&&"tag:yaml.org,2002:"===o||e&&!s.some((e=>e.startsWith(o)))||t.push(`%TAG ${i} ${o}`);return t.join("\n")}}function C(e){if(/[\x00-\x19\s,[\]{}]/.test(e)){const t=JSON.stringify(e);throw new Error(`Anchor must not contain whitespace or control characters: ${t}`)}return!0}function _(e){const t=new Set;return $(e,{Value(e,n){n.anchor&&t.add(n.anchor)}}),t}function L(e,t){for(let n=1;;++n){const s=`${e}${n}`;if(!t.has(s))return s}}function q(e,t,n,s){if(s&&"object"==typeof s)if(Array.isArray(s))for(let i=0,o=s.length;i<o;++i){const t=s[i],n=q(e,s,String(i),t);void 0===n?delete s[i]:n!==t&&(s[i]=n)}else if(s instanceof Map)for(const i of Array.from(s.keys())){const t=s.get(i),n=q(e,s,i,t);void 0===n?s.delete(i):n!==t&&s.set(i,n)}else if(s instanceof Set)for(const i of Array.from(s)){const t=q(e,s,i,i);void 0===t?s.delete(i):t!==i&&(s.delete(i),s.add(t))}else for(const[i,o]of Object.entries(s)){const t=q(e,s,i,o);void 0===t?delete s[i]:t!==o&&(s[i]=t)}return e.call(t,n,s)}function B(e,t,n){if(Array.isArray(e))return e.map(((e,t)=>B(e,String(t),n)));if(e&&"function"==typeof e.toJSON){if(!n||!v(e))return e.toJSON(t,n);const s={aliasCount:0,count:1,res:void 0};n.anchors.set(e,s),n.onCreate=e=>{s.res=e,delete n.onCreate};const i=e.toJSON(t,n);return n.onCreate&&n.onCreate(i),i}return"bigint"!=typeof e||n?.keep?e:Number(e)}I.defaultYaml={explicit:!1,version:"1.2"},I.defaultTags={"!!":"tag:yaml.org,2002:"};class P{constructor(e){Object.defineProperty(this,p,{value:e})}clone(){const e=Object.create(Object.getPrototypeOf(this),Object.getOwnPropertyDescriptors(this));return this.range&&(e.range=this.range.slice()),e}toJS(e,{mapAsMap:t,maxAliasCount:n,onAnchor:s,reviver:i}={}){if(!f(e))throw new TypeError("A document argument is required");const o={anchors:new Map,doc:e,keep:!0,mapAsMap:!0===t,mapKeyWarned:!1,maxAliasCount:"number"==typeof n?n:100},r=B(this,"",o);if("function"==typeof s)for(const{count:a,res:c}of o.anchors.values())s(c,a);return"function"==typeof i?q(i,{"":r},"",r):r}}class D extends P{constructor(e){super(i),this.source=e,Object.defineProperty(this,"tag",{set(){throw new Error("Alias nodes cannot have tags")}})}resolve(e,t){let n,s;t?.aliasResolveCache?n=t.aliasResolveCache:(n=[],$(e,{Node:(e,t)=>{(d(t)||v(t))&&n.push(t)}}),t&&(t.aliasResolveCache=n));for(const i of n){if(i===this)break;i.anchor===this.source&&(s=i)}return s}toJSON(e,t){if(!t)return{source:this.source};const{anchors:n,doc:s,maxAliasCount:i}=t,o=this.resolve(s,t);if(!o){const e=`Unresolved alias (the anchor must be set before the alias): ${this.source}`;throw new ReferenceError(e)}let r=n.get(o);if(r||(B(o,null,t),r=n.get(o)),void 0===r?.res){throw new ReferenceError("This should not happen: Alias anchor was not resolved?")}if(i>=0&&(r.count+=1,0===r.aliasCount&&(r.aliasCount=R(s,o,n)),r.count*r.aliasCount>i)){throw new ReferenceError("Excessive alias count indicates a resource exhaustion attack")}return r.res}toString(e,t,n){const s=`*${this.source}`;if(e){if(C(this.source),e.options.verifyAliasOrder&&!e.anchors.has(this.source)){const e=`Unresolved alias (the anchor must be set before the alias): ${this.source}`;throw new Error(e)}if(e.implicitKey)return`${s} `}return s}}function R(e,t,n){if(d(t)){const s=t.resolve(e),i=n&&s&&n.get(s);return i?i.count*i.aliasCount:0}if(y(t)){let s=0;for(const i of t.items){const t=R(e,i,n);t>s&&(s=t)}return s}if(u(t)){const s=R(e,t.key,n),i=R(e,t.value,n);return Math.max(s,i)}return 1}const M=e=>!e||"function"!=typeof e&&"object"!=typeof e;class K extends P{constructor(e){super(c),this.value=e}toJSON(e,t){return t?.keep?this.value:B(this.value,e,t)}toString(){return String(this.value)}}K.BLOCK_FOLDED="BLOCK_FOLDED",K.BLOCK_LITERAL="BLOCK_LITERAL",K.PLAIN="PLAIN",K.QUOTE_DOUBLE="QUOTE_DOUBLE",K.QUOTE_SINGLE="QUOTE_SINGLE";function U(e,t,n){if(f(e)&&(e=e.contents),b(e))return e;if(u(e)){const t=n.schema[r].createNode?.(n.schema,null,n);return t.items.push(e),t}(e instanceof String||e instanceof Number||e instanceof Boolean||"undefined"!=typeof BigInt&&e instanceof BigInt)&&(e=e.valueOf());const{aliasDuplicateObjects:s,onAnchor:i,onTagObj:o,schema:a,sourceObjects:c}=n;let p;if(s&&e&&"object"==typeof e){if(p=c.get(e),p)return p.anchor??(p.anchor=i(e)),new D(p.anchor);p={anchor:null,node:null},c.set(e,p)}t?.startsWith("!!")&&(t="tag:yaml.org,2002:"+t.slice(2));let d=function(e,t,n){if(t){const e=n.filter((e=>e.tag===t)),s=e.find((e=>!e.format))??e[0];if(!s)throw new Error(`Tag ${t} not found`);return s}return n.find((t=>t.identify?.(e)&&!t.format))}(e,t,a.tags);if(!d){if(e&&"function"==typeof e.toJSON&&(e=e.toJSON()),!e||"object"!=typeof e){const t=new K(e);return p&&(p.node=t),t}d=e instanceof Map?a[r]:Symbol.iterator in Object(e)?a[l]:a[r]}o&&(o(d),delete n.onTagObj);const h=d?.createNode?d.createNode(n.schema,e,n):"function"==typeof d?.nodeClass?.from?d.nodeClass.from(n.schema,e,n):new K(e);return t?h.tag=t:d.default||(h.tag=d.tag),p&&(p.node=h),h}function z(e,t,n){let s=n;for(let i=t.length-1;i>=0;--i){const e=t[i];if("number"==typeof e&&Number.isInteger(e)&&e>=0){const t=[];t[e]=s,s=t}else s=new Map([[e,s]])}return U(s,void 0,{aliasDuplicateObjects:!1,keepUndefined:!1,onAnchor:()=>{throw new Error("This should not happen, please report a bug.")},schema:e,sourceObjects:new Map})}const F=e=>null==e||"object"==typeof e&&!!e[Symbol.iterator]().next().done;class V extends P{constructor(e,t){super(e),Object.defineProperty(this,"schema",{value:t,configurable:!0,enumerable:!1,writable:!0})}clone(e){const t=Object.create(Object.getPrototypeOf(this),Object.getOwnPropertyDescriptors(this));return e&&(t.schema=e),t.items=t.items.map((t=>b(t)||u(t)?t.clone(e):t)),this.range&&(t.range=this.range.slice()),t}addIn(e,t){if(F(e))this.add(t);else{const[n,...s]=e,i=this.get(n,!0);if(y(i))i.addIn(s,t);else{if(void 0!==i||!this.schema)throw new Error(`Expected YAML collection at ${n}. Remaining path: ${s}`);this.set(n,z(this.schema,s,t))}}}deleteIn(e){const[t,...n]=e;if(0===n.length)return this.delete(t);const s=this.get(t,!0);if(y(s))return s.deleteIn(n);throw new Error(`Expected YAML collection at ${t}. Remaining path: ${n}`)}getIn(e,t){const[n,...s]=e,i=this.get(n,!0);return 0===s.length?!t&&m(i)?i.value:i:y(i)?i.getIn(s,t):void 0}hasAllNullValues(e){return this.items.every((t=>{if(!u(t))return!1;const n=t.value;return null==n||e&&m(n)&&null==n.value&&!n.commentBefore&&!n.comment&&!n.tag}))}hasIn(e){const[t,...n]=e;if(0===n.length)return this.has(t);const s=this.get(t,!0);return!!y(s)&&s.hasIn(n)}setIn(e,t){const[n,...s]=e;if(0===s.length)this.set(n,t);else{const e=this.get(n,!0);if(y(e))e.setIn(s,t);else{if(void 0!==e||!this.schema)throw new Error(`Expected YAML collection at ${n}. Remaining path: ${s}`);this.set(n,z(this.schema,s,t))}}}}const W=e=>e.replace(/^(?!$)(?: $)?/gm,"#");function J(e,t){return/^\n+$/.test(e)?e.substring(1):t?e.replace(/^(?! *$)/gm,t):e}const H=(e,t,n)=>e.endsWith("\n")?J(n,t):n.includes("\n")?"\n"+J(n,t):(e.endsWith(" ")?"":" ")+n,G="flow",Y="block",Q="quoted";function X(e,t,n="flow",{indentAtStart:s,lineWidth:i=80,minContentWidth:o=20,onFold:r,onOverflow:a}={}){if(!i||i<0)return e;i<o&&(o=0);const c=Math.max(1+o,1+i-t.length);if(e.length<=c)return e;const l=[],p={};let d,f,h=i-t.length;"number"==typeof s&&(s>i-Math.max(2,o)?l.push(0):h=i-s);let u=!1,m=-1,g=-1,y=-1;n===Y&&(m=Z(e,m,t.length),-1!==m&&(h=m+c));for(let v;v=e[m+=1];){if(n===Q&&"\\"===v){switch(g=m,e[m+1]){case"x":m+=3;break;case"u":m+=5;break;case"U":m+=9;break;default:m+=1}y=m}if("\n"===v)n===Y&&(m=Z(e,m,t.length)),h=m+t.length+c,d=void 0;else{if(" "===v&&f&&" "!==f&&"\n"!==f&&"\t"!==f){const t=e[m+1];t&&" "!==t&&"\n"!==t&&"\t"!==t&&(d=m)}if(m>=h)if(d)l.push(d),h=d+c,d=void 0;else if(n===Q){for(;" "===f||"\t"===f;)f=v,v=e[m+=1],u=!0;const t=m>y+1?m-2:g-1;if(p[t])return e;l.push(t),p[t]=!0,h=t+c,d=void 0}else u=!0}f=v}if(u&&a&&a(),0===l.length)return e;r&&r();let b=e.slice(0,l[0]);for(let v=0;v<l.length;++v){const s=l[v],i=l[v+1]||e.length;0===s?b=`\n${t}${e.slice(0,i)}`:(n===Q&&p[s]&&(b+=`${e[s]}\\`),b+=`\n${t}${e.slice(s+1,i)}`)}return b}function Z(e,t,n){let s=t,i=t+1,o=e[i];for(;" "===o||"\t"===o;)if(t<i+n)o=e[++t];else{do{o=e[++t]}while(o&&"\n"!==o);s=t,i=t+1,o=e[i]}return s}const ee=(e,t)=>({indentAtStart:t?e.indent.length:e.indentAtStart,lineWidth:e.options.lineWidth,minContentWidth:e.options.minContentWidth}),te=e=>/^(%|---|\.\.\.)/m.test(e);function ne(e,t){const n=JSON.stringify(e);if(t.options.doubleQuotedAsJSON)return n;const{implicitKey:s}=t,i=t.options.doubleQuotedMinMultiLineLength,o=t.indent||(te(e)?"  ":"");let r="",a=0;for(let c=0,l=n[c];l;l=n[++c])if(" "===l&&"\\"===n[c+1]&&"n"===n[c+2]&&(r+=n.slice(a,c)+"\\ ",c+=1,a=c,l="\\"),"\\"===l)switch(n[c+1]){case"u":{r+=n.slice(a,c);const e=n.substr(c+2,4);switch(e){case"0000":r+="\\0";break;case"0007":r+="\\a";break;case"000b":r+="\\v";break;case"001b":r+="\\e";break;case"0085":r+="\\N";break;case"00a0":r+="\\_";break;case"2028":r+="\\L";break;case"2029":r+="\\P";break;default:"00"===e.substr(0,2)?r+="\\x"+e.substr(2):r+=n.substr(c,6)}c+=5,a=c+1}break;case"n":if(s||'"'===n[c+2]||n.length<i)c+=1;else{for(r+=n.slice(a,c)+"\n\n";"\\"===n[c+2]&&"n"===n[c+3]&&'"'!==n[c+4];)r+="\n",c+=2;r+=o," "===n[c+2]&&(r+="\\"),c+=1,a=c+1}break;default:c+=1}return r=a?r+n.slice(a):n,s?r:X(r,o,Q,ee(t,!1))}function se(e,t){if(!1===t.options.singleQuote||t.implicitKey&&e.includes("\n")||/[ \t]\n|\n[ \t]/.test(e))return ne(e,t);const n=t.indent||(te(e)?"  ":""),s="'"+e.replace(/'/g,"''").replace(/\n+/g,`$&\n${n}`)+"'";return t.implicitKey?s:X(s,n,G,ee(t,!1))}function ie(e,t){const{singleQuote:n}=t.options;let s;if(!1===n)s=ne;else{const t=e.includes('"'),i=e.includes("'");s=t&&!i?se:i&&!t?ne:n?se:ne}return s(e,t)}let oe;try{oe=new RegExp("(^|(?<!\n))\n+(?!\n|$)","g")}catch{oe=/\n+(?!\n|$)/g}function re({comment:e,type:t,value:n},s,i,o){const{blockQuote:r,commentString:a,lineWidth:c}=s.options;if(!r||/\n[\t ]+$/.test(n))return ie(n,s);const l=s.indent||(s.forceBlockIndent||te(n)?"  ":""),p="literal"===r||"folded"!==r&&t!==K.BLOCK_FOLDED&&(t===K.BLOCK_LITERAL||!function(e,t,n){if(!t||t<0)return!1;const s=t-n,i=e.length;if(i<=s)return!1;for(let o=0,r=0;o<i;++o)if("\n"===e[o]){if(o-r>s)return!0;if(r=o+1,i-r<=s)return!1}return!0}(n,c,l.length));if(!n)return p?"|\n":">\n";let d,f;for(f=n.length;f>0;--f){const e=n[f-1];if("\n"!==e&&"\t"!==e&&" "!==e)break}let h=n.substring(f);const u=h.indexOf("\n");-1===u?d="-":n===h||u!==h.length-1?(d="+",o&&o()):d="",h&&(n=n.slice(0,-h.length),"\n"===h[h.length-1]&&(h=h.slice(0,-1)),h=h.replace(oe,`$&${l}`));let m,g=!1,y=-1;for(m=0;m<n.length;++m){const e=n[m];if(" "===e)g=!0;else{if("\n"!==e)break;y=m}}let b=n.substring(0,y<m?y+1:m);b&&(n=n.substring(b.length),b=b.replace(/\n+/g,`$&${l}`));let v=(g?l?"2":"1":"")+d;if(e&&(v+=" "+a(e.replace(/ ?[\r\n]+/g," ")),i&&i()),!p){const e=n.replace(/\n+/g,"\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g,"$1$2").replace(/\n+/g,`$&${l}`);let i=!1;const o=ee(s,!0);"folded"!==r&&t!==K.BLOCK_FOLDED&&(o.onOverflow=()=>{i=!0});const a=X(`${b}${e}${h}`,l,Y,o);if(!i)return`>${v}\n${l}${a}`}return`|${v}\n${l}${b}${n=n.replace(/\n+/g,`$&${l}`)}${h}`}function ae(e,t,n,s){const{implicitKey:i,inFlow:o}=t,r="string"==typeof e.value?e:Object.assign({},e,{value:String(e.value)});let{type:a}=e;a!==K.QUOTE_DOUBLE&&/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(r.value)&&(a=K.QUOTE_DOUBLE);const c=e=>{switch(e){case K.BLOCK_FOLDED:case K.BLOCK_LITERAL:return i||o?ie(r.value,t):re(r,t,n,s);case K.QUOTE_DOUBLE:return ne(r.value,t);case K.QUOTE_SINGLE:return se(r.value,t);case K.PLAIN:return function(e,t,n,s){const{type:i,value:o}=e,{actualString:r,implicitKey:a,indent:c,indentStep:l,inFlow:p}=t;if(a&&o.includes("\n")||p&&/[[\]{},]/.test(o))return ie(o,t);if(/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(o))return a||p||!o.includes("\n")?ie(o,t):re(e,t,n,s);if(!a&&!p&&i!==K.PLAIN&&o.includes("\n"))return re(e,t,n,s);if(te(o)){if(""===c)return t.forceBlockIndent=!0,re(e,t,n,s);if(a&&c===l)return ie(o,t)}const d=o.replace(/\n+/g,`$&\n${c}`);if(r){const e=e=>e.default&&"tag:yaml.org,2002:str"!==e.tag&&e.test?.test(d),{compat:n,tags:s}=t.doc.schema;if(s.some(e)||n?.some(e))return ie(o,t)}return a?d:X(d,c,G,ee(t,!1))}(r,t,n,s);default:return null}};let l=c(a);if(null===l){const{defaultKeyType:e,defaultStringType:n}=t.options,s=i&&e||n;if(l=c(s),null===l)throw new Error(`Unsupported default string type ${s}`)}return l}function ce(e,t){const n=Object.assign({blockQuote:!0,commentString:W,defaultKeyType:null,defaultStringType:"PLAIN",directives:null,doubleQuotedAsJSON:!1,doubleQuotedMinMultiLineLength:40,falseStr:"false",flowCollectionPadding:!0,indentSeq:!0,lineWidth:80,minContentWidth:20,nullStr:"null",simpleKeys:!1,singleQuote:null,trueStr:"true",verifyAliasOrder:!0},e.schema.toStringOptions,t);let s;switch(n.collectionStyle){case"block":s=!1;break;case"flow":s=!0;break;default:s=null}return{anchors:new Set,doc:e,flowCollectionPadding:n.flowCollectionPadding?" ":"",indent:"",indentStep:"number"==typeof n.indent?" ".repeat(n.indent):"  ",inFlow:s,options:n}}function le(e,t,n,s){if(u(e))return e.toString(t,n,s);if(d(e)){if(t.doc.directives)return e.toString(t);if(t.resolvedAliases?.has(e))throw new TypeError("Cannot stringify circular structure without alias nodes");t.resolvedAliases?t.resolvedAliases.add(e):t.resolvedAliases=new Set([e]),e=e.resolve(t.doc)}let i;const o=b(e)?e:t.doc.createNode(e,{onTagObj:e=>i=e});i??(i=function(e,t){if(t.tag){const n=e.filter((e=>e.tag===t.tag));if(n.length>0)return n.find((e=>e.format===t.format))??n[0]}let n,s;if(m(t)){s=t.value;let i=e.filter((e=>e.identify?.(s)));if(i.length>1){const e=i.filter((e=>e.test));e.length>0&&(i=e)}n=i.find((e=>e.format===t.format))??i.find((e=>!e.format))}else s=t,n=e.find((e=>e.nodeClass&&s instanceof e.nodeClass));if(!n)throw new Error(`Tag not resolved for ${s?.constructor?.name??(null===s?"null":typeof s)} value`);return n}(t.doc.schema.tags,o));const r=function(e,t,{anchors:n,doc:s}){if(!s.directives)return"";const i=[],o=(m(e)||y(e))&&e.anchor;o&&C(o)&&(n.add(o),i.push(`&${o}`));const r=e.tag??(t.default?null:t.tag);return r&&i.push(s.directives.tagString(r)),i.join(" ")}(o,i,t);r.length>0&&(t.indentAtStart=(t.indentAtStart??0)+r.length+1);const a="function"==typeof i.stringify?i.stringify(o,t,n,s):m(o)?ae(o,t,n,s):o.toString(t,n,s);return r?m(o)||"{"===a[0]||"["===a[0]?`${r} ${a}`:`${r}\n${t.indent}${a}`:a}function pe(e,t){"debug"!==e&&"warn"!==e||console.warn(t)}const de="<<",fe={identify:e=>e===de||"symbol"==typeof e&&e.description===de,default:"key",tag:"tag:yaml.org,2002:merge",test:/^<<$/,resolve:()=>Object.assign(new K(Symbol(de)),{addToJSMap:he}),stringify:()=>de};function he(e,t,n){if(n=e&&d(n)?n.resolve(e.doc):n,g(n))for(const s of n.items)ue(e,t,s);else if(Array.isArray(n))for(const s of n)ue(e,t,s);else ue(e,t,n)}function ue(e,t,n){const s=e&&d(n)?n.resolve(e.doc):n;if(!h(s))throw new Error("Merge sources must be maps or map aliases");const i=s.toJSON(null,e,Map);for(const[o,r]of i)t instanceof Map?t.has(o)||t.set(o,r):t instanceof Set?t.add(o):Object.prototype.hasOwnProperty.call(t,o)||Object.defineProperty(t,o,{value:r,writable:!0,enumerable:!0,configurable:!0});return t}function me(e,t,{key:n,value:s}){if(b(n)&&n.addToJSMap)n.addToJSMap(e,t,s);else if(((e,t)=>(fe.identify(t)||m(t)&&(!t.type||t.type===K.PLAIN)&&fe.identify(t.value))&&e?.doc.schema.tags.some((e=>e.tag===fe.tag&&e.default)))(e,n))he(e,t,s);else{const i=B(n,"",e);if(t instanceof Map)t.set(i,B(s,i,e));else if(t instanceof Set)t.add(i);else{const o=function(e,t,n){if(null===t)return"";if("object"!=typeof t)return String(t);if(b(e)&&n?.doc){const t=ce(n.doc,{});t.anchors=new Set;for(const e of n.anchors.keys())t.anchors.add(e.anchor);t.inFlow=!0,t.inStringifyKey=!0;const s=e.toString(t);if(!n.mapKeyWarned){let e=JSON.stringify(s);e.length>40&&(e=e.substring(0,36)+'..."'),pe(n.doc.options.logLevel,`Keys with collection values will be stringified due to JS Object restrictions: ${e}. Set mapAsMap: true to use object keys.`),n.mapKeyWarned=!0}return s}return JSON.stringify(t)}(n,i,e),r=B(s,o,e);o in t?Object.defineProperty(t,o,{value:r,writable:!0,enumerable:!0,configurable:!0}):t[o]=r}}return t}function ge(e,t,n){const s=U(e,void 0,n),i=U(t,void 0,n);return new ye(s,i)}class ye{constructor(e,t=null){Object.defineProperty(this,p,{value:a}),this.key=e,this.value=t}clone(e){let{key:t,value:n}=this;return b(t)&&(t=t.clone(e)),b(n)&&(n=n.clone(e)),new ye(t,n)}toJSON(e,t){return me(t,t?.mapAsMap?new Map:{},this)}toString(e,t,n){return e?.doc?function({key:e,value:t},n,s,i){const{allNullValues:o,doc:r,indent:a,indentStep:c,options:{commentString:l,indentSeq:p,simpleKeys:d}}=n;let f=b(e)&&e.comment||null;if(d){if(f)throw new Error("With simple keys, key nodes cannot have comments");if(y(e)||!b(e)&&"object"==typeof e)throw new Error("With simple keys, collection cannot be used as a key value")}let h=!d&&(!e||f&&null==t&&!n.inFlow||y(e)||(m(e)?e.type===K.BLOCK_FOLDED||e.type===K.BLOCK_LITERAL:"object"==typeof e));n=Object.assign({},n,{allNullValues:!1,implicitKey:!h&&(d||!o),indent:a+c});let u,v,k,w=!1,x=!1,$=le(e,n,(()=>w=!0),(()=>x=!0));if(!h&&!n.inFlow&&$.length>1024){if(d)throw new Error("With simple keys, single line scalar must not span more than 1024 characters");h=!0}if(n.inFlow){if(o||null==t)return w&&s&&s(),""===$?"?":h?`? ${$}`:$}else if(o&&!d||null==t&&h)return $=`? ${$}`,f&&!w?$+=H($,n.indent,l(f)):x&&i&&i(),$;w&&(f=null),h?(f&&($+=H($,n.indent,l(f))),$=`? ${$}\n${a}:`):($=`${$}:`,f&&($+=H($,n.indent,l(f)))),b(t)?(u=!!t.spaceBefore,v=t.commentBefore,k=t.comment):(u=!1,v=null,k=null,t&&"object"==typeof t&&(t=r.createNode(t))),n.implicitKey=!1,h||f||!m(t)||(n.indentAtStart=$.length+1),x=!1,p||!(c.length>=2)||n.inFlow||h||!g(t)||t.flow||t.tag||t.anchor||(n.indent=n.indent.substring(2));let j=!1;const S=le(t,n,(()=>j=!0),(()=>x=!0));let A=" ";if(f||u||v)A=u?"\n":"",v&&(A+=`\n${J(l(v),n.indent)}`),""!==S||n.inFlow?A+=`\n${n.indent}`:"\n"===A&&k&&(A="\n\n");else if(!h&&y(t)){const e=S[0],s=S.indexOf("\n"),i=-1!==s,o=n.inFlow??t.flow??0===t.items.length;if(i||!o){let t=!1;if(i&&("&"===e||"!"===e)){let n=S.indexOf(" ");"&"===e&&-1!==n&&n<s&&"!"===S[n+1]&&(n=S.indexOf(" ",n+1)),(-1===n||s<n)&&(t=!0)}t||(A=`\n${n.indent}`)}}else""!==S&&"\n"!==S[0]||(A="");return $+=A+S,n.inFlow?j&&s&&s():k&&!j?$+=H($,n.indent,l(k)):x&&i&&i(),$}(this,e,t,n):JSON.stringify(this)}}function be(e,t,n){return(t.inFlow??e.flow?ke:ve)(e,t,n)}function ve({comment:e,items:t},n,{blockItemPrefix:s,flowChars:i,itemIndent:o,onChompKeep:r,onComment:a}){const{indent:c,options:{commentString:l}}=n,p=Object.assign({},n,{indent:o,type:null});let d=!1;const f=[];for(let m=0;m<t.length;++m){const e=t[m];let i=null;if(b(e))!d&&e.spaceBefore&&f.push(""),we(n,f,e.commentBefore,d),e.comment&&(i=e.comment);else if(u(e)){const t=b(e.key)?e.key:null;t&&(!d&&t.spaceBefore&&f.push(""),we(n,f,t.commentBefore,d))}d=!1;let r=le(e,p,(()=>i=null),(()=>d=!0));i&&(r+=H(r,o,l(i))),d&&i&&(d=!1),f.push(s+r)}let h;if(0===f.length)h=i.start+i.end;else{h=f[0];for(let e=1;e<f.length;++e){const t=f[e];h+=t?`\n${c}${t}`:"\n"}}return e?(h+="\n"+J(l(e),c),a&&a()):d&&r&&r(),h}function ke({items:e},t,{flowChars:n,itemIndent:s}){const{indent:i,indentStep:o,flowCollectionPadding:r,options:{commentString:a}}=t;s+=o;const c=Object.assign({},t,{indent:s,inFlow:!0,type:null});let l=!1,p=0;const d=[];for(let m=0;m<e.length;++m){const n=e[m];let i=null;if(b(n))n.spaceBefore&&d.push(""),we(t,d,n.commentBefore,!1),n.comment&&(i=n.comment);else if(u(n)){const e=b(n.key)?n.key:null;e&&(e.spaceBefore&&d.push(""),we(t,d,e.commentBefore,!1),e.comment&&(l=!0));const s=b(n.value)?n.value:null;s?(s.comment&&(i=s.comment),s.commentBefore&&(l=!0)):null==n.value&&e?.comment&&(i=e.comment)}i&&(l=!0);let o=le(n,c,(()=>i=null));m<e.length-1&&(o+=","),i&&(o+=H(o,s,a(i))),!l&&(d.length>p||o.includes("\n"))&&(l=!0),d.push(o),p=d.length}const{start:f,end:h}=n;if(0===d.length)return f+h;if(!l){const e=d.reduce(((e,t)=>e+t.length+2),2);l=t.options.lineWidth>0&&e>t.options.lineWidth}if(l){let e=f;for(const t of d)e+=t?`\n${o}${i}${t}`:"\n";return`${e}\n${i}${h}`}return`${f}${r}${d.join(" ")}${r}${h}`}function we({indent:e,options:{commentString:t}},n,s,i){if(s&&i&&(s=s.replace(/^\n+/,"")),s){const i=J(t(s),e);n.push(i.trimStart())}}function xe(e,t){const n=m(t)?t.value:t;for(const s of e)if(u(s)){if(s.key===t||s.key===n)return s;if(m(s.key)&&s.key.value===n)return s}}class $e extends V{static get tagName(){return"tag:yaml.org,2002:map"}constructor(e){super(r,e),this.items=[]}static from(e,t,n){const{keepUndefined:s,replacer:i}=n,o=new this(e),r=(e,r)=>{if("function"==typeof i)r=i.call(t,e,r);else if(Array.isArray(i)&&!i.includes(e))return;(void 0!==r||s)&&o.items.push(ge(e,r,n))};if(t instanceof Map)for(const[a,c]of t)r(a,c);else if(t&&"object"==typeof t)for(const a of Object.keys(t))r(a,t[a]);return"function"==typeof e.sortMapEntries&&o.items.sort(e.sortMapEntries),o}add(e,t){let n;n=u(e)?e:e&&"object"==typeof e&&"key"in e?new ye(e.key,e.value):new ye(e,e?.value);const s=xe(this.items,n.key),i=this.schema?.sortMapEntries;if(s){if(!t)throw new Error(`Key ${n.key} already set`);m(s.value)&&M(n.value)?s.value.value=n.value:s.value=n.value}else if(i){const e=this.items.findIndex((e=>i(n,e)<0));-1===e?this.items.push(n):this.items.splice(e,0,n)}else this.items.push(n)}delete(e){const t=xe(this.items,e);if(!t)return!1;return this.items.splice(this.items.indexOf(t),1).length>0}get(e,t){const n=xe(this.items,e),s=n?.value;return(!t&&m(s)?s.value:s)??void 0}has(e){return!!xe(this.items,e)}set(e,t){this.add(new ye(e,t),!0)}toJSON(e,t,n){const s=n?new n:t?.mapAsMap?new Map:{};t?.onCreate&&t.onCreate(s);for(const i of this.items)me(t,s,i);return s}toString(e,t,n){if(!e)return JSON.stringify(this);for(const s of this.items)if(!u(s))throw new Error(`Map items must all be pairs; found ${JSON.stringify(s)} instead`);return!e.allNullValues&&this.hasAllNullValues(!1)&&(e=Object.assign({},e,{allNullValues:!0})),be(this,e,{blockItemPrefix:"",flowChars:{start:"{",end:"}"},itemIndent:e.indent||"",onChompKeep:n,onComment:t})}}const je={collection:"map",default:!0,nodeClass:$e,tag:"tag:yaml.org,2002:map",resolve:(e,t)=>(h(e)||t("Expected a mapping for this tag"),e),createNode:(e,t,n)=>$e.from(e,t,n)};class Se extends V{static get tagName(){return"tag:yaml.org,2002:seq"}constructor(e){super(l,e),this.items=[]}add(e){this.items.push(e)}delete(e){const t=Ae(e);if("number"!=typeof t)return!1;return this.items.splice(t,1).length>0}get(e,t){const n=Ae(e);if("number"!=typeof n)return;const s=this.items[n];return!t&&m(s)?s.value:s}has(e){const t=Ae(e);return"number"==typeof t&&t<this.items.length}set(e,t){const n=Ae(e);if("number"!=typeof n)throw new Error(`Expected a valid index, not ${e}.`);const s=this.items[n];m(s)&&M(t)?s.value=t:this.items[n]=t}toJSON(e,t){const n=[];t?.onCreate&&t.onCreate(n);let s=0;for(const i of this.items)n.push(B(i,String(s++),t));return n}toString(e,t,n){return e?be(this,e,{blockItemPrefix:"- ",flowChars:{start:"[",end:"]"},itemIndent:(e.indent||"")+"  ",onChompKeep:n,onComment:t}):JSON.stringify(this)}static from(e,t,n){const{replacer:s}=n,i=new this(e);if(t&&Symbol.iterator in Object(t)){let e=0;for(let o of t){if("function"==typeof s){const n=t instanceof Set?o:String(e++);o=s.call(t,n,o)}i.items.push(U(o,void 0,n))}}return i}}function Ae(e){let t=m(e)?e.value:e;return t&&"string"==typeof t&&(t=Number(t)),"number"==typeof t&&Number.isInteger(t)&&t>=0?t:null}const Ne={collection:"seq",default:!0,nodeClass:Se,tag:"tag:yaml.org,2002:seq",resolve:(e,t)=>(g(e)||t("Expected a sequence for this tag"),e),createNode:(e,t,n)=>Se.from(e,t,n)},Ee={identify:e=>"string"==typeof e,default:!0,tag:"tag:yaml.org,2002:str",resolve:e=>e,stringify:(e,t,n,s)=>ae(e,t=Object.assign({actualString:!0},t),n,s)},Oe={identify:e=>null==e,createNode:()=>new K(null),default:!0,tag:"tag:yaml.org,2002:null",test:/^(?:~|[Nn]ull|NULL)?$/,resolve:()=>new K(null),stringify:({source:e},t)=>"string"==typeof e&&Oe.test.test(e)?e:t.options.nullStr},Te={identify:e=>"boolean"==typeof e,default:!0,tag:"tag:yaml.org,2002:bool",test:/^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,resolve:e=>new K("t"===e[0]||"T"===e[0]),stringify({source:e,value:t},n){if(e&&Te.test.test(e)){if(t===("t"===e[0]||"T"===e[0]))return e}return t?n.options.trueStr:n.options.falseStr}};function Ie({format:e,minFractionDigits:t,tag:n,value:s}){if("bigint"==typeof s)return String(s);const i="number"==typeof s?s:Number(s);if(!isFinite(i))return isNaN(i)?".nan":i<0?"-.inf":".inf";let o=Object.is(s,-0)?"-0":JSON.stringify(s);if(!e&&t&&(!n||"tag:yaml.org,2002:float"===n)&&/^\d/.test(o)){let e=o.indexOf(".");e<0&&(e=o.length,o+=".");let n=t-(o.length-e-1);for(;n-- >0;)o+="0"}return o}const Ce={identify:e=>"number"==typeof e,default:!0,tag:"tag:yaml.org,2002:float",test:/^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,resolve:e=>"nan"===e.slice(-3).toLowerCase()?NaN:"-"===e[0]?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,stringify:Ie},_e={identify:e=>"number"==typeof e,default:!0,tag:"tag:yaml.org,2002:float",format:"EXP",test:/^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,resolve:e=>parseFloat(e),stringify(e){const t=Number(e.value);return isFinite(t)?t.toExponential():Ie(e)}},Le={identify:e=>"number"==typeof e,default:!0,tag:"tag:yaml.org,2002:float",test:/^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,resolve(e){const t=new K(parseFloat(e)),n=e.indexOf(".");return-1!==n&&"0"===e[e.length-1]&&(t.minFractionDigits=e.length-n-1),t},stringify:Ie},qe=e=>"bigint"==typeof e||Number.isInteger(e),Be=(e,t,n,{intAsBigInt:s})=>s?BigInt(e):parseInt(e.substring(t),n);function Pe(e,t,n){const{value:s}=e;return qe(s)&&s>=0?n+s.toString(t):Ie(e)}const De={identify:e=>qe(e)&&e>=0,default:!0,tag:"tag:yaml.org,2002:int",format:"OCT",test:/^0o[0-7]+$/,resolve:(e,t,n)=>Be(e,2,8,n),stringify:e=>Pe(e,8,"0o")},Re={identify:qe,default:!0,tag:"tag:yaml.org,2002:int",test:/^[-+]?[0-9]+$/,resolve:(e,t,n)=>Be(e,0,10,n),stringify:Ie},Me={identify:e=>qe(e)&&e>=0,default:!0,tag:"tag:yaml.org,2002:int",format:"HEX",test:/^0x[0-9a-fA-F]+$/,resolve:(e,t,n)=>Be(e,2,16,n),stringify:e=>Pe(e,16,"0x")},Ke=[je,Ne,Ee,Oe,Te,De,Re,Me,Ce,_e,Le];function Ue(e){return"bigint"==typeof e||Number.isInteger(e)}const ze=({value:e})=>JSON.stringify(e),Fe=[je,Ne].concat([{identify:e=>"string"==typeof e,default:!0,tag:"tag:yaml.org,2002:str",resolve:e=>e,stringify:ze},{identify:e=>null==e,createNode:()=>new K(null),default:!0,tag:"tag:yaml.org,2002:null",test:/^null$/,resolve:()=>null,stringify:ze},{identify:e=>"boolean"==typeof e,default:!0,tag:"tag:yaml.org,2002:bool",test:/^true$|^false$/,resolve:e=>"true"===e,stringify:ze},{identify:Ue,default:!0,tag:"tag:yaml.org,2002:int",test:/^-?(?:0|[1-9][0-9]*)$/,resolve:(e,t,{intAsBigInt:n})=>n?BigInt(e):parseInt(e,10),stringify:({value:e})=>Ue(e)?e.toString():JSON.stringify(e)},{identify:e=>"number"==typeof e,default:!0,tag:"tag:yaml.org,2002:float",test:/^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,resolve:e=>parseFloat(e),stringify:ze}],{default:!0,tag:"",test:/^/,resolve:(e,t)=>(t(`Unresolved plain scalar ${JSON.stringify(e)}`),e)}),Ve={identify:e=>e instanceof Uint8Array,default:!1,tag:"tag:yaml.org,2002:binary",resolve(e,t){if("function"==typeof atob){const t=atob(e.replace(/[\n\r]/g,"")),n=new Uint8Array(t.length);for(let e=0;e<t.length;++e)n[e]=t.charCodeAt(e);return n}return t("This environment does not support reading binary tags; either Buffer or atob is required"),e},stringify({comment:e,type:t,value:n},s,i,o){if(!n)return"";const r=n;let a;if("function"!=typeof btoa)throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");{let e="";for(let t=0;t<r.length;++t)e+=String.fromCharCode(r[t]);a=btoa(e)}if(t??(t=K.BLOCK_LITERAL),t!==K.QUOTE_DOUBLE){const e=Math.max(s.options.lineWidth-s.indent.length,s.options.minContentWidth),n=Math.ceil(a.length/e),i=new Array(n);for(let t=0,s=0;t<n;++t,s+=e)i[t]=a.substr(s,e);a=i.join(t===K.BLOCK_LITERAL?"\n":" ")}return ae({comment:e,type:t,value:a},s,i,o)}};function We(e,t){if(g(e))for(let n=0;n<e.items.length;++n){let s=e.items[n];if(!u(s)){if(h(s)){s.items.length>1&&t("Each pair must have its own sequence indicator");const e=s.items[0]||new ye(new K(null));if(s.commentBefore&&(e.key.commentBefore=e.key.commentBefore?`${s.commentBefore}\n${e.key.commentBefore}`:s.commentBefore),s.comment){const t=e.value??e.key;t.comment=t.comment?`${s.comment}\n${t.comment}`:s.comment}s=e}e.items[n]=u(s)?s:new ye(s)}}else t("Expected a sequence for this tag");return e}function Je(e,t,n){const{replacer:s}=n,i=new Se(e);i.tag="tag:yaml.org,2002:pairs";let o=0;if(t&&Symbol.iterator in Object(t))for(let r of t){let e,a;if("function"==typeof s&&(r=s.call(t,String(o++),r)),Array.isArray(r)){if(2!==r.length)throw new TypeError(`Expected [key, value] tuple: ${r}`);e=r[0],a=r[1]}else if(r&&r instanceof Object){const t=Object.keys(r);if(1!==t.length)throw new TypeError(`Expected tuple with one key, not ${t.length} keys`);e=t[0],a=r[e]}else e=r;i.items.push(ge(e,a,n))}return i}const He={collection:"seq",default:!1,tag:"tag:yaml.org,2002:pairs",resolve:We,createNode:Je};class Ge extends Se{constructor(){super(),this.add=$e.prototype.add.bind(this),this.delete=$e.prototype.delete.bind(this),this.get=$e.prototype.get.bind(this),this.has=$e.prototype.has.bind(this),this.set=$e.prototype.set.bind(this),this.tag=Ge.tag}toJSON(e,t){if(!t)return super.toJSON(e);const n=new Map;t?.onCreate&&t.onCreate(n);for(const s of this.items){let e,i;if(u(s)?(e=B(s.key,"",t),i=B(s.value,e,t)):e=B(s,"",t),n.has(e))throw new Error("Ordered maps must not include duplicate keys");n.set(e,i)}return n}static from(e,t,n){const s=Je(e,t,n),i=new this;return i.items=s.items,i}}Ge.tag="tag:yaml.org,2002:omap";const Ye={collection:"seq",identify:e=>e instanceof Map,nodeClass:Ge,default:!1,tag:"tag:yaml.org,2002:omap",resolve(e,t){const n=We(e,t),s=[];for(const{key:i}of n.items)m(i)&&(s.includes(i.value)?t(`Ordered maps must not include duplicate keys: ${i.value}`):s.push(i.value));return Object.assign(new Ge,n)},createNode:(e,t,n)=>Ge.from(e,t,n)};function Qe({value:e,source:t},n){return t&&(e?Xe:Ze).test.test(t)?t:e?n.options.trueStr:n.options.falseStr}const Xe={identify:e=>!0===e,default:!0,tag:"tag:yaml.org,2002:bool",test:/^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,resolve:()=>new K(!0),stringify:Qe},Ze={identify:e=>!1===e,default:!0,tag:"tag:yaml.org,2002:bool",test:/^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,resolve:()=>new K(!1),stringify:Qe},et={identify:e=>"number"==typeof e,default:!0,tag:"tag:yaml.org,2002:float",test:/^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,resolve:e=>"nan"===e.slice(-3).toLowerCase()?NaN:"-"===e[0]?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,stringify:Ie},tt={identify:e=>"number"==typeof e,default:!0,tag:"tag:yaml.org,2002:float",format:"EXP",test:/^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,resolve:e=>parseFloat(e.replace(/_/g,"")),stringify(e){const t=Number(e.value);return isFinite(t)?t.toExponential():Ie(e)}},nt={identify:e=>"number"==typeof e,default:!0,tag:"tag:yaml.org,2002:float",test:/^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,resolve(e){const t=new K(parseFloat(e.replace(/_/g,""))),n=e.indexOf(".");if(-1!==n){const s=e.substring(n+1).replace(/_/g,"");"0"===s[s.length-1]&&(t.minFractionDigits=s.length)}return t},stringify:Ie},st=e=>"bigint"==typeof e||Number.isInteger(e);function it(e,t,n,{intAsBigInt:s}){const i=e[0];if("-"!==i&&"+"!==i||(t+=1),e=e.substring(t).replace(/_/g,""),s){switch(n){case 2:e=`0b${e}`;break;case 8:e=`0o${e}`;break;case 16:e=`0x${e}`}const t=BigInt(e);return"-"===i?BigInt(-1)*t:t}const o=parseInt(e,n);return"-"===i?-1*o:o}function ot(e,t,n){const{value:s}=e;if(st(s)){const e=s.toString(t);return s<0?"-"+n+e.substr(1):n+e}return Ie(e)}const rt={identify:st,default:!0,tag:"tag:yaml.org,2002:int",format:"BIN",test:/^[-+]?0b[0-1_]+$/,resolve:(e,t,n)=>it(e,2,2,n),stringify:e=>ot(e,2,"0b")},at={identify:st,default:!0,tag:"tag:yaml.org,2002:int",format:"OCT",test:/^[-+]?0[0-7_]+$/,resolve:(e,t,n)=>it(e,1,8,n),stringify:e=>ot(e,8,"0")},ct={identify:st,default:!0,tag:"tag:yaml.org,2002:int",test:/^[-+]?[0-9][0-9_]*$/,resolve:(e,t,n)=>it(e,0,10,n),stringify:Ie},lt={identify:st,default:!0,tag:"tag:yaml.org,2002:int",format:"HEX",test:/^[-+]?0x[0-9a-fA-F_]+$/,resolve:(e,t,n)=>it(e,2,16,n),stringify:e=>ot(e,16,"0x")};class pt extends $e{constructor(e){super(e),this.tag=pt.tag}add(e){let t;t=u(e)?e:e&&"object"==typeof e&&"key"in e&&"value"in e&&null===e.value?new ye(e.key,null):new ye(e,null);xe(this.items,t.key)||this.items.push(t)}get(e,t){const n=xe(this.items,e);return!t&&u(n)?m(n.key)?n.key.value:n.key:n}set(e,t){if("boolean"!=typeof t)throw new Error("Expected boolean value for set(key, value) in a YAML set, not "+typeof t);const n=xe(this.items,e);n&&!t?this.items.splice(this.items.indexOf(n),1):!n&&t&&this.items.push(new ye(e))}toJSON(e,t){return super.toJSON(e,t,Set)}toString(e,t,n){if(!e)return JSON.stringify(this);if(this.hasAllNullValues(!0))return super.toString(Object.assign({},e,{allNullValues:!0}),t,n);throw new Error("Set items must all have null values")}static from(e,t,n){const{replacer:s}=n,i=new this(e);if(t&&Symbol.iterator in Object(t))for(let o of t)"function"==typeof s&&(o=s.call(t,o,o)),i.items.push(ge(o,null,n));return i}}pt.tag="tag:yaml.org,2002:set";const dt={collection:"map",identify:e=>e instanceof Set,nodeClass:pt,default:!1,tag:"tag:yaml.org,2002:set",createNode:(e,t,n)=>pt.from(e,t,n),resolve(e,t){if(h(e)){if(e.hasAllNullValues(!0))return Object.assign(new pt,e);t("Set items must all have null values")}else t("Expected a mapping for this tag");return e}};function ft(e,t){const n=e[0],s="-"===n||"+"===n?e.substring(1):e,i=e=>t?BigInt(e):Number(e),o=s.replace(/_/g,"").split(":").reduce(((e,t)=>e*i(60)+i(t)),i(0));return"-"===n?i(-1)*o:o}function ht(e){let{value:t}=e,n=e=>e;if("bigint"==typeof t)n=e=>BigInt(e);else if(isNaN(t)||!isFinite(t))return Ie(e);let s="";t<0&&(s="-",t*=n(-1));const i=n(60),o=[t%i];return t<60?o.unshift(0):(t=(t-o[0])/i,o.unshift(t%i),t>=60&&(t=(t-o[0])/i,o.unshift(t))),s+o.map((e=>String(e).padStart(2,"0"))).join(":").replace(/000000\d*$/,"")}const ut={identify:e=>"bigint"==typeof e||Number.isInteger(e),default:!0,tag:"tag:yaml.org,2002:int",format:"TIME",test:/^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,resolve:(e,t,{intAsBigInt:n})=>ft(e,n),stringify:ht},mt={identify:e=>"number"==typeof e,default:!0,tag:"tag:yaml.org,2002:float",format:"TIME",test:/^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,resolve:e=>ft(e,!1),stringify:ht},gt={identify:e=>e instanceof Date,default:!0,tag:"tag:yaml.org,2002:timestamp",test:RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),resolve(e){const t=e.match(gt.test);if(!t)throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");const[,n,s,i,o,r,a]=t.map(Number),c=t[7]?Number((t[7]+"00").substr(1,3)):0;let l=Date.UTC(n,s-1,i,o||0,r||0,a||0,c);const p=t[8];if(p&&"Z"!==p){let e=ft(p,!1);Math.abs(e)<30&&(e*=60),l-=6e4*e}return new Date(l)},stringify:({value:e})=>e?.toISOString().replace(/(T00:00:00)?\.000Z$/,"")??""},yt=[je,Ne,Ee,Oe,Xe,Ze,rt,at,ct,lt,et,tt,nt,Ve,fe,Ye,He,dt,ut,mt,gt],bt=new Map([["core",Ke],["failsafe",[je,Ne,Ee]],["json",Fe],["yaml11",yt],["yaml-1.1",yt]]),vt={binary:Ve,bool:Te,float:Le,floatExp:_e,floatNaN:Ce,floatTime:mt,int:Re,intHex:Me,intOct:De,intTime:ut,map:je,merge:fe,null:Oe,omap:Ye,pairs:He,seq:Ne,set:dt,timestamp:gt},kt={"tag:yaml.org,2002:binary":Ve,"tag:yaml.org,2002:merge":fe,"tag:yaml.org,2002:omap":Ye,"tag:yaml.org,2002:pairs":He,"tag:yaml.org,2002:set":dt,"tag:yaml.org,2002:timestamp":gt};function wt(e,t,n){const s=bt.get(t);if(s&&!e)return n&&!s.includes(fe)?s.concat(fe):s.slice();let i=s;if(!i){if(!Array.isArray(e)){const e=Array.from(bt.keys()).filter((e=>"yaml11"!==e)).map((e=>JSON.stringify(e))).join(", ");throw new Error(`Unknown schema "${t}"; use one of ${e} or define customTags array`)}i=[]}if(Array.isArray(e))for(const o of e)i=i.concat(o);else"function"==typeof e&&(i=e(i.slice()));return n&&(i=i.concat(fe)),i.reduce(((e,t)=>{const n="string"==typeof t?vt[t]:t;if(!n){const e=JSON.stringify(t),n=Object.keys(vt).map((e=>JSON.stringify(e))).join(", ");throw new Error(`Unknown custom tag ${e}; use one of ${n}`)}return e.includes(n)||e.push(n),e}),[])}const xt=(e,t)=>e.key<t.key?-1:e.key>t.key?1:0;class $t{constructor({compat:e,customTags:t,merge:n,resolveKnownTags:s,schema:i,sortMapEntries:o,toStringDefaults:a}){this.compat=Array.isArray(e)?wt(e,"compat"):e?wt(null,e):null,this.name="string"==typeof i&&i||"core",this.knownTags=s?kt:{},this.tags=wt(t,this.name,n),this.toStringOptions=a??null,Object.defineProperty(this,r,{value:je}),Object.defineProperty(this,c,{value:Ee}),Object.defineProperty(this,l,{value:Ne}),this.sortMapEntries="function"==typeof o?o:!0===o?xt:null}clone(){const e=Object.create($t.prototype,Object.getOwnPropertyDescriptors(this));return e.tags=this.tags.slice(),e}}class jt{constructor(e,t,n){this.commentBefore=null,this.comment=null,this.errors=[],this.warnings=[],Object.defineProperty(this,p,{value:o});let s=null;"function"==typeof t||Array.isArray(t)?s=t:void 0===n&&t&&(n=t,t=void 0);const i=Object.assign({intAsBigInt:!1,keepSourceTokens:!1,logLevel:"warn",prettyErrors:!0,strict:!0,stringKeys:!1,uniqueKeys:!0,version:"1.2"},n);this.options=i;let{version:r}=i;n?._directives?(this.directives=n._directives.atDocument(),this.directives.yaml.explicit&&(r=this.directives.yaml.version)):this.directives=new I({version:r}),this.setSchema(r,n),this.contents=void 0===e?null:this.createNode(e,s,n)}clone(){const e=Object.create(jt.prototype,{[p]:{value:o}});return e.commentBefore=this.commentBefore,e.comment=this.comment,e.errors=this.errors.slice(),e.warnings=this.warnings.slice(),e.options=Object.assign({},this.options),this.directives&&(e.directives=this.directives.clone()),e.schema=this.schema.clone(),e.contents=b(this.contents)?this.contents.clone(e.schema):this.contents,this.range&&(e.range=this.range.slice()),e}add(e){St(this.contents)&&this.contents.add(e)}addIn(e,t){St(this.contents)&&this.contents.addIn(e,t)}createAlias(e,t){if(!e.anchor){const n=_(this);e.anchor=!t||n.has(t)?L(t||"a",n):t}return new D(e.anchor)}createNode(e,t,n){let s;if("function"==typeof t)e=t.call({"":e},"",e),s=t;else if(Array.isArray(t)){const e=e=>"number"==typeof e||e instanceof String||e instanceof Number,n=t.filter(e).map(String);n.length>0&&(t=t.concat(n)),s=t}else void 0===n&&t&&(n=t,t=void 0);const{aliasDuplicateObjects:i,anchorPrefix:o,flow:r,keepUndefined:a,onTagObj:c,tag:l}=n??{},{onAnchor:p,setAnchors:d,sourceObjects:f}=function(e,t){const n=[],s=new Map;let i=null;return{onAnchor:s=>{n.push(s),i??(i=_(e));const o=L(t,i);return i.add(o),o},setAnchors:()=>{for(const e of n){const t=s.get(e);if("object"!=typeof t||!t.anchor||!m(t.node)&&!y(t.node)){const t=new Error("Failed to resolve repeated object (this should not happen)");throw t.source=e,t}t.node.anchor=t.anchor}},sourceObjects:s}}(this,o||"a"),h=U(e,l,{aliasDuplicateObjects:i??!0,keepUndefined:a??!1,onAnchor:p,onTagObj:c,replacer:s,schema:this.schema,sourceObjects:f});return r&&y(h)&&(h.flow=!0),d(),h}createPair(e,t,n={}){const s=this.createNode(e,null,n),i=this.createNode(t,null,n);return new ye(s,i)}delete(e){return!!St(this.contents)&&this.contents.delete(e)}deleteIn(e){return F(e)?null!=this.contents&&(this.contents=null,!0):!!St(this.contents)&&this.contents.deleteIn(e)}get(e,t){return y(this.contents)?this.contents.get(e,t):void 0}getIn(e,t){return F(e)?!t&&m(this.contents)?this.contents.value:this.contents:y(this.contents)?this.contents.getIn(e,t):void 0}has(e){return!!y(this.contents)&&this.contents.has(e)}hasIn(e){return F(e)?void 0!==this.contents:!!y(this.contents)&&this.contents.hasIn(e)}set(e,t){null==this.contents?this.contents=z(this.schema,[e],t):St(this.contents)&&this.contents.set(e,t)}setIn(e,t){F(e)?this.contents=t:null==this.contents?this.contents=z(this.schema,Array.from(e),t):St(this.contents)&&this.contents.setIn(e,t)}setSchema(e,t={}){let n;switch("number"==typeof e&&(e=String(e)),e){case"1.1":this.directives?this.directives.yaml.version="1.1":this.directives=new I({version:"1.1"}),n={resolveKnownTags:!1,schema:"yaml-1.1"};break;case"1.2":case"next":this.directives?this.directives.yaml.version=e:this.directives=new I({version:e}),n={resolveKnownTags:!0,schema:"core"};break;case null:this.directives&&delete this.directives,n=null;break;default:{const t=JSON.stringify(e);throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${t}`)}}if(t.schema instanceof Object)this.schema=t.schema;else{if(!n)throw new Error("With a null YAML version, the { schema: Schema } option is required");this.schema=new $t(Object.assign(n,t))}}toJS({json:e,jsonArg:t,mapAsMap:n,maxAliasCount:s,onAnchor:i,reviver:o}={}){const r={anchors:new Map,doc:this,keep:!e,mapAsMap:!0===n,mapKeyWarned:!1,maxAliasCount:"number"==typeof s?s:100},a=B(this.contents,t??"",r);if("function"==typeof i)for(const{count:c,res:l}of r.anchors.values())i(l,c);return"function"==typeof o?q(o,{"":a},"",a):a}toJSON(e,t){return this.toJS({json:!0,jsonArg:e,mapAsMap:!1,onAnchor:t})}toString(e={}){if(this.errors.length>0)throw new Error("Document with errors cannot be stringified");if("indent"in e&&(!Number.isInteger(e.indent)||Number(e.indent)<=0)){const t=JSON.stringify(e.indent);throw new Error(`"indent" option must be a positive integer, not ${t}`)}return function(e,t){const n=[];let s=!0===t.directives;if(!1!==t.directives&&e.directives){const t=e.directives.toString(e);t?(n.push(t),s=!0):e.directives.docStart&&(s=!0)}s&&n.push("---");const i=ce(e,t),{commentString:o}=i.options;if(e.commentBefore){1!==n.length&&n.unshift("");const t=o(e.commentBefore);n.unshift(J(t,""))}let r=!1,a=null;if(e.contents){if(b(e.contents)){if(e.contents.spaceBefore&&s&&n.push(""),e.contents.commentBefore){const t=o(e.contents.commentBefore);n.push(J(t,""))}i.forceBlockIndent=!!e.comment,a=e.contents.comment}const t=a?void 0:()=>r=!0;let c=le(e.contents,i,(()=>a=null),t);a&&(c+=H(c,"",o(a))),"|"!==c[0]&&">"!==c[0]||"---"!==n[n.length-1]?n.push(c):n[n.length-1]=`--- ${c}`}else n.push(le(e.contents,i));if(e.directives?.docEnd)if(e.comment){const t=o(e.comment);t.includes("\n")?(n.push("..."),n.push(J(t,""))):n.push(`... ${t}`)}else n.push("...");else{let t=e.comment;t&&r&&(t=t.replace(/^\n+/,"")),t&&(r&&!a||""===n[n.length-1]||n.push(""),n.push(J(o(t),"")))}return n.join("\n")+"\n"}(this,e)}}function St(e){if(y(e))return!0;throw new Error("Expected a YAML collection as document contents")}class At extends Error{constructor(e,t,n,s){super(),this.name=e,this.code=n,this.message=s,this.pos=t}}class Nt extends At{constructor(e,t,n){super("YAMLParseError",e,t,n)}}class Et extends At{constructor(e,t,n){super("YAMLWarning",e,t,n)}}const Ot=(e,t)=>n=>{if(-1===n.pos[0])return;n.linePos=n.pos.map((e=>t.linePos(e)));const{line:s,col:i}=n.linePos[0];n.message+=` at line ${s}, column ${i}`;let o=i-1,r=e.substring(t.lineStarts[s-1],t.lineStarts[s]).replace(/[\n\r]+$/,"");if(o>=60&&r.length>80){const e=Math.min(o-39,r.length-79);r="\u2026"+r.substring(e),o-=e-1}if(r.length>80&&(r=r.substring(0,79)+"\u2026"),s>1&&/^ *$/.test(r.substring(0,o))){let n=e.substring(t.lineStarts[s-2],t.lineStarts[s-1]);n.length>80&&(n=n.substring(0,79)+"\u2026\n"),r=n+r}if(/[^ ]/.test(r)){let e=1;const t=n.linePos[1];t?.line===s&&t.col>i&&(e=Math.max(1,Math.min(t.col-i,80-o)));const a=" ".repeat(o)+"^".repeat(e);n.message+=`:\n\n${r}\n${a}\n`}};function Tt(e,{flow:t,indicator:n,next:s,offset:i,onError:o,parentIndent:r,startOnNewline:a}){let c=!1,l=a,p=a,d="",f="",h=!1,u=!1,m=null,g=null,y=null,b=null,v=null,k=null,w=null;for(const j of e)switch(u&&("space"!==j.type&&"newline"!==j.type&&"comma"!==j.type&&o(j.offset,"MISSING_CHAR","Tags and anchors must be separated from the next token by white space"),u=!1),m&&(l&&"comment"!==j.type&&"newline"!==j.type&&o(m,"TAB_AS_INDENT","Tabs are not allowed as indentation"),m=null),j.type){case"space":t||"doc-start"===n&&"flow-collection"===s?.type||!j.source.includes("\t")||(m=j),p=!0;break;case"comment":{p||o(j,"MISSING_CHAR","Comments must be separated from other tokens by white space characters");const e=j.source.substring(1)||" ";d?d+=f+e:d=e,f="",l=!1;break}case"newline":l?d?d+=j.source:k&&"seq-item-ind"===n||(c=!0):f+=j.source,l=!0,h=!0,(g||y)&&(b=j),p=!0;break;case"anchor":g&&o(j,"MULTIPLE_ANCHORS","A node can have at most one anchor"),j.source.endsWith(":")&&o(j.offset+j.source.length-1,"BAD_ALIAS","Anchor ending in : is ambiguous",!0),g=j,w??(w=j.offset),l=!1,p=!1,u=!0;break;case"tag":y&&o(j,"MULTIPLE_TAGS","A node can have at most one tag"),y=j,w??(w=j.offset),l=!1,p=!1,u=!0;break;case n:(g||y)&&o(j,"BAD_PROP_ORDER",`Anchors and tags must be after the ${j.source} indicator`),k&&o(j,"UNEXPECTED_TOKEN",`Unexpected ${j.source} in ${t??"collection"}`),k=j,l="seq-item-ind"===n||"explicit-key-ind"===n,p=!1;break;case"comma":if(t){v&&o(j,"UNEXPECTED_TOKEN",`Unexpected , in ${t}`),v=j,l=!1,p=!1;break}default:o(j,"UNEXPECTED_TOKEN",`Unexpected ${j.type} token`),l=!1,p=!1}const x=e[e.length-1],$=x?x.offset+x.source.length:i;return u&&s&&"space"!==s.type&&"newline"!==s.type&&"comma"!==s.type&&("scalar"!==s.type||""!==s.source)&&o(s.offset,"MISSING_CHAR","Tags and anchors must be separated from the next token by white space"),m&&(l&&m.indent<=r||"block-map"===s?.type||"block-seq"===s?.type)&&o(m,"TAB_AS_INDENT","Tabs are not allowed as indentation"),{comma:v,found:k,spaceBefore:c,comment:d,hasNewline:h,anchor:g,tag:y,newlineAfterProp:b,end:$,start:w??$}}function It(e){if(!e)return null;switch(e.type){case"alias":case"scalar":case"double-quoted-scalar":case"single-quoted-scalar":if(e.source.includes("\n"))return!0;if(e.end)for(const t of e.end)if("newline"===t.type)return!0;return!1;case"flow-collection":for(const t of e.items){for(const e of t.start)if("newline"===e.type)return!0;if(t.sep)for(const e of t.sep)if("newline"===e.type)return!0;if(It(t.key)||It(t.value))return!0}return!1;default:return!0}}function Ct(e,t,n){if("flow-collection"===t?.type){const s=t.end[0];if(s.indent===e&&("]"===s.source||"}"===s.source)&&It(t)){n(s,"BAD_INDENT","Flow end indicator should be more indented than parent",!0)}}}function _t(e,t,n){const{uniqueKeys:s}=e.options;if(!1===s)return!1;const i="function"==typeof s?s:(e,t)=>e===t||m(e)&&m(t)&&e.value===t.value;return t.some((e=>i(e.key,n)))}const Lt="All mapping items must start at the same column";function qt(e,t,n,s){let i="";if(e){let o=!1,r="";for(const a of e){const{source:e,type:c}=a;switch(c){case"space":o=!0;break;case"comment":{n&&!o&&s(a,"MISSING_CHAR","Comments must be separated from other tokens by white space characters");const t=e.substring(1)||" ";i?i+=r+t:i=t,r="";break}case"newline":i&&(r+=e),o=!0;break;default:s(a,"UNEXPECTED_TOKEN",`Unexpected ${c} at node end`)}t+=e.length}}return{comment:i,offset:t}}const Bt="Block collections are not allowed within flow collections",Pt=e=>e&&("block-map"===e.type||"block-seq"===e.type);function Dt(e,t,n,s,i,o){const r="block-map"===n.type?function({composeNode:e,composeEmptyNode:t},n,s,i,o){const r=new(o?.nodeClass??$e)(n.schema);n.atRoot&&(n.atRoot=!1);let a=s.offset,c=null;for(const l of s.items){const{start:o,key:p,sep:d,value:f}=l,h=Tt(o,{indicator:"explicit-key-ind",next:p??d?.[0],offset:a,onError:i,parentIndent:s.indent,startOnNewline:!0}),u=!h.found;if(u){if(p&&("block-seq"===p.type?i(a,"BLOCK_AS_IMPLICIT_KEY","A block sequence may not be used as an implicit map key"):"indent"in p&&p.indent!==s.indent&&i(a,"BAD_INDENT",Lt)),!h.anchor&&!h.tag&&!d){c=h.end,h.comment&&(r.comment?r.comment+="\n"+h.comment:r.comment=h.comment);continue}(h.newlineAfterProp||It(p))&&i(p??o[o.length-1],"MULTILINE_IMPLICIT_KEY","Implicit keys need to be on a single line")}else h.found?.indent!==s.indent&&i(a,"BAD_INDENT",Lt);n.atKey=!0;const m=h.end,g=p?e(n,p,h,i):t(n,m,o,null,h,i);n.schema.compat&&Ct(s.indent,p,i),n.atKey=!1,_t(n,r.items,g)&&i(m,"DUPLICATE_KEY","Map keys must be unique");const y=Tt(d??[],{indicator:"map-value-ind",next:f,offset:g.range[2],onError:i,parentIndent:s.indent,startOnNewline:!p||"block-scalar"===p.type});if(a=y.end,y.found){u&&("block-map"!==f?.type||y.hasNewline||i(a,"BLOCK_AS_IMPLICIT_KEY","Nested mappings are not allowed in compact mappings"),n.options.strict&&h.start<y.found.offset-1024&&i(g.range,"KEY_OVER_1024_CHARS","The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));const o=f?e(n,f,y,i):t(n,a,d,null,y,i);n.schema.compat&&Ct(s.indent,f,i),a=o.range[2];const c=new ye(g,o);n.options.keepSourceTokens&&(c.srcToken=l),r.items.push(c)}else{u&&i(g.range,"MISSING_CHAR","Implicit map keys need to be followed by map values"),y.comment&&(g.comment?g.comment+="\n"+y.comment:g.comment=y.comment);const e=new ye(g);n.options.keepSourceTokens&&(e.srcToken=l),r.items.push(e)}}return c&&c<a&&i(c,"IMPOSSIBLE","Map comment with trailing content"),r.range=[s.offset,a,c??a],r}(e,t,n,s,o):"block-seq"===n.type?function({composeNode:e,composeEmptyNode:t},n,s,i,o){const r=new(o?.nodeClass??Se)(n.schema);n.atRoot&&(n.atRoot=!1),n.atKey&&(n.atKey=!1);let a=s.offset,c=null;for(const{start:l,value:p}of s.items){const o=Tt(l,{indicator:"seq-item-ind",next:p,offset:a,onError:i,parentIndent:s.indent,startOnNewline:!0});if(!o.found){if(!(o.anchor||o.tag||p)){c=o.end,o.comment&&(r.comment=o.comment);continue}"block-seq"===p?.type?i(o.end,"BAD_INDENT","All sequence items must start at the same column"):i(a,"MISSING_CHAR","Sequence item without - indicator")}const d=p?e(n,p,o,i):t(n,o.end,l,null,o,i);n.schema.compat&&Ct(s.indent,p,i),a=d.range[2],r.items.push(d)}return r.range=[s.offset,a,c??a],r}(e,t,n,s,o):function({composeNode:e,composeEmptyNode:t},n,s,i,o){const r="{"===s.start.source,a=r?"flow map":"flow sequence",c=new(o?.nodeClass??(r?$e:Se))(n.schema);c.flow=!0;const l=n.atRoot;l&&(n.atRoot=!1),n.atKey&&(n.atKey=!1);let p=s.offset+s.start.source.length;for(let g=0;g<s.items.length;++g){const o=s.items[g],{start:l,key:d,sep:f,value:h}=o,m=Tt(l,{flow:a,indicator:"explicit-key-ind",next:d??f?.[0],offset:p,onError:i,parentIndent:s.indent,startOnNewline:!1});if(!m.found){if(!(m.anchor||m.tag||f||h)){0===g&&m.comma?i(m.comma,"UNEXPECTED_TOKEN",`Unexpected , in ${a}`):g<s.items.length-1&&i(m.start,"UNEXPECTED_TOKEN",`Unexpected empty item in ${a}`),m.comment&&(c.comment?c.comment+="\n"+m.comment:c.comment=m.comment),p=m.end;continue}!r&&n.options.strict&&It(d)&&i(d,"MULTILINE_IMPLICIT_KEY","Implicit keys of flow sequence pairs need to be on a single line")}if(0===g)m.comma&&i(m.comma,"UNEXPECTED_TOKEN",`Unexpected , in ${a}`);else if(m.comma||i(m.start,"MISSING_CHAR",`Missing , between ${a} items`),m.comment){let e="";e:for(const t of l)switch(t.type){case"comma":case"space":break;case"comment":e=t.source.substring(1);break e;default:break e}if(e){let t=c.items[c.items.length-1];u(t)&&(t=t.value??t.key),t.comment?t.comment+="\n"+e:t.comment=e,m.comment=m.comment.substring(e.length+1)}}if(r||f||m.found){n.atKey=!0;const u=m.end,g=d?e(n,d,m,i):t(n,u,l,null,m,i);Pt(d)&&i(g.range,"BLOCK_IN_FLOW",Bt),n.atKey=!1;const y=Tt(f??[],{flow:a,indicator:"map-value-ind",next:h,offset:g.range[2],onError:i,parentIndent:s.indent,startOnNewline:!1});if(y.found){if(!r&&!m.found&&n.options.strict){if(f)for(const e of f){if(e===y.found)break;if("newline"===e.type){i(e,"MULTILINE_IMPLICIT_KEY","Implicit keys of flow sequence pairs need to be on a single line");break}}m.start<y.found.offset-1024&&i(y.found,"KEY_OVER_1024_CHARS","The : indicator must be at most 1024 chars after the start of an implicit flow sequence key")}}else h&&("source"in h&&":"===h.source?.[0]?i(h,"MISSING_CHAR",`Missing space after : in ${a}`):i(y.start,"MISSING_CHAR",`Missing , or : between ${a} items`));const b=h?e(n,h,y,i):y.found?t(n,y.end,f,null,y,i):null;b?Pt(h)&&i(b.range,"BLOCK_IN_FLOW",Bt):y.comment&&(g.comment?g.comment+="\n"+y.comment:g.comment=y.comment);const v=new ye(g,b);if(n.options.keepSourceTokens&&(v.srcToken=o),r){const e=c;_t(n,e.items,g)&&i(u,"DUPLICATE_KEY","Map keys must be unique"),e.items.push(v)}else{const e=new $e(n.schema);e.flow=!0,e.items.push(v);const t=(b??g).range;e.range=[g.range[0],t[1],t[2]],c.items.push(e)}p=b?b.range[2]:y.end}else{const s=h?e(n,h,m,i):t(n,m.end,f,null,m,i);c.items.push(s),p=s.range[2],Pt(h)&&i(s.range,"BLOCK_IN_FLOW",Bt)}}const d=r?"}":"]",[f,...h]=s.end;let m=p;if(f?.source===d)m=f.offset+f.source.length;else{const e=a[0].toUpperCase()+a.substring(1);i(p,l?"MISSING_CHAR":"BAD_INDENT",l?`${e} must end with a ${d}`:`${e} in block collection must be sufficiently indented and end with a ${d}`),f&&1!==f.source.length&&h.unshift(f)}if(h.length>0){const e=qt(h,m,n.options.strict,i);e.comment&&(c.comment?c.comment+="\n"+e.comment:c.comment=e.comment),c.range=[s.offset,m,e.offset]}else c.range=[s.offset,m,m];return c}(e,t,n,s,o),a=r.constructor;return"!"===i||i===a.tagName?(r.tag=a.tagName,r):(i&&(r.tag=i),r)}function Rt(e,t,n){const s=t.offset,i=function({offset:e,props:t},n,s){if("block-scalar-header"!==t[0].type)return s(t[0],"IMPOSSIBLE","Block scalar header not found"),null;const{source:i}=t[0],o=i[0];let r=0,a="",c=-1;for(let f=1;f<i.length;++f){const t=i[f];if(a||"-"!==t&&"+"!==t){const n=Number(t);!r&&n?r=n:-1===c&&(c=e+f)}else a=t}-1!==c&&s(c,"UNEXPECTED_TOKEN",`Block scalar header includes extra characters: ${i}`);let l=!1,p="",d=i.length;for(let f=1;f<t.length;++f){const e=t[f];switch(e.type){case"space":l=!0;case"newline":d+=e.source.length;break;case"comment":if(n&&!l){s(e,"MISSING_CHAR","Comments must be separated from other tokens by white space characters")}d+=e.source.length,p=e.source.substring(1);break;case"error":s(e,"UNEXPECTED_TOKEN",e.message),d+=e.source.length;break;default:{s(e,"UNEXPECTED_TOKEN",`Unexpected token in block scalar header: ${e.type}`);const t=e.source;t&&"string"==typeof t&&(d+=t.length)}}}return{mode:o,indent:r,chomp:a,comment:p,length:d}}(t,e.options.strict,n);if(!i)return{value:"",type:null,comment:"",range:[s,s,s]};const o=">"===i.mode?K.BLOCK_FOLDED:K.BLOCK_LITERAL,r=t.source?function(e){const t=e.split(/\n( *)/),n=t[0],s=n.match(/^( *)/),i=[s?.[1]?[s[1],n.slice(s[1].length)]:["",n]];for(let o=1;o<t.length;o+=2)i.push([t[o],t[o+1]]);return i}(t.source):[];let a=r.length;for(let m=r.length-1;m>=0;--m){const e=r[m][1];if(""!==e&&"\r"!==e)break;a=m}if(0===a){const e="+"===i.chomp&&r.length>0?"\n".repeat(Math.max(1,r.length-1)):"";let n=s+i.length;return t.source&&(n+=t.source.length),{value:e,type:o,comment:i.comment,range:[s,n,n]}}let c=t.indent+i.indent,l=t.offset+i.length,p=0;for(let m=0;m<a;++m){const[t,s]=r[m];if(""!==s&&"\r"!==s){if(t.length<c){const e="Block scalars with more-indented leading empty lines must use an explicit indentation indicator";n(l+t.length,"MISSING_CHAR",e)}if(0===i.indent&&(c=t.length),p=m,0===c&&!e.atRoot){n(l,"BAD_INDENT","Block scalar values in collections must be indented")}break}0===i.indent&&t.length>c&&(c=t.length),l+=t.length+s.length+1}for(let m=r.length-1;m>=a;--m)r[m][0].length>c&&(a=m+1);let d="",f="",h=!1;for(let m=0;m<p;++m)d+=r[m][0].slice(c)+"\n";for(let m=p;m<a;++m){let[e,t]=r[m];l+=e.length+t.length+1;const s="\r"===t[t.length-1];if(s&&(t=t.slice(0,-1)),t&&e.length<c){const o=`Block scalar lines must not be less indented than their ${i.indent?"explicit indentation indicator":"first line"}`;n(l-t.length-(s?2:1),"BAD_INDENT",o),e=""}o===K.BLOCK_LITERAL?(d+=f+e.slice(c)+t,f="\n"):e.length>c||"\t"===t[0]?(" "===f?f="\n":h||"\n"!==f||(f="\n\n"),d+=f+e.slice(c)+t,f="\n",h=!0):""===t?"\n"===f?d+="\n":f="\n":(d+=f+t,f=" ",h=!1)}switch(i.chomp){case"-":break;case"+":for(let e=a;e<r.length;++e)d+="\n"+r[e][0].slice(c);"\n"!==d[d.length-1]&&(d+="\n");break;default:d+="\n"}const u=s+i.length+t.source.length;return{value:d,type:o,comment:i.comment,range:[s,u,u]}}function Mt(e,t,n){const{offset:s,type:i,source:o,end:r}=e;let a,c;const l=(e,t,i)=>n(s+e,t,i);switch(i){case"scalar":a=K.PLAIN,c=function(e,t){let n="";switch(e[0]){case"\t":n="a tab character";break;case",":n="flow indicator character ,";break;case"%":n="directive indicator character %";break;case"|":case">":n=`block scalar indicator ${e[0]}`;break;case"@":case"`":n=`reserved character ${e[0]}`}n&&t(0,"BAD_SCALAR_START",`Plain value cannot start with ${n}`);return Kt(e)}(o,l);break;case"single-quoted-scalar":a=K.QUOTE_SINGLE,c=function(e,t){"'"===e[e.length-1]&&1!==e.length||t(e.length,"MISSING_CHAR","Missing closing 'quote");return Kt(e.slice(1,-1)).replace(/''/g,"'")}(o,l);break;case"double-quoted-scalar":a=K.QUOTE_DOUBLE,c=function(e,t){let n="";for(let s=1;s<e.length-1;++s){const i=e[s];if("\r"!==i||"\n"!==e[s+1])if("\n"===i){const{fold:t,offset:i}=Ut(e,s);n+=t,s=i}else if("\\"===i){let i=e[++s];const o=zt[i];if(o)n+=o;else if("\n"===i)for(i=e[s+1];" "===i||"\t"===i;)i=e[1+ ++s];else if("\r"===i&&"\n"===e[s+1])for(i=e[1+ ++s];" "===i||"\t"===i;)i=e[1+ ++s];else if("x"===i||"u"===i||"U"===i){const o={x:2,u:4,U:8}[i];n+=Ft(e,s+1,o,t),s+=o}else{const i=e.substr(s-1,2);t(s-1,"BAD_DQ_ESCAPE",`Invalid escape sequence ${i}`),n+=i}}else if(" "===i||"\t"===i){const t=s;let o=e[s+1];for(;" "===o||"\t"===o;)o=e[1+ ++s];"\n"===o||"\r"===o&&"\n"===e[s+2]||(n+=s>t?e.slice(t,s+1):i)}else n+=i}'"'===e[e.length-1]&&1!==e.length||t(e.length,"MISSING_CHAR",'Missing closing "quote');return n}(o,l);break;default:return n(e,"UNEXPECTED_TOKEN",`Expected a flow scalar value, but found: ${i}`),{value:"",type:null,comment:"",range:[s,s+o.length,s+o.length]}}const p=s+o.length,d=qt(r,p,t,n);return{value:c,type:a,comment:d.comment,range:[s,p,d.offset]}}function Kt(e){let t,n;try{t=new RegExp("(.*?)(?<![ \t])[ \t]*\r?\n","sy"),n=new RegExp("[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?\n","sy")}catch{t=/(.*?)[ \t]*\r?\n/sy,n=/[ \t]*(.*?)[ \t]*\r?\n/sy}let s=t.exec(e);if(!s)return e;let i=s[1],o=" ",r=t.lastIndex;for(n.lastIndex=r;s=n.exec(e);)""===s[1]?"\n"===o?i+=o:o="\n":(i+=o+s[1],o=" "),r=n.lastIndex;const a=/[ \t]*(.*)/sy;return a.lastIndex=r,s=a.exec(e),i+o+(s?.[1]??"")}function Ut(e,t){let n="",s=e[t+1];for(;!(" "!==s&&"\t"!==s&&"\n"!==s&&"\r"!==s||"\r"===s&&"\n"!==e[t+2]);)"\n"===s&&(n+="\n"),s=e[(t+=1)+1];return n||(n=" "),{fold:n,offset:t}}const zt={0:"\0",a:"\x07",b:"\b",e:"\x1b",f:"\f",n:"\n",r:"\r",t:"\t",v:"\v",N:"\x85",_:"\xa0",L:"\u2028",P:"\u2029"," ":" ",'"':'"',"/":"/","\\":"\\","\t":"\t"};function Ft(e,t,n,s){const i=e.substr(t,n),o=i.length===n&&/^[0-9a-fA-F]+$/.test(i)?parseInt(i,16):NaN;if(isNaN(o)){const i=e.substr(t-2,n+2);return s(t-2,"BAD_DQ_ESCAPE",`Invalid escape sequence ${i}`),i}return String.fromCodePoint(o)}function Vt(e,t,n,s){const{value:i,type:o,comment:r,range:a}="block-scalar"===t.type?Rt(e,t,s):Mt(t,e.options.strict,s),l=n?e.directives.tagName(n.source,(e=>s(n,"TAG_RESOLVE_FAILED",e))):null;let p,d;p=e.options.stringKeys&&e.atKey?e.schema[c]:l?function(e,t,n,s,i){if("!"===n)return e[c];const o=[];for(const a of e.tags)if(!a.collection&&a.tag===n){if(!a.default||!a.test)return a;o.push(a)}for(const a of o)if(a.test?.test(t))return a;const r=e.knownTags[n];if(r&&!r.collection)return e.tags.push(Object.assign({},r,{default:!1,test:void 0})),r;return i(s,"TAG_RESOLVE_FAILED",`Unresolved tag: ${n}`,"tag:yaml.org,2002:str"!==n),e[c]}(e.schema,i,l,n,s):"scalar"===t.type?function({atKey:e,directives:t,schema:n},s,i,o){const r=n.tags.find((t=>(!0===t.default||e&&"key"===t.default)&&t.test?.test(s)))||n[c];if(n.compat){const e=n.compat.find((e=>e.default&&e.test?.test(s)))??n[c];if(r.tag!==e.tag){o(i,"TAG_RESOLVE_FAILED",`Value may be parsed as either ${t.tagString(r.tag)} or ${t.tagString(e.tag)}`,!0)}}return r}(e,i,t,s):e.schema[c];try{const o=p.resolve(i,(e=>s(n??t,"TAG_RESOLVE_FAILED",e)),e.options);d=m(o)?o:new K(o)}catch(f){const e=f instanceof Error?f.message:String(f);s(n??t,"TAG_RESOLVE_FAILED",e),d=new K(i)}return d.range=a,d.source=i,o&&(d.type=o),l&&(d.tag=l),p.format&&(d.format=p.format),r&&(d.comment=r),d}function Wt(e,t,n){if(t){n??(n=t.length);for(let s=n-1;s>=0;--s){let n=t[s];switch(n.type){case"space":case"comment":case"newline":e-=n.source.length;continue}for(n=t[++s];"space"===n?.type;)e+=n.source.length,n=t[++s];break}}return e}const Jt={composeNode:Ht,composeEmptyNode:Gt};function Ht(e,t,n,s){const i=e.atKey,{spaceBefore:o,comment:r,anchor:a,tag:c}=n;let l,p=!0;switch(t.type){case"alias":l=function({options:e},{offset:t,source:n,end:s},i){const o=new D(n.substring(1));""===o.source&&i(t,"BAD_ALIAS","Alias cannot be an empty string");o.source.endsWith(":")&&i(t+n.length-1,"BAD_ALIAS","Alias ending in : is ambiguous",!0);const r=t+n.length,a=qt(s,r,e.strict,i);o.range=[t,r,a.offset],a.comment&&(o.comment=a.comment);return o}(e,t,s),(a||c)&&s(t,"ALIAS_PROPS","An alias node must not specify any properties");break;case"scalar":case"single-quoted-scalar":case"double-quoted-scalar":case"block-scalar":l=Vt(e,t,c,s),a&&(l.anchor=a.source.substring(1));break;case"block-map":case"block-seq":case"flow-collection":l=function(e,t,n,s,i){const o=s.tag,r=o?t.directives.tagName(o.source,(e=>i(o,"TAG_RESOLVE_FAILED",e))):null;if("block-seq"===n.type){const{anchor:e,newlineAfterProp:t}=s,n=e&&o?e.offset>o.offset?e:o:e??o;n&&(!t||t.offset<n.offset)&&i(n,"MISSING_CHAR","Missing newline after block sequence props")}const a="block-map"===n.type?"map":"block-seq"===n.type?"seq":"{"===n.start.source?"map":"seq";if(!o||!r||"!"===r||r===$e.tagName&&"map"===a||r===Se.tagName&&"seq"===a)return Dt(e,t,n,i,r);let c=t.schema.tags.find((e=>e.tag===r&&e.collection===a));if(!c){const s=t.schema.knownTags[r];if(s?.collection!==a)return s?i(o,"BAD_COLLECTION_TYPE",`${s.tag} used for ${a} collection, but expects ${s.collection??"scalar"}`,!0):i(o,"TAG_RESOLVE_FAILED",`Unresolved tag: ${r}`,!0),Dt(e,t,n,i,r);t.schema.tags.push(Object.assign({},s,{default:!1})),c=s}const l=Dt(e,t,n,i,r,c),p=c.resolve?.(l,(e=>i(o,"TAG_RESOLVE_FAILED",e)),t.options)??l,d=b(p)?p:new K(p);return d.range=l.range,d.tag=r,c?.format&&(d.format=c.format),d}(Jt,e,t,n,s),a&&(l.anchor=a.source.substring(1));break;default:s(t,"UNEXPECTED_TOKEN","error"===t.type?t.message:`Unsupported token (type: ${t.type})`),l=Gt(e,t.offset,void 0,null,n,s),p=!1}if(a&&""===l.anchor&&s(a,"BAD_ALIAS","Anchor cannot be an empty string"),i&&e.options.stringKeys&&(!m(l)||"string"!=typeof l.value||l.tag&&"tag:yaml.org,2002:str"!==l.tag)){s(c??t,"NON_STRING_KEY","With stringKeys, all keys must be strings")}return o&&(l.spaceBefore=!0),r&&("scalar"===t.type&&""===t.source?l.comment=r:l.commentBefore=r),e.options.keepSourceTokens&&p&&(l.srcToken=t),l}function Gt(e,t,n,s,{spaceBefore:i,comment:o,anchor:r,tag:a,end:c},l){const p=Vt(e,{type:"scalar",offset:Wt(t,n,s),indent:-1,source:""},a,l);return r&&(p.anchor=r.source.substring(1),""===p.anchor&&l(r,"BAD_ALIAS","Anchor cannot be an empty string")),i&&(p.spaceBefore=!0),o&&(p.comment=o,p.range[2]=c),p}function Yt(e){if("number"==typeof e)return[e,e+1];if(Array.isArray(e))return 2===e.length?e:[e[0],e[1]];const{offset:t,source:n}=e;return[t,t+("string"==typeof n?n.length:1)]}function Qt(e){let t="",n=!1,s=!1;for(let i=0;i<e.length;++i){const o=e[i];switch(o[0]){case"#":t+=(""===t?"":s?"\n\n":"\n")+(o.substring(1)||" "),n=!0,s=!1;break;case"%":"#"!==e[i+1]?.[0]&&(i+=1),n=!1;break;default:n||(s=!0),n=!1}}return{comment:t,afterEmptyLine:s}}class Xt{constructor(e={}){this.doc=null,this.atDirectives=!1,this.prelude=[],this.errors=[],this.warnings=[],this.onError=(e,t,n,s)=>{const i=Yt(e);s?this.warnings.push(new Et(i,t,n)):this.errors.push(new Nt(i,t,n))},this.directives=new I({version:e.version||"1.2"}),this.options=e}decorate(e,t){const{comment:n,afterEmptyLine:s}=Qt(this.prelude);if(n){const i=e.contents;if(t)e.comment=e.comment?`${e.comment}\n${n}`:n;else if(s||e.directives.docStart||!i)e.commentBefore=n;else if(y(i)&&!i.flow&&i.items.length>0){let e=i.items[0];u(e)&&(e=e.key);const t=e.commentBefore;e.commentBefore=t?`${n}\n${t}`:n}else{const e=i.commentBefore;i.commentBefore=e?`${n}\n${e}`:n}}t?(Array.prototype.push.apply(e.errors,this.errors),Array.prototype.push.apply(e.warnings,this.warnings)):(e.errors=this.errors,e.warnings=this.warnings),this.prelude=[],this.errors=[],this.warnings=[]}streamInfo(){return{comment:Qt(this.prelude).comment,directives:this.directives,errors:this.errors,warnings:this.warnings}}*compose(e,t=!1,n=-1){for(const s of e)yield*this.next(s);yield*this.end(t,n)}*next(e){switch(e.type){case"directive":this.directives.add(e.source,((t,n,s)=>{const i=Yt(e);i[0]+=t,this.onError(i,"BAD_DIRECTIVE",n,s)})),this.prelude.push(e.source),this.atDirectives=!0;break;case"document":{const t=function(e,t,{offset:n,start:s,value:i,end:o},r){const a=Object.assign({_directives:t},e),c=new jt(void 0,a),l={atKey:!1,atRoot:!0,directives:c.directives,options:c.options,schema:c.schema},p=Tt(s,{indicator:"doc-start",next:i??o?.[0],offset:n,onError:r,parentIndent:0,startOnNewline:!0});p.found&&(c.directives.docStart=!0,!i||"block-map"!==i.type&&"block-seq"!==i.type||p.hasNewline||r(p.end,"MISSING_CHAR","Block collection cannot start on same line with directives-end marker")),c.contents=i?Ht(l,i,p,r):Gt(l,p.end,s,null,p,r);const d=c.contents.range[2],f=qt(o,d,!1,r);return f.comment&&(c.comment=f.comment),c.range=[n,d,f.offset],c}(this.options,this.directives,e,this.onError);this.atDirectives&&!t.directives.docStart&&this.onError(e,"MISSING_CHAR","Missing directives-end/doc-start indicator line"),this.decorate(t,!1),this.doc&&(yield this.doc),this.doc=t,this.atDirectives=!1;break}case"byte-order-mark":case"space":break;case"comment":case"newline":this.prelude.push(e.source);break;case"error":{const t=e.source?`${e.message}: ${JSON.stringify(e.source)}`:e.message,n=new Nt(Yt(e),"UNEXPECTED_TOKEN",t);this.atDirectives||!this.doc?this.errors.push(n):this.doc.errors.push(n);break}case"doc-end":{if(!this.doc){const t="Unexpected doc-end without preceding document";this.errors.push(new Nt(Yt(e),"UNEXPECTED_TOKEN",t));break}this.doc.directives.docEnd=!0;const t=qt(e.end,e.offset+e.source.length,this.doc.options.strict,this.onError);if(this.decorate(this.doc,!0),t.comment){const e=this.doc.comment;this.doc.comment=e?`${e}\n${t.comment}`:t.comment}this.doc.range[2]=t.offset;break}default:this.errors.push(new Nt(Yt(e),"UNEXPECTED_TOKEN",`Unsupported token ${e.type}`))}}*end(e=!1,t=-1){if(this.doc)this.decorate(this.doc,!0),yield this.doc,this.doc=null;else if(e){const e=Object.assign({_directives:this.directives},this.options),n=new jt(void 0,e);this.atDirectives&&this.onError(t,"MISSING_CHAR","Missing directives-end indicator line"),n.range=[0,t,t],this.decorate(n,!1),yield n}}}const Zt=Symbol("break visit"),en=Symbol("skip children"),tn=Symbol("remove item");function nn(e,t){"type"in e&&"document"===e.type&&(e={start:e.start,value:e.value}),sn(Object.freeze([]),e,t)}function sn(e,t,n){let s=n(t,e);if("symbol"==typeof s)return s;for(const i of["key","value"]){const o=t[i];if(o&&"items"in o){for(let t=0;t<o.items.length;++t){const s=sn(Object.freeze(e.concat([[i,t]])),o.items[t],n);if("number"==typeof s)t=s-1;else{if(s===Zt)return Zt;s===tn&&(o.items.splice(t,1),t-=1)}}"function"==typeof s&&"key"===i&&(s=s(t,e))}}return"function"==typeof s?s(t,e):s}nn.BREAK=Zt,nn.SKIP=en,nn.REMOVE=tn,nn.itemAtPath=(e,t)=>{let n=e;for(const[s,i]of t){const e=n?.[s];if(!e||!("items"in e))return;n=e.items[i]}return n},nn.parentCollection=(e,t)=>{const n=nn.itemAtPath(e,t.slice(0,-1)),s=t[t.length-1][0],i=n?.[s];if(i&&"items"in i)return i;throw new Error("Parent collection not found")};const on="\x1f";function rn(e){switch(e){case void 0:case" ":case"\n":case"\r":case"\t":return!0;default:return!1}}const an=new Set("0123456789ABCDEFabcdef"),cn=new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()"),ln=new Set(",[]{}"),pn=new Set(" ,[]{}\n\r\t"),dn=e=>!e||pn.has(e);class fn{constructor(){this.atEnd=!1,this.blockScalarIndent=-1,this.blockScalarKeep=!1,this.buffer="",this.flowKey=!1,this.flowLevel=0,this.indentNext=0,this.indentValue=0,this.lineEndPos=null,this.next=null,this.pos=0}*lex(e,t=!1){if(e){if("string"!=typeof e)throw TypeError("source is not a string");this.buffer=this.buffer?this.buffer+e:e,this.lineEndPos=null}this.atEnd=!t;let n=this.next??"stream";for(;n&&(t||this.hasChars(1));)n=yield*this.parseNext(n)}atLineEnd(){let e=this.pos,t=this.buffer[e];for(;" "===t||"\t"===t;)t=this.buffer[++e];return!t||"#"===t||"\n"===t||"\r"===t&&"\n"===this.buffer[e+1]}charAt(e){return this.buffer[this.pos+e]}continueScalar(e){let t=this.buffer[e];if(this.indentNext>0){let n=0;for(;" "===t;)t=this.buffer[++n+e];if("\r"===t){const t=this.buffer[n+e+1];if("\n"===t||!t&&!this.atEnd)return e+n+1}return"\n"===t||n>=this.indentNext||!t&&!this.atEnd?e+n:-1}if("-"===t||"."===t){const t=this.buffer.substr(e,3);if(("---"===t||"..."===t)&&rn(this.buffer[e+3]))return-1}return e}getLine(){let e=this.lineEndPos;return("number"!=typeof e||-1!==e&&e<this.pos)&&(e=this.buffer.indexOf("\n",this.pos),this.lineEndPos=e),-1===e?this.atEnd?this.buffer.substring(this.pos):null:("\r"===this.buffer[e-1]&&(e-=1),this.buffer.substring(this.pos,e))}hasChars(e){return this.pos+e<=this.buffer.length}setNext(e){return this.buffer=this.buffer.substring(this.pos),this.pos=0,this.lineEndPos=null,this.next=e,null}peek(e){return this.buffer.substr(this.pos,e)}*parseNext(e){switch(e){case"stream":return yield*this.parseStream();case"line-start":return yield*this.parseLineStart();case"block-start":return yield*this.parseBlockStart();case"doc":return yield*this.parseDocument();case"flow":return yield*this.parseFlowCollection();case"quoted-scalar":return yield*this.parseQuotedScalar();case"block-scalar":return yield*this.parseBlockScalar();case"plain-scalar":return yield*this.parsePlainScalar()}}*parseStream(){let e=this.getLine();if(null===e)return this.setNext("stream");if("\ufeff"===e[0]&&(yield*this.pushCount(1),e=e.substring(1)),"%"===e[0]){let t=e.length,n=e.indexOf("#");for(;-1!==n;){const s=e[n-1];if(" "===s||"\t"===s){t=n-1;break}n=e.indexOf("#",n+1)}for(;;){const n=e[t-1];if(" "!==n&&"\t"!==n)break;t-=1}const s=(yield*this.pushCount(t))+(yield*this.pushSpaces(!0));return yield*this.pushCount(e.length-s),this.pushNewline(),"stream"}if(this.atLineEnd()){const t=yield*this.pushSpaces(!0);return yield*this.pushCount(e.length-t),yield*this.pushNewline(),"stream"}return yield"\x02",yield*this.parseLineStart()}*parseLineStart(){const e=this.charAt(0);if(!e&&!this.atEnd)return this.setNext("line-start");if("-"===e||"."===e){if(!this.atEnd&&!this.hasChars(4))return this.setNext("line-start");const e=this.peek(3);if(("---"===e||"..."===e)&&rn(this.charAt(3)))return yield*this.pushCount(3),this.indentValue=0,this.indentNext=0,"---"===e?"doc":"stream"}return this.indentValue=yield*this.pushSpaces(!1),this.indentNext>this.indentValue&&!rn(this.charAt(1))&&(this.indentNext=this.indentValue),yield*this.parseBlockStart()}*parseBlockStart(){const[e,t]=this.peek(2);if(!t&&!this.atEnd)return this.setNext("block-start");if(("-"===e||"?"===e||":"===e)&&rn(t)){const e=(yield*this.pushCount(1))+(yield*this.pushSpaces(!0));return this.indentNext=this.indentValue+1,this.indentValue+=e,yield*this.parseBlockStart()}return"doc"}*parseDocument(){yield*this.pushSpaces(!0);const e=this.getLine();if(null===e)return this.setNext("doc");let t=yield*this.pushIndicators();switch(e[t]){case"#":yield*this.pushCount(e.length-t);case void 0:return yield*this.pushNewline(),yield*this.parseLineStart();case"{":case"[":return yield*this.pushCount(1),this.flowKey=!1,this.flowLevel=1,"flow";case"}":case"]":return yield*this.pushCount(1),"doc";case"*":return yield*this.pushUntil(dn),"doc";case'"':case"'":return yield*this.parseQuotedScalar();case"|":case">":return t+=(yield*this.parseBlockScalarHeader()),t+=(yield*this.pushSpaces(!0)),yield*this.pushCount(e.length-t),yield*this.pushNewline(),yield*this.parseBlockScalar();default:return yield*this.parsePlainScalar()}}*parseFlowCollection(){let e,t,n=-1;do{e=yield*this.pushNewline(),e>0?(t=yield*this.pushSpaces(!1),this.indentValue=n=t):t=0,t+=(yield*this.pushSpaces(!0))}while(e+t>0);const s=this.getLine();if(null===s)return this.setNext("flow");if(-1!==n&&n<this.indentNext&&"#"!==s[0]||0===n&&(s.startsWith("---")||s.startsWith("..."))&&rn(s[3])){if(!(n===this.indentNext-1&&1===this.flowLevel&&("]"===s[0]||"}"===s[0])))return this.flowLevel=0,yield"\x18",yield*this.parseLineStart()}let i=0;for(;","===s[i];)i+=(yield*this.pushCount(1)),i+=(yield*this.pushSpaces(!0)),this.flowKey=!1;switch(i+=(yield*this.pushIndicators()),s[i]){case void 0:return"flow";case"#":return yield*this.pushCount(s.length-i),"flow";case"{":case"[":return yield*this.pushCount(1),this.flowKey=!1,this.flowLevel+=1,"flow";case"}":case"]":return yield*this.pushCount(1),this.flowKey=!0,this.flowLevel-=1,this.flowLevel?"flow":"doc";case"*":return yield*this.pushUntil(dn),"flow";case'"':case"'":return this.flowKey=!0,yield*this.parseQuotedScalar();case":":{const e=this.charAt(1);if(this.flowKey||rn(e)||","===e)return this.flowKey=!1,yield*this.pushCount(1),yield*this.pushSpaces(!0),"flow"}default:return this.flowKey=!1,yield*this.parsePlainScalar()}}*parseQuotedScalar(){const e=this.charAt(0);let t=this.buffer.indexOf(e,this.pos+1);if("'"===e)for(;-1!==t&&"'"===this.buffer[t+1];)t=this.buffer.indexOf("'",t+2);else for(;-1!==t;){let e=0;for(;"\\"===this.buffer[t-1-e];)e+=1;if(e%2==0)break;t=this.buffer.indexOf('"',t+1)}const n=this.buffer.substring(0,t);let s=n.indexOf("\n",this.pos);if(-1!==s){for(;-1!==s;){const e=this.continueScalar(s+1);if(-1===e)break;s=n.indexOf("\n",e)}-1!==s&&(t=s-("\r"===n[s-1]?2:1))}if(-1===t){if(!this.atEnd)return this.setNext("quoted-scalar");t=this.buffer.length}return yield*this.pushToIndex(t+1,!1),this.flowLevel?"flow":"doc"}*parseBlockScalarHeader(){this.blockScalarIndent=-1,this.blockScalarKeep=!1;let e=this.pos;for(;;){const t=this.buffer[++e];if("+"===t)this.blockScalarKeep=!0;else if(t>"0"&&t<="9")this.blockScalarIndent=Number(t)-1;else if("-"!==t)break}return yield*this.pushUntil((e=>rn(e)||"#"===e))}*parseBlockScalar(){let e,t=this.pos-1,n=0;e:for(let i=this.pos;e=this.buffer[i];++i)switch(e){case" ":n+=1;break;case"\n":t=i,n=0;break;case"\r":{const e=this.buffer[i+1];if(!e&&!this.atEnd)return this.setNext("block-scalar");if("\n"===e)break}default:break e}if(!e&&!this.atEnd)return this.setNext("block-scalar");if(n>=this.indentNext){-1===this.blockScalarIndent?this.indentNext=n:this.indentNext=this.blockScalarIndent+(0===this.indentNext?1:this.indentNext);do{const e=this.continueScalar(t+1);if(-1===e)break;t=this.buffer.indexOf("\n",e)}while(-1!==t);if(-1===t){if(!this.atEnd)return this.setNext("block-scalar");t=this.buffer.length}}let s=t+1;for(e=this.buffer[s];" "===e;)e=this.buffer[++s];if("\t"===e){for(;"\t"===e||" "===e||"\r"===e||"\n"===e;)e=this.buffer[++s];t=s-1}else if(!this.blockScalarKeep)for(;;){let e=t-1,s=this.buffer[e];"\r"===s&&(s=this.buffer[--e]);const i=e;for(;" "===s;)s=this.buffer[--e];if(!("\n"===s&&e>=this.pos&&e+1+n>i))break;t=e}return yield on,yield*this.pushToIndex(t+1,!0),yield*this.parseLineStart()}*parsePlainScalar(){const e=this.flowLevel>0;let t,n=this.pos-1,s=this.pos-1;for(;t=this.buffer[++s];)if(":"===t){const t=this.buffer[s+1];if(rn(t)||e&&ln.has(t))break;n=s}else if(rn(t)){let i=this.buffer[s+1];if("\r"===t&&("\n"===i?(s+=1,t="\n",i=this.buffer[s+1]):n=s),"#"===i||e&&ln.has(i))break;if("\n"===t){const e=this.continueScalar(s+1);if(-1===e)break;s=Math.max(s,e-2)}}else{if(e&&ln.has(t))break;n=s}return t||this.atEnd?(yield on,yield*this.pushToIndex(n+1,!0),e?"flow":"doc"):this.setNext("plain-scalar")}*pushCount(e){return e>0?(yield this.buffer.substr(this.pos,e),this.pos+=e,e):0}*pushToIndex(e,t){const n=this.buffer.slice(this.pos,e);return n?(yield n,this.pos+=n.length,n.length):(t&&(yield""),0)}*pushIndicators(){switch(this.charAt(0)){case"!":return(yield*this.pushTag())+(yield*this.pushSpaces(!0))+(yield*this.pushIndicators());case"&":return(yield*this.pushUntil(dn))+(yield*this.pushSpaces(!0))+(yield*this.pushIndicators());case"-":case"?":case":":{const e=this.flowLevel>0,t=this.charAt(1);if(rn(t)||e&&ln.has(t))return e?this.flowKey&&(this.flowKey=!1):this.indentNext=this.indentValue+1,(yield*this.pushCount(1))+(yield*this.pushSpaces(!0))+(yield*this.pushIndicators())}}return 0}*pushTag(){if("<"===this.charAt(1)){let e=this.pos+2,t=this.buffer[e];for(;!rn(t)&&">"!==t;)t=this.buffer[++e];return yield*this.pushToIndex(">"===t?e+1:e,!1)}{let e=this.pos+1,t=this.buffer[e];for(;t;)if(cn.has(t))t=this.buffer[++e];else{if("%"!==t||!an.has(this.buffer[e+1])||!an.has(this.buffer[e+2]))break;t=this.buffer[e+=3]}return yield*this.pushToIndex(e,!1)}}*pushNewline(){const e=this.buffer[this.pos];return"\n"===e?yield*this.pushCount(1):"\r"===e&&"\n"===this.charAt(1)?yield*this.pushCount(2):0}*pushSpaces(e){let t,n=this.pos-1;do{t=this.buffer[++n]}while(" "===t||e&&"\t"===t);const s=n-this.pos;return s>0&&(yield this.buffer.substr(this.pos,s),this.pos=n),s}*pushUntil(e){let t=this.pos,n=this.buffer[t];for(;!e(n);)n=this.buffer[++t];return yield*this.pushToIndex(t,!1)}}function hn(e,t){for(let n=0;n<e.length;++n)if(e[n].type===t)return!0;return!1}function un(e){for(let t=0;t<e.length;++t)switch(e[t].type){case"space":case"comment":case"newline":break;default:return t}return-1}function mn(e){switch(e?.type){case"alias":case"scalar":case"single-quoted-scalar":case"double-quoted-scalar":case"flow-collection":return!0;default:return!1}}function gn(e){switch(e.type){case"document":return e.start;case"block-map":{const t=e.items[e.items.length-1];return t.sep??t.start}case"block-seq":return e.items[e.items.length-1].start;default:return[]}}function yn(e){if(0===e.length)return[];let t=e.length;e:for(;--t>=0;)switch(e[t].type){case"doc-start":case"explicit-key-ind":case"map-value-ind":case"seq-item-ind":case"newline":break e}for(;"space"===e[++t]?.type;);return e.splice(t,e.length)}function bn(e){if("flow-seq-start"===e.start.type)for(const t of e.items)!t.sep||t.value||hn(t.start,"explicit-key-ind")||hn(t.sep,"map-value-ind")||(t.key&&(t.value=t.key),delete t.key,mn(t.value)?t.value.end?Array.prototype.push.apply(t.value.end,t.sep):t.value.end=t.sep:Array.prototype.push.apply(t.start,t.sep),delete t.sep)}class vn{constructor(e){this.atNewLine=!0,this.atScalar=!1,this.indent=0,this.offset=0,this.onKeyLine=!1,this.stack=[],this.source="",this.type="",this.lexer=new fn,this.onNewLine=e}*parse(e,t=!1){this.onNewLine&&0===this.offset&&this.onNewLine(0);for(const n of this.lexer.lex(e,t))yield*this.next(n);t||(yield*this.end())}*next(e){if(this.source=e,this.atScalar)return this.atScalar=!1,yield*this.step(),void(this.offset+=e.length);const t=function(e){switch(e){case"\ufeff":return"byte-order-mark";case"\x02":return"doc-mode";case"\x18":return"flow-error-end";case on:return"scalar";case"---":return"doc-start";case"...":return"doc-end";case"":case"\n":case"\r\n":return"newline";case"-":return"seq-item-ind";case"?":return"explicit-key-ind";case":":return"map-value-ind";case"{":return"flow-map-start";case"}":return"flow-map-end";case"[":return"flow-seq-start";case"]":return"flow-seq-end";case",":return"comma"}switch(e[0]){case" ":case"\t":return"space";case"#":return"comment";case"%":return"directive-line";case"*":return"alias";case"&":return"anchor";case"!":return"tag";case"'":return"single-quoted-scalar";case'"':return"double-quoted-scalar";case"|":case">":return"block-scalar-header"}return null}(e);if(t)if("scalar"===t)this.atNewLine=!1,this.atScalar=!0,this.type="scalar";else{switch(this.type=t,yield*this.step(),t){case"newline":this.atNewLine=!0,this.indent=0,this.onNewLine&&this.onNewLine(this.offset+e.length);break;case"space":this.atNewLine&&" "===e[0]&&(this.indent+=e.length);break;case"explicit-key-ind":case"map-value-ind":case"seq-item-ind":this.atNewLine&&(this.indent+=e.length);break;case"doc-mode":case"flow-error-end":return;default:this.atNewLine=!1}this.offset+=e.length}else{const t=`Not a YAML token: ${e}`;yield*this.pop({type:"error",offset:this.offset,message:t,source:e}),this.offset+=e.length}}*end(){for(;this.stack.length>0;)yield*this.pop()}get sourceToken(){return{type:this.type,offset:this.offset,indent:this.indent,source:this.source}}*step(){const e=this.peek(1);if("doc-end"!==this.type||"doc-end"===e?.type){if(!e)return yield*this.stream();switch(e.type){case"document":return yield*this.document(e);case"alias":case"scalar":case"single-quoted-scalar":case"double-quoted-scalar":return yield*this.scalar(e);case"block-scalar":return yield*this.blockScalar(e);case"block-map":return yield*this.blockMap(e);case"block-seq":return yield*this.blockSequence(e);case"flow-collection":return yield*this.flowCollection(e);case"doc-end":return yield*this.documentEnd(e)}yield*this.pop()}else{for(;this.stack.length>0;)yield*this.pop();this.stack.push({type:"doc-end",offset:this.offset,source:this.source})}}peek(e){return this.stack[this.stack.length-e]}*pop(e){const t=e??this.stack.pop();if(t)if(0===this.stack.length)yield t;else{const e=this.peek(1);switch("block-scalar"===t.type?t.indent="indent"in e?e.indent:0:"flow-collection"===t.type&&"document"===e.type&&(t.indent=0),"flow-collection"===t.type&&bn(t),e.type){case"document":e.value=t;break;case"block-scalar":e.props.push(t);break;case"block-map":{const n=e.items[e.items.length-1];if(n.value)return e.items.push({start:[],key:t,sep:[]}),void(this.onKeyLine=!0);if(!n.sep)return Object.assign(n,{key:t,sep:[]}),void(this.onKeyLine=!n.explicitKey);n.value=t;break}case"block-seq":{const n=e.items[e.items.length-1];n.value?e.items.push({start:[],value:t}):n.value=t;break}case"flow-collection":{const n=e.items[e.items.length-1];return void(!n||n.value?e.items.push({start:[],key:t,sep:[]}):n.sep?n.value=t:Object.assign(n,{key:t,sep:[]}))}default:yield*this.pop(),yield*this.pop(t)}if(!("document"!==e.type&&"block-map"!==e.type&&"block-seq"!==e.type||"block-map"!==t.type&&"block-seq"!==t.type)){const n=t.items[t.items.length-1];n&&!n.sep&&!n.value&&n.start.length>0&&-1===un(n.start)&&(0===t.indent||n.start.every((e=>"comment"!==e.type||e.indent<t.indent)))&&("document"===e.type?e.end=n.start:e.items.push({start:n.start}),t.items.splice(-1,1))}}else{const e="Tried to pop an empty stack";yield{type:"error",offset:this.offset,source:"",message:e}}}*stream(){switch(this.type){case"directive-line":return void(yield{type:"directive",offset:this.offset,source:this.source});case"byte-order-mark":case"space":case"comment":case"newline":return void(yield this.sourceToken);case"doc-mode":case"doc-start":{const e={type:"document",offset:this.offset,start:[]};return"doc-start"===this.type&&e.start.push(this.sourceToken),void this.stack.push(e)}}yield{type:"error",offset:this.offset,message:`Unexpected ${this.type} token in YAML stream`,source:this.source}}*document(e){if(e.value)return yield*this.lineEnd(e);switch(this.type){case"doc-start":return void(-1!==un(e.start)?(yield*this.pop(),yield*this.step()):e.start.push(this.sourceToken));case"anchor":case"tag":case"space":case"comment":case"newline":return void e.start.push(this.sourceToken)}const t=this.startBlockValue(e);t?this.stack.push(t):yield{type:"error",offset:this.offset,message:`Unexpected ${this.type} token in YAML document`,source:this.source}}*scalar(e){if("map-value-ind"===this.type){const t=yn(gn(this.peek(2)));let n;e.end?(n=e.end,n.push(this.sourceToken),delete e.end):n=[this.sourceToken];const s={type:"block-map",offset:e.offset,indent:e.indent,items:[{start:t,key:e,sep:n}]};this.onKeyLine=!0,this.stack[this.stack.length-1]=s}else yield*this.lineEnd(e)}*blockScalar(e){switch(this.type){case"space":case"comment":case"newline":return void e.props.push(this.sourceToken);case"scalar":if(e.source=this.source,this.atNewLine=!0,this.indent=0,this.onNewLine){let e=this.source.indexOf("\n")+1;for(;0!==e;)this.onNewLine(this.offset+e),e=this.source.indexOf("\n",e)+1}yield*this.pop();break;default:yield*this.pop(),yield*this.step()}}*blockMap(e){const t=e.items[e.items.length-1];switch(this.type){case"newline":if(this.onKeyLine=!1,t.value){const n="end"in t.value?t.value.end:void 0,s=Array.isArray(n)?n[n.length-1]:void 0;"comment"===s?.type?n?.push(this.sourceToken):e.items.push({start:[this.sourceToken]})}else t.sep?t.sep.push(this.sourceToken):t.start.push(this.sourceToken);return;case"space":case"comment":if(t.value)e.items.push({start:[this.sourceToken]});else if(t.sep)t.sep.push(this.sourceToken);else{if(this.atIndentedComment(t.start,e.indent)){const n=e.items[e.items.length-2],s=n?.value?.end;if(Array.isArray(s))return Array.prototype.push.apply(s,t.start),s.push(this.sourceToken),void e.items.pop()}t.start.push(this.sourceToken)}return}if(this.indent>=e.indent){const n=!this.onKeyLine&&this.indent===e.indent,s=n&&(t.sep||t.explicitKey)&&"seq-item-ind"!==this.type;let i=[];if(s&&t.sep&&!t.value){const n=[];for(let s=0;s<t.sep.length;++s){const i=t.sep[s];switch(i.type){case"newline":n.push(s);break;case"space":break;case"comment":i.indent>e.indent&&(n.length=0);break;default:n.length=0}}n.length>=2&&(i=t.sep.splice(n[1]))}switch(this.type){case"anchor":case"tag":return void(s||t.value?(i.push(this.sourceToken),e.items.push({start:i}),this.onKeyLine=!0):t.sep?t.sep.push(this.sourceToken):t.start.push(this.sourceToken));case"explicit-key-ind":return t.sep||t.explicitKey?s||t.value?(i.push(this.sourceToken),e.items.push({start:i,explicitKey:!0})):this.stack.push({type:"block-map",offset:this.offset,indent:this.indent,items:[{start:[this.sourceToken],explicitKey:!0}]}):(t.start.push(this.sourceToken),t.explicitKey=!0),void(this.onKeyLine=!0);case"map-value-ind":if(t.explicitKey)if(t.sep)if(t.value)e.items.push({start:[],key:null,sep:[this.sourceToken]});else if(hn(t.sep,"map-value-ind"))this.stack.push({type:"block-map",offset:this.offset,indent:this.indent,items:[{start:i,key:null,sep:[this.sourceToken]}]});else if(mn(t.key)&&!hn(t.sep,"newline")){const e=yn(t.start),n=t.key,s=t.sep;s.push(this.sourceToken),delete t.key,delete t.sep,this.stack.push({type:"block-map",offset:this.offset,indent:this.indent,items:[{start:e,key:n,sep:s}]})}else i.length>0?t.sep=t.sep.concat(i,this.sourceToken):t.sep.push(this.sourceToken);else if(hn(t.start,"newline"))Object.assign(t,{key:null,sep:[this.sourceToken]});else{const e=yn(t.start);this.stack.push({type:"block-map",offset:this.offset,indent:this.indent,items:[{start:e,key:null,sep:[this.sourceToken]}]})}else t.sep?t.value||s?e.items.push({start:i,key:null,sep:[this.sourceToken]}):hn(t.sep,"map-value-ind")?this.stack.push({type:"block-map",offset:this.offset,indent:this.indent,items:[{start:[],key:null,sep:[this.sourceToken]}]}):t.sep.push(this.sourceToken):Object.assign(t,{key:null,sep:[this.sourceToken]});return void(this.onKeyLine=!0);case"alias":case"scalar":case"single-quoted-scalar":case"double-quoted-scalar":{const n=this.flowScalar(this.type);return void(s||t.value?(e.items.push({start:i,key:n,sep:[]}),this.onKeyLine=!0):t.sep?this.stack.push(n):(Object.assign(t,{key:n,sep:[]}),this.onKeyLine=!0))}default:{const s=this.startBlockValue(e);if(s){if("block-seq"===s.type){if(!t.explicitKey&&t.sep&&!hn(t.sep,"newline"))return void(yield*this.pop({type:"error",offset:this.offset,message:"Unexpected block-seq-ind on same line with key",source:this.source}))}else n&&e.items.push({start:i});return void this.stack.push(s)}}}}yield*this.pop(),yield*this.step()}*blockSequence(e){const t=e.items[e.items.length-1];switch(this.type){case"newline":if(t.value){const n="end"in t.value?t.value.end:void 0,s=Array.isArray(n)?n[n.length-1]:void 0;"comment"===s?.type?n?.push(this.sourceToken):e.items.push({start:[this.sourceToken]})}else t.start.push(this.sourceToken);return;case"space":case"comment":if(t.value)e.items.push({start:[this.sourceToken]});else{if(this.atIndentedComment(t.start,e.indent)){const n=e.items[e.items.length-2],s=n?.value?.end;if(Array.isArray(s))return Array.prototype.push.apply(s,t.start),s.push(this.sourceToken),void e.items.pop()}t.start.push(this.sourceToken)}return;case"anchor":case"tag":if(t.value||this.indent<=e.indent)break;return void t.start.push(this.sourceToken);case"seq-item-ind":if(this.indent!==e.indent)break;return void(t.value||hn(t.start,"seq-item-ind")?e.items.push({start:[this.sourceToken]}):t.start.push(this.sourceToken))}if(this.indent>e.indent){const t=this.startBlockValue(e);if(t)return void this.stack.push(t)}yield*this.pop(),yield*this.step()}*flowCollection(e){const t=e.items[e.items.length-1];if("flow-error-end"===this.type){let e;do{yield*this.pop(),e=this.peek(1)}while("flow-collection"===e?.type)}else if(0===e.end.length){switch(this.type){case"comma":case"explicit-key-ind":return void(!t||t.sep?e.items.push({start:[this.sourceToken]}):t.start.push(this.sourceToken));case"map-value-ind":return void(!t||t.value?e.items.push({start:[],key:null,sep:[this.sourceToken]}):t.sep?t.sep.push(this.sourceToken):Object.assign(t,{key:null,sep:[this.sourceToken]}));case"space":case"comment":case"newline":case"anchor":case"tag":return void(!t||t.value?e.items.push({start:[this.sourceToken]}):t.sep?t.sep.push(this.sourceToken):t.start.push(this.sourceToken));case"alias":case"scalar":case"single-quoted-scalar":case"double-quoted-scalar":{const n=this.flowScalar(this.type);return void(!t||t.value?e.items.push({start:[],key:n,sep:[]}):t.sep?this.stack.push(n):Object.assign(t,{key:n,sep:[]}))}case"flow-map-end":case"flow-seq-end":return void e.end.push(this.sourceToken)}const n=this.startBlockValue(e);n?this.stack.push(n):(yield*this.pop(),yield*this.step())}else{const t=this.peek(2);if("block-map"===t.type&&("map-value-ind"===this.type&&t.indent===e.indent||"newline"===this.type&&!t.items[t.items.length-1].sep))yield*this.pop(),yield*this.step();else if("map-value-ind"===this.type&&"flow-collection"!==t.type){const n=yn(gn(t));bn(e);const s=e.end.splice(1,e.end.length);s.push(this.sourceToken);const i={type:"block-map",offset:e.offset,indent:e.indent,items:[{start:n,key:e,sep:s}]};this.onKeyLine=!0,this.stack[this.stack.length-1]=i}else yield*this.lineEnd(e)}}flowScalar(e){if(this.onNewLine){let e=this.source.indexOf("\n")+1;for(;0!==e;)this.onNewLine(this.offset+e),e=this.source.indexOf("\n",e)+1}return{type:e,offset:this.offset,indent:this.indent,source:this.source}}startBlockValue(e){switch(this.type){case"alias":case"scalar":case"single-quoted-scalar":case"double-quoted-scalar":return this.flowScalar(this.type);case"block-scalar-header":return{type:"block-scalar",offset:this.offset,indent:this.indent,props:[this.sourceToken],source:""};case"flow-map-start":case"flow-seq-start":return{type:"flow-collection",offset:this.offset,indent:this.indent,start:this.sourceToken,items:[],end:[]};case"seq-item-ind":return{type:"block-seq",offset:this.offset,indent:this.indent,items:[{start:[this.sourceToken]}]};case"explicit-key-ind":{this.onKeyLine=!0;const t=yn(gn(e));return t.push(this.sourceToken),{type:"block-map",offset:this.offset,indent:this.indent,items:[{start:t,explicitKey:!0}]}}case"map-value-ind":{this.onKeyLine=!0;const t=yn(gn(e));return{type:"block-map",offset:this.offset,indent:this.indent,items:[{start:t,key:null,sep:[this.sourceToken]}]}}}return null}atIndentedComment(e,t){return"comment"===this.type&&(!(this.indent<=t)&&e.every((e=>"newline"===e.type||"space"===e.type)))}*documentEnd(e){"doc-mode"!==this.type&&(e.end?e.end.push(this.sourceToken):e.end=[this.sourceToken],"newline"===this.type&&(yield*this.pop()))}*lineEnd(e){switch(this.type){case"comma":case"doc-start":case"doc-end":case"flow-seq-end":case"flow-map-end":case"map-value-ind":yield*this.pop(),yield*this.step();break;case"newline":this.onKeyLine=!1;default:e.end?e.end.push(this.sourceToken):e.end=[this.sourceToken],"newline"===this.type&&(yield*this.pop())}}}class kn{constructor(){this.lineStarts=[],this.addNewLine=e=>this.lineStarts.push(e),this.linePos=e=>{let t=0,n=this.lineStarts.length;for(;t<n;){const s=t+n>>1;this.lineStarts[s]<e?t=s+1:n=s}if(this.lineStarts[t]===e)return{line:t+1,col:1};if(0===t)return{line:0,col:e};return{line:t,col:e-this.lineStarts[t-1]+1}}}}function wn(e){const t=!1!==e.prettyErrors;return{lineCounter:e.lineCounter||t&&new kn||null,prettyErrors:t}}function xn(e,t={}){const{lineCounter:n,prettyErrors:s}=wn(t),i=new vn(n?.addNewLine),o=new Xt(t);let r=null;for(const a of o.compose(i.parse(e),!0,e.length))if(r){if("silent"!==r.options.logLevel){r.errors.push(new Nt(a.range.slice(0,2),"MULTIPLE_DOCS","Source contains multiple documents; please use YAML.parseAllDocuments()"));break}}else r=a;return s&&n&&(r.errors.forEach(Ot(e,n)),r.warnings.forEach(Ot(e,n))),r}function $n(e,t,n){let s;"function"==typeof t?s=t:void 0===n&&t&&"object"==typeof t&&(n=t);const i=xn(e,n);if(!i)return null;if(i.warnings.forEach((e=>pe(i.options.logLevel,e))),i.errors.length>0){if("silent"!==i.options.logLevel)throw i.errors[0];i.errors=[]}return i.toJS(Object.assign({reviver:s},n))}function jn(e,t,n){let s=null;if("function"==typeof t||Array.isArray(t)?s=t:void 0===n&&t&&(n=t),"string"==typeof n&&(n=n.length),"number"==typeof n){const e=Math.round(n);n=e<1?void 0:e>8?{indent:8}:{indent:e}}if(void 0===e){const{keepUndefined:e}=n??t??{};if(!e)return}return f(e)&&!s?e.toString(n):new jt(e,s,n).toString(n)}const Sn={"schema:ethdebug/format/data/hex":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/data/hex"\n\ntitle: ethdebug/format/data/hex\ndescription: |\n  A `0x`-prefixed hexadecimal string. This value **must** contain at least one\n  hexadecimal character (`0x` by itself is not allowed).\n\ntype: string\npattern: "^0x[0-9a-fA-F]{1,}$"\n\nexamples:\n  - "0x0000"\n  - "0x1"\n',"schema:ethdebug/format/data/unsigned":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/data/unsigned"\n\ntitle: ethdebug/format/data/unsigned\ndescription: |\n  A non-negative integer encoded as a JSON number.\n\ntype: integer\nminimum: 0\n\nexamples:\n  - 0\n  - 100\n',"schema:ethdebug/format/data/value":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/data/value"\n\ntitle: ethdebug/format/data/value\ndescription: |\n  A non-negative integer value, expressed either as a native JSON number or as\n  a `0x`-prefixed hexadecimal string.\n\noneOf:\n  - description: A non-negative integer literal\n    $ref: "schema:ethdebug/format/data/unsigned"\n\n  - description: |\n      A `0x`-prefixed hexadecimal string representing literal bytes or a number\n      commonly displayed in base 16 (e.g. bytecode instruction offsets).\n    $ref: "schema:ethdebug/format/data/hex"\n\nexamples:\n  - "0x0000"\n  - 2\n',"schema:ethdebug/format/info/resources":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/info/resources"\n\ntitle: ethdebug/format/info/resources\ndescription: |\n  An object containing lookup tables for finding debugging resources by name.\n\ntype: object\n\nproperties:\n  types:\n    title: Types by name\n    description: |\n      A collection of types by name identifier.\n    type: object\n    additionalProperties:\n      $ref: "schema:ethdebug/format/type"\n\n  pointers:\n    title: Pointer templates by name\n    description: |\n      A collection of pointer templates by name identifier.\n    type: object\n    additionalProperties:\n      $ref: "schema:ethdebug/format/pointer/template"\n\n  compilation:\n    $ref: "schema:ethdebug/format/materials/compilation"\n\nrequired:\n  - types\n  - pointers\n\nexamples:\n  - types:\n      "struct__Coordinate":\n        kind: struct\n        contains:\n          - name: x\n            type:\n              kind: uint\n              bits: 128\n          - name: y\n            type:\n              kind: uint\n              bits: 128\n        definition:\n          name: Coordinate\n          location:\n            source:\n              id: 5\n            range:\n              offset: 18\n              length: 55\n\n    pointers:\n      "struct__Coordinate__storage":\n        expect:\n          - contract_variable_slot__struct__Coordinate__storage\n        for:\n          group:\n            - name: member__x__struct__Coordinate__storage\n              location: storage\n              slot: contract_variable_slot__struct__Coordinate__storage\n              offset: 0\n              length: 128\n            - name: member__y__struct__Coordinate__storage\n              location: storage\n              slot: contract_variable_slot__struct__Coordinate__storage\n              offset:\n                $sum:\n                  - .offset: member__x__struct__Coordinate__storage\n                  - .length: member__x__struct__Coordinate__storage\n              length: 128\n',"schema:ethdebug/format/info":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/info"\n\ntitle: ethdebug/format/info\ndescription: |\n  Debugging information about a single compilation\n\ntype: object\n\n$ref: "schema:ethdebug/format/info/resources"\n\nproperties:\n  programs:\n    type: array\n    items:\n      $ref: "schema:ethdebug/format/program"\n    additionalItems: false\n\n  compilation:\n    $ref: "schema:ethdebug/format/materials/compilation"\n\nrequired:\n  - compilation\n  - programs\n\nexamples:\n  - compilation:\n      id: __301f3b6d85831638\n      compiler:\n        name: egc\n        version: 0.2.3+commit.8b37fa7a\n      settings:\n        turbo: true\n      sources:\n        - id: 1\n          path: "Escrow.eg"\n          language: examplelang\n          contents: |\n            import { Asset } from std::asset::fungible;\n\n            type State = !slots[\n              ready: bool,\n              complete: bool,\n\n              beneficiary: address,\n\n              asset: Asset,\n              amount: uint256,\n\n              canRemit: () -> bool,\n            ]\n\n            @create\n            func setup(\n              beneficiary: address,\n              asset: Asset,\n              canRemit: () -> bool,\n            ) -> State:\n              return {\n                ready = False,\n                complete = False,\n                beneficiary,\n                asset,\n                amount = 0,\n                canRemit,\n              }\n\n            @abi\n            @state(self: State)\n            @account(self)\n            func deposit(depositor: address, amount: uint256):\n              require(!self.ready)\n              require(!self.complete)\n\n              # expects an existing allowance (also known as "approval")\n              self.asset.transferFrom(depositor, self, amount)\n\n              self.amount = amount\n              self.ready = True\n\n            @abi\n            @state(self: State)\n            func remit():\n              require(self.ready)\n              require(!self.complete)\n\n              require(self.canRemit())\n\n              asset.transfer(self.beneficiary, self.amount)\n\n              self.complete = True\n\n    types:\n      # Define the State type structure\n      State:\n        kind: "struct"\n        contains:\n          - name: "ready"\n            type:\n              kind: "bool"\n          - name: "complete"\n            type:\n              kind: "bool"\n          - name: "beneficiary"\n            type:\n              kind: "address"\n          - name: "asset"\n            type:\n              kind: "struct"\n              contains:\n                - name: "address"\n                  type:\n                    kind: "address"\n          - name: "amount"\n            type:\n              kind: "uint"\n              bits: 256\n          - name: "canRemit"\n            type:\n              kind: "function"\n              internal: true\n              contains:\n                parameters:\n                  type:\n                    kind: "tuple"\n                    contains: []\n                returns:\n                  type:\n                    kind: "bool"\n\n    pointers:\n      # Define storage layout for the State struct\n      State_storage:\n        expect: ["slot"]\n        for:\n          group:\n            - name: "ready"\n              location: "storage"\n              slot: "slot"\n              offset: 0\n              length: 1\n            - name: "complete"\n              location: "storage"\n              slot: "slot"\n              offset: 1\n              length: 1\n            - name: "beneficiary"\n              location: "storage"\n              slot: { "$sum": ["slot", 1] }\n            - name: "asset"\n              location: "storage"\n              slot: { "$sum": ["slot", 2] }\n            - name: "amount"\n              location: "storage"\n              slot: { "$sum": ["slot", 3] }\n            - name: "canRemit"\n              location: "storage"\n              slot: { "$sum": ["slot", 4] }\n\n    programs:\n      - contract:\n          name: "Escrow"\n          definition:\n            source:\n              id: 1\n            range:\n              offset: 0\n              length: 891\n        environment: "create"\n        instructions:\n          - offset: 0\n            operation:\n              mnemonic: "PUSH1"\n              arguments: ["0x80"]\n            context:\n              code:\n                source:\n                  id: 1\n                range:\n                  offset: 891\n                  length: 20\n',"schema:ethdebug/format/materials/compilation":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/materials/compilation"\n\ntitle: ethdebug/format/materials/compilation\ndescription: |\n  An object representing a single invocation of a compiler.\n\ntype: object\nproperties:\n  id:\n    description: |\n      Compilation ID\n\n      This value **should** be globally-unique and generated only from the\n      compiler inputs (settings, sources, etc.); the same compiler inputs/\n      settings **should** produce the same identifier.\n\n    $ref: "schema:ethdebug/format/materials/id"\n\n  compiler:\n    type: object\n    title: Compiler name and version\n    properties:\n      name:\n        type: string\n        description: Compiler name\n\n      version:\n        type: string\n        description: |\n          Compiler version.\n\n          This value **should** be specified using the most detailed version\n          representation available, i.e., including source control hash and\n          compiler build information whenever possible.\n\n    required:\n      - name\n      - version\n\n    examples:\n      - name: lllc\n        version: 0.4.12-develop.2017.6.27+commit.b83f77e0.Linux.g++\n\n  settings:\n    description: |\n      Compiler settings in a format native to the compiler.\n\n      For compilers whose settings includes full source representations, this\n      field **should** be specified in such a way that avoids large data\n      redundancies (e.g. if compiler settings contain full source\n      representations, then this field would significantly duplicate the\n      information represented by the `sources` field in this object).\n\n      In situations where settings information duplicates information\n      represented elsewhere in **ethdebug/format**, compilers **may** adopt\n      any reasonable strategy, e.g.:\n        - omit duplications partially (leaving the rest of the settings\n          intact)\n        - omit this field entirely\n        - specify this field as a hash of the full settings\n          representation (with the expectation that users of this format will\n          have access to the full representation by some other means)\n\n    allOf:\n      - true\n\n  sources:\n    type: array\n    items:\n      $ref: "schema:ethdebug/format/materials/source"\n\nrequired:\n  - id\n  - compiler\n  - sources\n\nexamples:\n  - id: foo\n    compiler:\n      name: lllc\n      version: 0.4.12-develop.2017.6.27+commit.b83f77e0.Linux.g++\n    sources:\n      - id: 0\n        path: stdin\n        contents: |\n          (add 1 (mul 2 (add 3 4)))\n        language: LLL\n',"schema:ethdebug/format/materials/id":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/materials/id"\n\ntitle: ethdebug/format/materials/id\ndescription: An opaque external ID (likely generated by compiler)\n\ntype:\n  - number\n  - string\n\nexamples:\n  - 5\n  - "five"\n',"schema:ethdebug/format/materials/reference":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/materials/reference"\n\ntitle: ethdebug/format/materials/reference\ndescription: A reference to an external resource by ID\n\ntype: object\nproperties:\n  id:\n    $ref: "schema:ethdebug/format/materials/id"\n\n  type:\n    enum:\n      - compilation\n      - source\n\nrequired: [id]\n\nunevaluatedProperties: false\n\nexamples:\n  - id: 1\n',"schema:ethdebug/format/materials/source-range":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/materials/source-range"\n\ntitle: ethdebug/format/materials/source-range\ndescription: |\n  A range of bytes in a particular source.\n\n  Note that this refers to the bytes range in the original character encoding\n  for the source, not the character encoding used for strings in this JSON\n  format (UTF-8). For compilers that support input sources in encodings other\n  than this format\'s transmission encoding, compilers **must** address source\n  ranges in this original encoding, and debuggers **must** re-encode source\n  contents obtained from this format _before_ performing any range addressing.\n\n  (Compilers that only accept UTF-8 or ASCII are naturally exempt from this\n  concern.)\n\ntype: object\nproperties:\n  compilation:\n    title: Compilation reference by ID\n    $ref: "schema:ethdebug/format/materials/reference"\n\n  source:\n    title: Source reference by ID\n    $ref: "schema:ethdebug/format/materials/reference"\n\n  range:\n    title: Bytes range within source contents\n    description: |\n      Ranges that span the entire source contents **may** omit this field\n      as a shorthand. This field is otherwise **required**.\n    type: object\n    properties:\n      offset:\n        description: |\n          Byte offset at beginning of range.\n        $ref: "schema:ethdebug/format/data/value"\n\n      length:\n        description: Number of bytes contained in range\n        $ref: "schema:ethdebug/format/data/value"\n\n    unevaluatedProperties: false\n\n    required:\n      - offset\n      - length\n\nunevaluatedProperties: false\n\nrequired:\n  - source\n\nexamples:\n  - source:\n      id: 5\n    range:\n      offset: 20\n      length: 100\n',"schema:ethdebug/format/materials/source":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/materials/source"\n\ntitle: ethdebug/format/materials/source\ndescription: |\n  An object representing one unit of compiler input, the raw text contents and\n  identifying metadata (such as file path) that were given to the compiler as\n  part of a compilation.\n\ntype: object\nproperties:\n  id:\n    description: |\n      Source identifier. This field **must** be unique for all sources\n      within a single compiler invocation (compilation).\n    $ref: "schema:ethdebug/format/materials/id"\n\n  path:\n    type: string\n    description: |\n      Hierarchical file-system-like path to this source. This value may\n      be an absolute path, a path relative to some root directory, a path\n      to some resource within a package, etc.\n\n      This value does not need to correspond to any file on disk (either\n      physical or virtual), and might instead refer to a path identifier\n      for a source that was generated by a compiler or other development tool.\n\n      This format makes no specific restrictions on how paths should be\n      specified (e.g., no restriction on path separators, etc.), other than\n      that values for this field should match what users observe elsewhere for\n      the inputs/outputs of this particular compiler invocation.\n\n      If no path information is available for a particular source, e.g. if the\n      source was provided to the compiler via shell standard input, this field\n      should indicate that somehow (e.g., specifying `"path": "stdin"` or\n      similar).\n\n      This field\'s value **should** be unique across all sources within the\n      same compilation.\n\n  contents:\n    description: |\n      The full contents of the source, possibly re-encoded as UTF-8 to\n      match parent JSON encoding.\n\n      In cases where input source used a different encoding, this object\n      **must** also specify an `encoding` property to indicate the\n      encoding originally used. Where relevant, debuggers **must** also\n      convert these `contents` back to the specified original encoding so\n      as to match code author expectations.\n\n    type: string\n\n  encoding:\n    description: |\n      Character encoding of original source `contents`. This property\n      is **required** if this encoding does not match the JSON transmission\n      encoding (UTF-8), since the value of the `contents` property will\n      represent the text of the source of this JSON encoding.\n\n      This property **must not** appear in objects that do not specify\n      a `contents` property.\n\n    type: string\n\n  language:\n    description: |\n      The high-level language that the source contents are written in.\n\n    type: string\n\nrequired:\n  - id\n  - path\n  - contents\n  - language\n\nexamples:\n  - id: 5\n    path: ./contracts/SimpleStorage.sol\n    contents: |\n      // SPDX-License-Identifier: GPL-3.0\n      pragma solidity >=0.4.16 <0.9.0;\n\n      contract SimpleStorage {\n          uint storedData;\n\n          function set(uint x) public {\n              storedData = x;\n          }\n\n          function get() public view returns (uint) {\n              return storedData;\n          }\n      }\n\n    language: Solidity\n',"schema:ethdebug/format/pointer/collection/conditional":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/pointer/collection/conditional"\n\ntitle: ethdebug/format/pointer/collection/conditional\ndescription: |\n  A pointer defined conditionally based on the non-zero-ness of some expression\n\ntype: object\n\nproperties:\n  if:\n    $ref: "schema:ethdebug/format/pointer/expression"\n  then:\n    $ref: "schema:ethdebug/format/pointer"\n  else:\n    $ref: "schema:ethdebug/format/pointer"\n\nrequired:\n  - if\n  - then\n\nadditionalProperties: false\n\nexamples:\n  - if: 0\n    then:\n      location: memory\n      offset: 0\n      length: 1\n    else:\n      location: memory\n      offset: 1\n      length: 1\n',"schema:ethdebug/format/pointer/collection/group":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/pointer/collection/group"\n\ntitle: ethdebug/format/pointer/collection/group\ndescription: |\n  A composite collection of pointers\ntype: object\nproperties:\n  group:\n    type: array\n    items:\n      $ref: "schema:ethdebug/format/pointer"\n    minItems: 1\nrequired:\n  - group\nadditionalProperties: false\n\nexamples:\n  - group:\n      - name: "data-pointer"\n        location: stack\n        slot: 0\n      - location: memory\n        offset:\n          $read: "data-pointer"\n        length: 32\n',"schema:ethdebug/format/pointer/collection/list":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/pointer/collection/list"\n\ntitle: ethdebug/format/pointer/collection/list\ndescription: |\n  An ordered list of pointers, indexed starting at zero.\ntype: object\nproperties:\n  list:\n    type: object\n    properties:\n      count:\n        description: |\n          The size of the list that this collection represents.\n        $ref: "schema:ethdebug/format/pointer/expression"\n      each:\n        description: |\n          An identifier name whose value as an expression resolves to the index\n          in the list\n        $ref: "schema:ethdebug/format/pointer/identifier"\n      is:\n        description: |\n          The dynamically-generated pointer repeated as a list\n        $ref: "schema:ethdebug/format/pointer"\n    required:\n      - count\n      - each\n      - is\n\nrequired:\n  - list\n\nadditionalProperties: false\n\nexamples:\n  - list:\n      count: 5\n      each: "index"\n      is:\n        location: memory\n        offset:\n          $read: "index"\n        length: 1\n',"schema:ethdebug/format/pointer/collection/reference":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/pointer/collection/reference"\n\ntitle: ethdebug/format/pointer/collection/reference\ndescription: |\n  A pointer by named reference to a pointer template (defined elsewhere).\n\ntype: object\n\nproperties:\n  template:\n    title: Template identifier\n    $ref: "schema:ethdebug/format/pointer/identifier"\n\n  yields:\n    title: Region name mapping\n    description: |\n      Maps region names produced by the template to new names for use\n      outside the template. Unmapped region names pass through unchanged.\n      When omitted, all regions keep their original names.\n    type: object\n    propertyNames:\n      $ref: "schema:ethdebug/format/pointer/identifier"\n    additionalProperties:\n      $ref: "schema:ethdebug/format/pointer/identifier"\n\nrequired:\n  - template\n\nadditionalProperties: false\n\nexamples:\n  - template: "string-storage-pointer"\n\n  - template: "string-storage-pointer"\n    yields:\n      data: "name-data"\n      length: "name-length"\n',"schema:ethdebug/format/pointer/collection/scope":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/pointer/collection/scope"\n\ntitle: ethdebug/format/pointer/collection/scope\ndescription: |\n  A pointer defined with the aid of additional variables with values specified\n  as expressions.\n\n  Variables are specified by the `define` field as an object mapping of\n  expression by identifier. Variables are specified **in order**, so that\n  later appearing variables may reference earlier ones in the same object.\n\ntype: object\n\nproperties:\n  define:\n    title: Mapping of variables to expression value\n    type: object\n    patternProperties:\n      "^[a-zA-Z_\\\\-]+[a-zA-Z0-9$_\\\\-]*$":\n        $ref: "schema:ethdebug/format/pointer/expression"\n    additionalProperties: false\n  in:\n    $ref: "schema:ethdebug/format/pointer"\n\nrequired:\n  - define\n  - in\n\nadditionalProperties: false\n\nexamples:\n  - define:\n      example-offset:\n        $sum: [1, 2]\n      example-length:\n        $product: [2, $wordsize]\n    in:\n      name: example\n      location: memory\n      offset: example-offset\n      length: example-length\n',"schema:ethdebug/format/pointer/collection/templates":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/pointer/collection/templates"\n\ntitle: ethdebug/format/pointer/collection/templates\ndescription: |\n  A pointer with locally-defined templates available for use within.\n\n  Templates defined here are available by name for reference collections\n  inside the `in` pointer.\n\ntype: object\n\nproperties:\n  templates:\n    title: Mapping of template names to template definitions\n    type: object\n    propertyNames:\n      $ref: "schema:ethdebug/format/pointer/identifier"\n    additionalProperties:\n      $ref: "schema:ethdebug/format/pointer/template"\n  in:\n    $ref: "schema:ethdebug/format/pointer"\n\nrequired:\n  - templates\n  - in\n\nadditionalProperties: false\n\nexamples:\n  - templates:\n      simple-slot:\n        expect: ["slot"]\n        for:\n          location: storage\n          slot: "slot"\n    in:\n      define:\n        slot: 0\n      in:\n        template: "simple-slot"\n',"schema:ethdebug/format/pointer/collection":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/pointer/collection"\n\ntitle: ethdebug/format/pointer/collection\ndescription: |\n  A representation of a collection of pointers to data in the EVM\ntype: object\nallOf:\n  - oneOf:\n      - required: [group]\n      - required: [list]\n      - required: [if]\n      - required: [define]\n      - required: [template]\n      - required: [templates]\n\n  - if:\n      required: [group]\n    then:\n      $ref: "schema:ethdebug/format/pointer/collection/group"\n\n  - if:\n      required: [list]\n    then:\n      $ref: "schema:ethdebug/format/pointer/collection/list"\n\n  - if:\n      required: [if]\n    then:\n      $ref: "schema:ethdebug/format/pointer/collection/conditional"\n\n  - if:\n      required: [define]\n    then:\n      $ref: "schema:ethdebug/format/pointer/collection/scope"\n\n  - if:\n      required: [template]\n    then:\n      $ref: "schema:ethdebug/format/pointer/collection/reference"\n\n  - if:\n      required: [templates]\n    then:\n      $ref: "schema:ethdebug/format/pointer/collection/templates"\n',"schema:ethdebug/format/pointer/expression":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/pointer/expression"\n\ntitle: ethdebug/format/pointer/expression\ndescription: |\n  A schema for describing expressions that evaluate to values.\n\noneOf:\n  - $ref: "#/$defs/Literal"\n  - $ref: "#/$defs/Variable"\n  - $ref: "#/$defs/Constant"\n  - $ref: "#/$defs/Arithmetic"\n  - $ref: "#/$defs/Lookup"\n  - $ref: "#/$defs/Read"\n  - $ref: "#/$defs/Keccak256"\n  - $ref: "#/$defs/Concat"\n  - $ref: "#/$defs/Resize"\n\n$defs:\n  Literal:\n    title: Literal value\n    description: |\n      An unsigned number or a `0x`-prefixed string of hexadecimal digits\n\n    $ref: "schema:ethdebug/format/data/value"\n\n    examples:\n      - 5\n      - "0x0000000000000000000000000000000000000000000000000000000000000000"\n\n  Constant:\n    title: Constant value\n    type: string\n    enum:\n      - $wordsize\n\n  Variable:\n    title: Variable identifier\n    description: |\n      A string that matches an identifier used in an earlier declaration of\n      a scalar variable. This expression evaluates to the value of that\n      variable.\n    $ref: "schema:ethdebug/format/pointer/identifier"\n\n  Arithmetic:\n    title: Arithmetic operation\n    type: object\n    properties:\n      "$sum":\n        description: |\n          A list of expressions to be added together.\n        $ref: "#/$defs/Operands"\n      "$difference":\n        description: |\n          A tuple of two expressions where the second is to be subtracted from\n          the first.\n\n          If the second operand is larger than the first, the result of this\n          arithmetic operation is defined to equal zero (`0`).\n\n          (i.e., `{ "$difference": [a, b] }` equals `a` minus `b`.)\n        $ref: "#/$defs/Operands"\n        minItems: 2\n        maxItems: 2\n      "$product":\n        description: |\n          A list of expressions to be multiplied.\n        $ref: "#/$defs/Operands"\n      "$quotient":\n        description: |\n          A tuple of two expressions where the first corresponds to the\n          dividend and the second corresponds to the divisor, for the purposes\n          of doing integer division.\n\n          (i.e., `{ "$quotient": [a, b] }` equals `a` divided by `b`.)\n        $ref: "#/$defs/Operands"\n        minItems: 2\n        maxItems: 2\n      "$remainder":\n        description: |\n          A tuple of two expressions where the first corresponds to the\n          dividend and the second corresponds to the divisor, for the purposes\n          of computing the modular-arithmetic remainder.\n\n          (i.e., `{ "$remainder": [a, b] }` equals `a` mod `b`.)\n        $ref: "#/$defs/Operands"\n        minItems: 2\n        maxItems: 2\n    additionalProperties: false\n    minProperties: 1\n    maxProperties: 1\n    examples:\n      - "$sum": [5, 3, 4]\n      - "$difference": [5, 3]\n      - "$product": [5, 3, 0]\n      - "$quotient": [5, 3]\n      - "$remainder":\n          - "$product":\n              - 2\n              - 2\n              - 2\n              - 2\n          - 3\n\n  Operands:\n    type: array\n    items:\n      $ref: "schema:ethdebug/format/pointer/expression"\n\n  Lookup:\n    title: Lookup region definition\n    description: |\n      An object of the form `{ ".<property-name>": "<region>" }`, to\n      denote that this expression is equivalent to the defined value for\n      the property named `<property-name>` inside the region referenced as\n      `<region>`.\n\n      `<property-name>` **must** be a valid and present property on the\n      corresponding region, or it **must** correspond to an optional property\n      whose schema specifies a default value for that property.\n    type: object\n    patternProperties:\n      "^\\\\.(offset|length|slot)$":\n        $ref: "#/$defs/Reference"\n    additionalProperties: false\n    minProperties: 1\n    maxProperties: 1\n\n    examples:\n      - .offset: "array-count"\n      - .length: "array-item"\n      - .offset: $this\n\n  Read:\n    title: Read region bytes\n    description: |\n      An object of the form `{ "$read": "<region>" }`. The value of this\n      expression equals the raw bytes present in the running machine state\n      in the referenced region.\n    type: object\n    properties:\n      $read:\n        $ref: "#/$defs/Reference"\n    required:\n      - $read\n    additionalProperties: false\n    examples:\n      - $read: "struct-start"\n\n  Reference:\n    title: Region reference\n    description: |\n      A string value that **must** either be the `"name"` of at least one\n      region declared with `{ "name": "<region>" }` previously in some root\n      pointer representation, or it **must** be the literal value `"$this"`,\n      which indicates a reference to the region containing this expression.\n\n      If more than one region is defined with the same name, resolution is\n      defined as firstly resolving to the latest earlier sibling that declares\n      the matching name, then secondly resolving to the parent if it matches,\n      then to parent\'s earlier siblings, and so on.\n    type: string\n    oneOf:\n      - $ref: "schema:ethdebug/format/pointer/identifier"\n      - const: "$this"\n        description: |\n          Indicates a reference to the region containing this expression.\n\n  Keccak256:\n    title: Keccak256 hash\n    description: |\n      An object of the form `{ "$keccak256": [...values] }`, indicating that this\n      expression evaluates to the Solidity-style keccak256 hash of the\n      tightly-packed bytes encoded by `values`.\n    type: object\n    properties:\n      $keccak256:\n        title: Array of hashed values\n        type: array\n        items:\n          $ref: "schema:ethdebug/format/pointer/expression"\n    additionalProperties: false\n    required:\n      - $keccak256\n    examples:\n      - $keccak256:\n          - 0\n          - "0x00"\n\n  Concat:\n    title: Concatenate values\n    description: |\n      An object of the form `{ "$concat": [...values] }`, indicating that this\n      expression evaluates to the concatenation of bytes from each value.\n      The byte width of each operand is preserved; no padding is added or\n      removed between operands.\n    type: object\n    properties:\n      $concat:\n        title: Array of values to concatenate\n        type: array\n        items:\n          $ref: "schema:ethdebug/format/pointer/expression"\n    additionalProperties: false\n    required:\n      - $concat\n    examples:\n      - $concat:\n          - "0x00"\n          - "0x00"\n      - $concat:\n          - "0xdead"\n          - "0xbeef"\n      - $concat: []\n\n  Resize:\n    title: Resize data\n    description: |\n      A resize operation expression is either an object of the form\n      `{ "$sized<N>": <expression> }` or an object of the form\n      `{ "$wordsized": <expression> }`, where `<expression>` is an expression\n      whose value is to be resized, and, if applicable, where `<N>` is the\n      smallest decimal representation of an unsigned integer.\n\n      This object\'s value is evaluated as follows, based on the bytes width of\n      the value `<expression>` evaluates to and based on `<N>` (using the\n      value of `"$wordsize"` for `<N>` in the case of the latter form above):\n      - If the width equals `<N>`, this object evaluates to the same value as\n        `<expression>` (equivalent to the identity function or no-op).\n      - If the width is less than `<N>`, this object evaluates to the same value\n        as `<expression>` but with additional zero-bytes (`0x00`) prepended on\n        the left (most significant) side, such that the resulting bytes width\n        equals `<N>`.\n      - If the width exceeds `<N>`, this object evaluates to the same value\n        as `<expression>` but with a number of bytes removed from the left\n        (most significant) side until the bytes width equals `<N>`.\n\n      (These cases match the behavior that Solidity uses for resizing its\n      `bytesN`/`uintN` types.)\n    type: object\n    oneOf:\n      - title: Resize to literal number of bytes\n        type: object\n        patternProperties:\n          "^\\\\$sized([1-9]+[0-9]*)$":\n            $ref: "schema:ethdebug/format/pointer/expression"\n        additionalProperties: false\n      - title: Resize to word-size\n        type: object\n        patternProperties:\n          "^\\\\$wordsized$":\n            $ref: "schema:ethdebug/format/pointer/expression"\n        additionalProperties: false\n    minProperties: 1\n    maxProperties: 1\n    examples:\n      - $sized2: "0x00" # 0x0000\n      - $sized2: "0xffffff" # 0xffff\n      - $wordsized: "0x00" # 0x0000000000000000000000000000000000000000000000000000000000000000\n\nexamples:\n  - 0\n  - $sum:\n      - .offset: "array-start"\n      - .length: "array-start"\n      - 1\n  - $keccak256:\n      - 5\n      - .offset: "array-start"\n',"schema:ethdebug/format/pointer/identifier":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/pointer/identifier"\n\ntitle: ethdebug/format/pointer/identifier\ndescription: |\n  An identifier for use within the context of a root pointer\ntype: string\npattern: "^[a-zA-Z_\\\\-]+[a-zA-Z0-9$_\\\\-]*$"\n\nexamples:\n  - a\n  - a0\n  - -$\n  - __init__\n',"schema:ethdebug/format/pointer/region/base":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/pointer/region/base"\n\ntitle: ethdebug/format/pointer/region/base\ndescription: |\n  Common schema for all region schemas, regardless of `"location": ...`.\n\ntype: object\nproperties:\n  name:\n    $ref: "schema:ethdebug/format/pointer/identifier"\n\n  location:\n    type: string\n\nrequired:\n  - location\n\nexamples:\n  - name: "array-item"\n    location: memory\n',"schema:ethdebug/format/pointer/region/calldata":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/pointer/region/calldata"\n\ntitle: ethdebug/format/pointer/region/calldata\ndescription: |\n  A schema for representing a region of data in message calldata.\n\n  This schema is constructed by extending the base region schema\n  and the schema for the slice addressing scheme.\ntype: object\nallOf:\n  - title: \'{\xa0"location":\xa0"calldata"\xa0}\' # note: whitespace chars are \\255 (nbsp)\n    properties:\n      location:\n        const: calldata\n\n    required:\n      - location\n  - $ref: "schema:ethdebug/format/pointer/region/base"\n  - $ref: "schema:ethdebug/format/pointer/scheme/slice"\n\nunevaluatedProperties: false\n\nexamples:\n  - location: calldata\n    offset: "0x04"\n    length: 32\n',"schema:ethdebug/format/pointer/region/code":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/pointer/region/code"\n\ntitle: ethdebug/format/pointer/region/code\ndescription: |\n  A schema for representing a region of data in EVM bytecode.\n\n  This schema is constructed by extending the base region schema\n  and the schema for the slice addressing scheme.\ntype: object\nallOf:\n  - title: \'{\xa0"location":\xa0"code"\xa0}\' # note: whitespace chars are \\255 (nbsp)\n    properties:\n      location:\n        const: code\n\n    required:\n      - location\n  - $ref: "schema:ethdebug/format/pointer/region/base"\n  - $ref: "schema:ethdebug/format/pointer/scheme/slice"\n\nunevaluatedProperties: false\n\nexamples:\n  - location: code\n    offset: "0x04"\n    length: 32\n',"schema:ethdebug/format/pointer/region/memory":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/pointer/region/memory"\n\ntitle: ethdebug/format/pointer/region/memory\ndescription: |\n  A schema for representing a region of data in EVM memory. Pointer regions\n  within memory represent a single/atomic sequence of byte locations.\n\n  This schema is constructed by extending the base region schema\n  and the schema for the slice addressing scheme.\ntype: object\nallOf:\n  - title: \'{\xa0"location":\xa0"memory"\xa0}\' # note: whitespace chars are \\255 (nbsp)\n    properties:\n      location:\n        const: memory\n\n    required:\n      - location\n  - $ref: "schema:ethdebug/format/pointer/region/base"\n  - $ref: "schema:ethdebug/format/pointer/scheme/slice"\n\nunevaluatedProperties: false\n\nexamples:\n  - location: memory\n    offset: "0x04"\n    length: 32\n',"schema:ethdebug/format/pointer/region/returndata":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/pointer/region/returndata"\n\ntitle: ethdebug/format/pointer/region/returndata\ndescription: |\n  A schema for representing a region of data in message returndata.\n\n  This schema is constructed by extending the base region schema\n  and the schema for the slice addressing scheme.\ntype: object\nallOf:\n  - title: \'{\xa0"location":\xa0"returndata"\xa0}\' # note: whitespace chars are \\255 (nbsp)\n    properties:\n      location:\n        const: returndata\n\n    required:\n      - location\n  - $ref: "schema:ethdebug/format/pointer/region/base"\n  - $ref: "schema:ethdebug/format/pointer/scheme/slice"\n\nunevaluatedProperties: false\n\nexamples:\n  - location: returndata\n    offset: "0x04"\n    length: 32\n',"schema:ethdebug/format/pointer/region/stack":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/pointer/region/stack"\n\ntitle: ethdebug/format/pointer/region/stack\ndescription: |\n  A schema for representing a region of data in the EVM.\n\n  Describes stack slots as number of positions from the top (at time of\n  observation). Debuggers reading this information **should** immediately\n  convert these positions to absolute positions from the bottom.\n\n  This schema is constructed by extending the base region schema\n  and the schema for the segment addressing scheme.\ntype: object\nallOf:\n  - title: \'{\xa0"location":\xa0"stack"\xa0}\' # note: whitespace chars are \\255 (nbsp)\n    properties:\n      location:\n        const: stack\n\n    required:\n      - location\n\n  - $ref: "schema:ethdebug/format/pointer/region/base"\n  - $ref: "schema:ethdebug/format/pointer/scheme/segment"\n\nunevaluatedProperties: false\n\nexamples:\n  - location: stack\n    slot: 0\n  - location: stack\n    slot: 1\n    length:\n      $product:\n        - $wordsize\n        - 2\n',"schema:ethdebug/format/pointer/region/storage":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/pointer/region/storage"\n\ntitle: ethdebug/format/pointer/region/storage\ndescription: |\n  A schema for representing a region of data in EVM storage.\n\n  This schema is constructed by extending the base region schema\n  and the schema for the segment addressing scheme.\ntype: object\nallOf:\n  - title: \'{\xa0"location":\xa0"storage"\xa0}\' # note: whitespace chars are \\255 (nbsp)\n    properties:\n      location:\n        const: storage\n\n    required:\n      - location\n\n  - $ref: "schema:ethdebug/format/pointer/region/base"\n  - $ref: "schema:ethdebug/format/pointer/scheme/segment"\n\nunevaluatedProperties: false\n\nexamples:\n  - location: storage\n    slot: "0x03"\n  - location: storage\n    slot: "0x06"\n    length:\n      $product:\n        - $wordsize\n        - 2\n  - location: storage\n    slot: "0x08"\n    offset:\n      $quotient:\n        - $wordsize\n        - 2\n    length:\n      $quotient:\n        - $wordsize\n        - 2\n',"schema:ethdebug/format/pointer/region/transient":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/pointer/region/transient"\n\ntitle: ethdebug/format/pointer/region/transient\ndescription: |\n  A schema for representing a region of data in EVM transient storage.\n\n  This schema is constructed by extending the base region schema\n  and the schema for the segment addressing scheme.\ntype: object\nallOf:\n  - title: \'{\xa0"location":\xa0"transient"\xa0}\' # note: whitespace chars are \\255 (nbsp)\n    properties:\n      location:\n        const: transient\n\n    required:\n      - location\n\n  - $ref: "schema:ethdebug/format/pointer/region/base"\n  - $ref: "schema:ethdebug/format/pointer/scheme/segment"\n\nunevaluatedProperties: false\n\nexamples:\n  - location: transient\n    slot: "0x03"\n  - location: transient\n    slot: "0x06"\n    length:\n      $product:\n        - $wordsize\n        - 2\n  - location: transient\n    slot: "0x08"\n    offset:\n      $quotient:\n        - $wordsize\n        - 2\n    length:\n      $quotient:\n        - $wordsize\n        - 2\n',"schema:ethdebug/format/pointer/region":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/pointer/region"\n\ntitle: ethdebug/format/pointer/region\ndescription: |\n  A representation of a region of data in the EVM\ntype: object\nproperties:\n  location:\n    $ref: "#/$defs/Location"\n\nallOf:\n  - if:\n      properties:\n        location:\n          const: stack\n\n    then:\n      $ref: "schema:ethdebug/format/pointer/region/stack"\n\n  - if:\n      properties:\n        location:\n          const: memory\n\n    then:\n      $ref: "schema:ethdebug/format/pointer/region/memory"\n\n  - if:\n      properties:\n        location:\n          const: storage\n    then:\n      $ref: "schema:ethdebug/format/pointer/region/storage"\n\n  - if:\n      properties:\n        location:\n          const: calldata\n    then:\n      $ref: "schema:ethdebug/format/pointer/region/calldata"\n\n  - if:\n      properties:\n        location:\n          const: returndata\n    then:\n      $ref: "schema:ethdebug/format/pointer/region/returndata"\n\n  - if:\n      properties:\n        location:\n          const: transient\n    then:\n      $ref: "schema:ethdebug/format/pointer/region/transient"\n\n  - if:\n      properties:\n        location:\n          const: code\n    then:\n      $ref: "schema:ethdebug/format/pointer/region/code"\n\n$defs:\n  Location:\n    type: string\n    enum:\n      - stack\n      - memory\n      - storage\n      - calldata\n      - returndata\n      - transient\n      - code\n\nunevaluatedProperties: false\n\nexamples:\n  - location: storage\n    slot: "0x0000000000000000000000000000000000000000000000000000000000000000"\n',"schema:ethdebug/format/pointer/scheme/segment":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/pointer/scheme/segment"\n\ntitle: ethdebug/format/pointer/scheme/segment\ndescription: |\n  An addressing scheme for pointing to a range of bytes in a data location\n  arranged as individually-addressable word-sized slots.\n\n  **Note** that this addressing scheme permits addressing byte ranges that\n  extend beyond the last byte of a particular slot, or even covering the range\n  of multiple slots.\n\n  In such cases, this schema defines the range as the concatenation of bytes\n  across slots such that the address of the first byte after the end of slot\n  `p` (i.e., `{ "offset": "$wordsize" }`) is interpreted as the first byte of\n  slot `p + 1`.\n\ntype: object\n\nproperties:\n  slot:\n    $ref: "schema:ethdebug/format/pointer/expression"\n  offset:\n    description: |\n      The starting byte index within the slot.\n\n      This field is **optional**. If unspecified, it has the default value of\n      `0`, indicating that the segment begins at the start of the specified\n      slot.\n\n      This field\'s expression must resolve to a value _n_ such that\n      0&nbsp;\u2264&nbsp;_n_&nbsp;\\<&nbsp;`$wordsize` (i.e., the offset **must**\n      begin inside the slot).\n    $ref: "schema:ethdebug/format/pointer/expression"\n    default: 0\n  length:\n    description: |\n      The length of the bytes range this segment represents.\n\n      This field is **optional**. If unspecified, its default value indicates\n      that the segment ends at the end of the slot.\n\n      If this field has value larger than the default value, i.e., if the\n      segment extends beyond the last byte in the slot, then this segment is\n      defined to be the concatenation of the sequentially-addressed slot(s)\n      following following the slot specified.\n    $ref: "schema:ethdebug/format/pointer/expression"\n    default:\n      $difference:\n        - $wordsize\n        - .offset: $this\n\nrequired:\n  - slot\n\nexamples:\n  - slot: 0\n  - slot: 1\n    length:\n      $product:\n        - $wordsize\n        - 3\n',"schema:ethdebug/format/pointer/scheme/slice":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/pointer/scheme/slice"\n\ntitle: ethdebug/format/pointer/scheme/slice\ndescription: |\n  An addressing scheme for pointing to a range of sequential bytes inside\n  a data location whose structure is that of a regular bytes array\n  (i.e., where bytes are indexed by byte offset, with no concept of word).\n\ntype: object\n\nproperties:\n  offset:\n    description: |\n      The index of the byte (starting from zero) in the data location where\n      the slice begins.\n    $ref: "schema:ethdebug/format/pointer/expression"\n  length:\n    description: |\n      The length of the slice in number of bytes.\n    $ref: "schema:ethdebug/format/pointer/expression"\n\nrequired:\n  - offset\n  - length\n\nexamples:\n  - offset: 0\n    length: 32\n',"schema:ethdebug/format/pointer/template":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/pointer/template"\n\ntitle: ethdebug/format/pointer/template\ndescription: |\n  A schema for representing a pointer defined in terms of some variables whose\n  values are to be provided when invoking the template.\n\ntype: object\nproperties:\n  expect:\n    title: Template variables\n    description: |\n      An array of variable identifiers used in the definition of the\n      pointer template.\n    type: array\n    items:\n      $ref: "schema:ethdebug/format/pointer/identifier"\n    additionalItems: false\n\n  for:\n    $ref: "schema:ethdebug/format/pointer"\n\nrequired:\n  - expect\n  - for\n\nadditionalProperties: false\n\nexamples:\n  - expect: ["slot"]\n    for:\n      location: storage\n      slot: "slot"\n',"schema:ethdebug/format/pointer":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/pointer"\n\ntitle: ethdebug/format/pointer\ndescription: |\n  A schema for representing a pointer to a data position or a range of data\n  positions in the EVM.\n\n  An **ethdebug/format/pointer** is either a single region or a structured\n  collection of other pointers.\n\ntype: object\n\nif:\n  required: [location]\nthen:\n  $ref: "schema:ethdebug/format/pointer/region"\nelse:\n  $ref: "schema:ethdebug/format/pointer/collection"\n\nexamples:\n  - # example: a single particular storage slot\n    location: storage\n    slot: 2\n\n  - # example `uint256[] memory` allocation pointer\n    define:\n      "uint256-array-memory-pointer-slot": 0\n    in:\n      # this pointer composes an ordered list of other pointers\n      group:\n        # declare the first sub-pointer to be the "array-start" region of data\n        # corresponding to the first item in the stack (at time of observation)\n        - name: "array-start"\n          location: stack\n          slot: "uint256-array-memory-pointer-slot"\n\n        # declare the "array-count" region to be at the offset indicated by\n        # the value at "array-start"\n        - name: "array-count"\n          location: memory\n          offset:\n            $read: "array-start"\n          length: $wordsize\n\n        # thirdly, declare a sub-pointer that is a dynamic list whose size is\n        # indicated by the value at "array-count", where each "item-index"\n        # corresponds to a discrete "array-item" region\n        - list:\n            count:\n              $read: "array-count"\n            each: "item-index"\n            is:\n              name: "array-item"\n              location: "memory"\n              offset:\n                # array items are positioned so that the item with index 0\n                # immediately follows "array-count", and each subsequent item\n                # immediately follows the previous.\n                $sum:\n                  - .offset: "array-count"\n                  - .length: "array-count"\n                  - $product:\n                      - "item-index"\n                      - .length: $this\n              length: $wordsize\n\n  - # example `struct Record { uint8 x; uint8 y; bytes4 salt; }` in storage\n    #\n    # this example defines the "packed-field" template inline and demonstrates\n    # how templates can be reused with `yields` to rename regions.\n    # each field is placed by packing right-to-left from the previous offset.\n    templates:\n      packed-field:\n        expect:\n          - "struct-storage-contract-variable-slot"\n          - "previous"\n          - "size"\n        for:\n          name: "field"\n          location: storage\n          slot: "struct-storage-contract-variable-slot"\n          offset:\n            $difference: ["previous", "size"]\n          length: "size"\n    in:\n      define:\n        "struct-storage-contract-variable-slot": 0\n      in:\n        group:\n          # sentinel region marking where packing begins (end of word)\n          - name: "packing-begin"\n            location: storage\n            slot: "struct-storage-contract-variable-slot"\n            offset: $wordsize\n            length: 0\n\n          - define: { previous: { .offset: "packing-begin" }, size: 1 }\n            in:\n              template: "packed-field"\n              yields: { "field": "x" }\n\n          - define: { previous: { .offset: "x" }, size: 1 }\n            in:\n              template: "packed-field"\n              yields: { "field": "y" }\n\n          - define: { previous: { .offset: "y" }, size: 4 }\n            in:\n              template: "packed-field"\n              yields: { "field": "salt" }\n\n  - # example `(struct Record { uint256 x; uint256 y; })[] memory`\n    group:\n      # declare the first sub-pointer to be the "array-start" region of data\n      # corresponding to the first item in the stack (at time of observation)\n      - name: "array-start"\n        location: stack\n        slot: 0\n\n      # declares the "array-count" region in memory at the offset indicated\n      # by "array-start" and of length equal to word size\n      - name: "array-count"\n        location: memory\n        offset:\n          $read: "array-start"\n        length: $wordsize\n\n      # declare this to include a list of pointers of size indicated by the\n      # value at "array-count", where each "item-index" corresponds to a\n      # group of pointers\n      - list:\n          count:\n            $read: "array-count"\n          each: "item-index"\n          is:\n            group:\n              # each element in the list includes a "struct-pointer" region\n              # in memory (laid out sequentially in a block as the raw\n              # array data)\n              - name: "struct-pointer"\n                location: memory\n                offset:\n                  $sum:\n                    - .offset: "array-count"\n                    - .length: "array-count"\n                    - $product:\n                        - "item-index"\n                        - .length: "struct-pointer"\n                length: $wordsize\n\n              # following that pointer leads to the region corresponding to\n              # the first member of the struct\n              - name: "struct-member-0"\n                location: memory\n                offset:\n                  $read: "struct-pointer"\n                length: $wordsize\n\n              # the second struct member immediately follows the first\n              - name: "struct-member-1"\n                location: memory\n                offset:\n                  $sum:\n                    - .offset: "struct-member-0"\n                    - .length: "struct-member-0"\n                length: $wordsize\n\n  - # example `string storage` allocation\n    define:\n      "string-storage-contract-variable-slot": 0\n    in:\n      group:\n        # for short strings, the length is stored as 2n in the last byte of slot\n        - name: "length-flag"\n          location: storage\n          slot: "string-storage-contract-variable-slot"\n          offset:\n            $difference: [$wordsize, 1]\n          length: 1\n\n        # define the region representing the string data itself conditionally\n        # based on odd or even length data\n        - if:\n            $remainder:\n              - $sum:\n                  - $read: "length-flag"\n                  - 1\n              - 2\n\n          # short string case (flag is even)\n          then:\n            define:\n              "string-length":\n                $quotient: [{ $read: "length-flag" }, 2]\n            in:\n              name: "string"\n              location: storage\n              slot: "string-storage-contract-variable-slot"\n              offset: 0\n              length: "string-length"\n\n          # long string case (flag is odd)\n          else:\n            group:\n              # long strings may use full word to describe length as 2n+1\n              - name: "long-string-length-data"\n                location: storage\n                slot: "string-storage-contract-variable-slot"\n                offset: 0\n                length: $wordsize\n\n              - define:\n                  "string-length":\n                    $quotient:\n                      - $difference:\n                          - $read: "long-string-length-data"\n                          - 1\n                      - 2\n\n                  "start-slot":\n                    $keccak256:\n                      - $wordsized: "string-storage-contract-variable-slot"\n\n                  "total-slots":\n                    # account for both zero and nonzero slot remainders by adding\n                    # $wordsize-1 to the length before dividing\n                    $quotient:\n                      - $sum: ["string-length", { $difference: [$wordsize, 1] }]\n                      - $wordsize\n                in:\n                  list:\n                    count: "total-slots"\n                    each: "i"\n                    is:\n                      define:\n                        "current-slot":\n                          $sum: ["start-slot", "i"]\n                        "previous-length":\n                          $product: ["i", $wordsize]\n                      in:\n                        # conditional based on whether this is the last slot:\n                        # is the string length longer than the previous length\n                        # plus this whole slot?\n                        if:\n                          $difference:\n                            - "string-length"\n                            - $sum: ["previous-length", "$wordsize"]\n                        then:\n                          # include the whole slot\n                          name: "string"\n                          location: storage\n                          slot: "current-slot"\n                        else:\n                          # include only what\'s left in the string\n                          name: "string"\n                          location: storage\n                          slot: "current-slot"\n                          offset: 0\n                          length:\n                            $difference: ["string-length", "previous-length"]\n',"schema:ethdebug/format/program/context/code":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/program/context/code"\n\ntitle: ethdebug/format/program/context/code\ndescription: |\n  Information about the source code range corresponding to this point in\n  machine execution.\n\ntype: object\nproperties:\n  code:\n    $ref: "schema:ethdebug/format/materials/source-range"\nrequired:\n  - code\n\nexamples:\n  - code:\n      source:\n        id: 5\n      range:\n        offset: 68\n        length: 16\n',"schema:ethdebug/format/program/context/frame":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/program/context/frame"\n\ntitle: ethdebug/format/program/context/frame\ndescription: |\n  A context may specify a `"frame"` property to indicate that its facts apply\n  only to one of several possible compilation frames, e.g. for compilers with\n  distinct frontend/backends to specify debugging data for the IR separately\n  from the debugging data for the source language.\ntype: object\nproperties:\n  frame:\n    title: Relevant compilation frame\n    type: string\nrequired:\n  - frame\n\nexamples:\n  - frame: "ir"\n  - frame: "source"\n',"schema:ethdebug/format/program/context/gather":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/program/context/gather"\n\ntitle: ethdebug/format/program/context/gather\ndescription: |\n  A context specifying the `"gather"` property with a list of contexts\n  indicates that all specified contexts apply simultaneously.\n\ntype: object\nproperties:\n  gather:\n    title: Contexts to gather\n    type: array\n    items:\n      $ref: "schema:ethdebug/format/program/context"\n    minItems: 2\n    additionalItems: false\nrequired:\n  - gather\n\nexamples:\n  - gather:\n      - frame: "ir"\n        code:\n          source:\n            id: 0\n          range:\n            offset: 8\n            length: 11\n      - frame: "source"\n        code:\n          source:\n            id: 3\n          range:\n            offset: 113\n            length: 19\n  - gather:\n      - variables:\n          - identifier: x\n            declaration:\n              source:\n                id: 5\n              range:\n                offset: 10\n                length: 56\n            type:\n              kind: string\n      - variables:\n          - identifier: x\n            declaration:\n              source:\n                id: 5\n              range:\n                offset: 10\n                length: 56\n            pointer:\n              location: storage\n              slot: 0\n',"schema:ethdebug/format/program/context/name":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/program/context/name"\n\ntitle: ethdebug/format/program/context/name\ndescription: |\n  The name of the context, for use in disambiguating future instruction\n  annotations that specify one of several possible contexts based on\n  information only available at runtime.\n\ntype: object\nproperties:\n  name:\n    type: string\nrequired:\n  - name\n\nexamples:\n  - name: "Array<T=bytes32>"\n',"schema:ethdebug/format/program/context/pick":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/program/context/pick"\n\ntitle: ethdebug/format/program/context/pick\ndescription: |\n  A program context that specifies the `"pick"` property indicates that\n  one of several possible contexts are known to be true, possibly requiring\n  additional information to disambiguate.\n\ntype: object\nproperties:\n  pick:\n    title: Contexts to pick from\n    type: array\n    items:\n      $ref: "schema:ethdebug/format/program/context"\n    minItems: 2\n    additionalItems: false\nrequired:\n  - pick\n\nexamples:\n  - pick:\n      - code:\n          source:\n            id: 5\n          range:\n            offset: 68\n            length: 16\n      - code:\n          source:\n            id: 5\n          range:\n            offset: 132\n            length: 16\n',"schema:ethdebug/format/program/context/remark":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/program/context/remark"\n\ntitle: ethdebug/format/program/context/remark\ndescription: |\n  Human-readable information about the instruction. This field is intended\n  primarily not for compilers to use directly, but rather for humans\n  (directly or indirectly) to use as an annotation field.\n\ntype: object\nproperties:\n  remark:\n    type: string\n\nrequired:\n  - remark\n\nexamples:\n  - remark: "jump to end if zero"\n',"schema:ethdebug/format/program/context/variables":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/program/context/variables"\n\ntitle: ethdebug/format/program/context/variables\ndescription: |\n  Information about known variables at this context\'s point in code\n  execution, specified as an array whose items each correspond to a unique\n  variable.\n\n  Items in this array **should not** have duplicate non-empty `identifier`\n  values except where high-level language semantics require it. Where\n  possible, use other mechanisms provided by this format to indicate that\n  an identifier\'s corresponding variable is ambiguous.\n\ntype: object\nproperties:\n  variables:\n    type: array\n    items:\n      $ref: "#/$defs/Variable"\n    minItems: 1\n    additionalItems: false\nrequired:\n  - variables\n\nexamples:\n  - variables:\n      - identifier: x\n        declaration:\n          source:\n            id: 5\n          range:\n            offset: 10\n            length: 56\n        type:\n          kind: string\n        pointer:\n          location: storage\n          slot: 0\n\n$defs:\n  Variable:\n    title: Variable\n    description: |\n      The information known about a variable at a particular point in the code\n      execution.\n\n    type: object\n    properties:\n      identifier:\n        type: string\n        minLength: 1\n\n      declaration:\n        description: |\n          Source range corresponding to where the variable was declared.\n        $ref: "schema:ethdebug/format/materials/source-range"\n\n      type:\n        description: |\n          The variable\'s static type, if it exists. This **must** be specified\n          either as a full **ethdebug/format/type** representation, or an\n          `{ "id": "..." }` type reference object.\n        oneOf:\n          - $ref: "schema:ethdebug/format/type"\n          - $ref: "schema:ethdebug/format/type/reference"\n\n      pointer:\n        description: |\n          Allocation information for the variable, if it exists.\n        $ref: "schema:ethdebug/format/pointer"\n\n    minProperties: 1\n    unevaluatedProperties: false\n\n    examples:\n      - identifier: x\n        declaration:\n          source:\n            id: 5\n          range:\n            offset: 10\n            length: 56\n',"schema:ethdebug/format/program/context":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/program/context"\n\ntitle: ethdebug/format/program/context\ndescription: |\n  An **ethdebug/format/program/context** object represents compile-time\n  information about the high-level runtime execution state at a specific point\n  in a program\'s bytecode.\n\n  This schema provides a formal specification for this format\'s model of what\n  information can be known at compile-time about the high-level runtime. This\n  includes data such as a particular machine instruction\'s source mapping or\n  what variables exist in runtime state following some instruction.\n\n  The context object supports dynamic context combination and selection through\n  the use of `gather`, and `pick` properties. This allows for flexible\n  composition and extraction of context information.\n\n  Contexts serve as a bridge between low-level EVM execution and high-level\n  language constructs. Debuggers can use these compile-time guarantees to\n  maintain a coherent view of the high-level language runtime throughout\n  program execution. This enables debugging tools to map execution points to\n  source code, reconstruct variable states, provide meaningful stack traces,\n  and offer insights into control flow and data structures.\n\ntype: object\n\nallOf:\n  - if:\n      required: ["code"]\n    then:\n      description: |\n        The context\'s corresponding source code range.\n      $ref: "schema:ethdebug/format/program/context/code"\n  - if:\n      required: ["variables"]\n    then:\n      description: |\n        Variable definitions, types, allocations known to exist in the context.\n      $ref: "schema:ethdebug/format/program/context/variables"\n  - if:\n      required: ["remark"]\n    then:\n      description: |\n        Human-readable context annotation. Not intended for compiler use.\n      $ref: "schema:ethdebug/format/program/context/remark"\n  - if:\n      required: ["pick"]\n    then:\n      description: |\n        Alternation between several possible contexts.\n      $ref: "schema:ethdebug/format/program/context/pick"\n  - if:\n      required: ["gather"]\n    then:\n      description: |\n        Collection of multiple known, separate contexts.\n      $ref: "schema:ethdebug/format/program/context/gather"\n  - if:\n      required: ["frame"]\n    then:\n      description: |\n        For use by compilers with multiple pipeline outputs (e.g., use of an\n        intermediary representation) to associate a\n        context with a particular compiler step.\n      $ref: "schema:ethdebug/format/program/context/frame"\n\nunevaluatedProperties: false\n\nexamples:\n  - variables:\n      - identifier: x\n        declaration:\n          source:\n            id: 5\n          range:\n            offset: 10\n            length: 56\n        type:\n          kind: string\n        pointer:\n          location: storage\n          slot: 0\n    code:\n      source:\n        id: 5\n      range:\n        offset: 68\n        length: 16\n',"schema:ethdebug/format/program/instruction":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/program/instruction"\n\ntitle: ethdebug/format/program/instruction\ndescription: |\n  A schema for representing the information pertaining to a particular\n  instruction in machine code.\n\ntype: object\n\nproperties:\n  offset:\n    title: Instruction byte offset\n    description: |\n      The byte offset where the instruction begins within the bytecode.\n\n      For legacy contract bytecode (non-EOF), this value is equivalent to the\n      instruction\'s program counter. For EOF bytecode, this value **must** be\n      the offset from the start of the container, not the start of a particular\n      code section within that container.\n    $ref: "schema:ethdebug/format/data/value"\n\n  operation:\n    title: Machine operation information\n    type: object\n    properties:\n      mnemonic:\n        description: The mnemonic operation code (PUSH1, e.g.)\n        type: string\n\n      arguments:\n        description: The immediate arguments to the operation, if relevant.\n        type: array\n        minItems: 1\n        items:\n          description: |\n            An immediate value specified as argument to the opcode\n          $ref: "schema:ethdebug/format/data/value"\n\n    required:\n      - mnemonic\n\n  context:\n    description: |\n      The context known to exist following the execution of this instruction.\n\n      This field is **optional**. Omitting it is equivalent to specifying the\n      empty context value (`{}`).\n    $ref: "schema:ethdebug/format/program/context"\n    default: {}\n\nrequired:\n  - offset\n\nexamples:\n  - offset: 0\n    operation:\n      mnemonic: "PUSH1"\n      arguments: ["0x60"]\n    context:\n      code:\n        source:\n          id: 5\n        range:\n          offset: 10\n          length: 30\n',"schema:ethdebug/format/program":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/program"\n\ntitle: ethdebug/format/program\ndescription: |\n  Debugging information about a particular bytecode in a compilation.\n\ntype: object\n\nproperties:\n  compilation:\n    title: Compilation reference by ID\n    description: |\n      A reference to the compilation as an `{ "id": ... }` object.\n    $ref: "schema:ethdebug/format/materials/reference"\n\n  contract:\n    type: object\n    properties:\n      name:\n        type: string\n\n      definition:\n        $ref: "schema:ethdebug/format/materials/source-range"\n    required:\n      - definition\n\n  environment:\n    title: Bytecode execution environment\n    description: |\n      Whether this bytecode is for contract creation or runtime calls.\n    type: string\n    enum:\n      - call\n      - create\n\n  context:\n    description: |\n      The context known to exist prior to the execution of the first\n      instruction in the bytecode.\n\n      This field is **optional**. Omitting it is equivalent to specifying the\n      empty context value (`{}`).\n    $ref: "schema:ethdebug/format/program/context"\n    default: {}\n\n  instructions:\n    type: array\n    description: |\n      The full array of instructions for the bytecode.\n    items:\n      $ref: "schema:ethdebug/format/program/instruction"\n    additionalItems: false\n\nrequired:\n  - contract\n  - environment\n  - instructions\n\nexamples:\n  - # Incrementing a storage counter\n    #\n    # This example represents the call bytecode for the following pseudo-code:\n    # ```\n    # contract Incrementer;\n    #\n    # storage {\n    #   [0] storedValue: uint256;\n    # };\n    #\n    # code {\n    #   let localValue = storedValue;\n    #   storedValue += 1;\n    #   value = tmp;\n    # };\n    # ```\n    contract:\n      name: "Incrementer"\n      definition:\n        source:\n          id: 0\n    environment: call\n    context:\n      variables:\n        - &stored-value\n          identifier: storedValue\n          type:\n            kind: uint\n            bits: 256\n          pointer:\n            location: storage\n            slot: 0\n    instructions:\n      - offset: 0\n        operation:\n          mnemonic: PUSH0\n        context:\n          variables:\n            - *stored-value\n      - offset: 1\n        operation:\n          mnemonic: SLOAD\n        context:\n          variables:\n            - *stored-value\n            - &local-value\n              identifier: localValue\n              type:\n                kind: uint\n                bits: 256\n              pointer:\n                location: stack\n                slot: 0\n      - offset: 2\n        operation:\n          mnemonic: PUSH1\n          arguments: ["0x01"]\n        context:\n          variables:\n            - *stored-value\n            - <<: *local-value\n              pointer:\n                location: stack\n                slot: 1\n\n      - offset: 4\n        operation:\n          mnemonic: ADD\n        context:\n          variables:\n            - *stored-value\n            - *local-value\n      - offset: 5\n        operation:\n          mnemonic: PUSH0\n        context:\n          variables:\n            - *stored-value\n            - <<: *local-value\n              pointer:\n                location: stack\n                slot: 1\n\n      - offset: 6\n        operation:\n          mnemonic: SSTORE\n        context:\n          variables:\n            - *stored-value\n',"schema:ethdebug/format/type/base":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/type/base"\n\ntitle: ethdebug/format/type/base\ndescription: Defines the minimally necessary schema for a data type.\n  Types belong to a particular `class` (`"elementary"` or `"complex"`),\n  and are further identified by a particular `kind`.\ntype: object\noneOf:\n  - $ref: "#/$defs/ElementaryType"\n  - $ref: "#/$defs/ComplexType"\n\n$defs:\n  ElementaryType:\n    title: Base elementary type\n    description: Represents an elementary type (one that does not compose other types)\n    type: object\n    properties:\n      class:\n        type: string\n        const: elementary\n      kind:\n        type: string\n      contains:\n        not:\n          description: "Elementary types **must not** specify a `contains` field\n            (to make it easier to discriminate elementary vs. complex)"\n    required:\n      - kind\n    examples:\n      - kind: uint\n        bits: 256\n\n  ComplexType:\n    title: Base complex type\n    description:\n      Represents a complex type, one that composes other types (e.g., arrays,\n      structs, mappings)\n    type: object\n    properties:\n      class:\n        type: string\n        const: complex\n        description: Indicates that this is a complex type\n      kind:\n        type: string\n        description: The specific kind of complex type, e.g., array or struct\n      contains:\n        title: Complex type `contains` field\n        description:\n          Either a type wrapper, an array of type wrappers, or an object\n          mapping to type wrappers.\n        oneOf:\n          - $ref: "#/$defs/TypeWrapper"\n          - $ref: "#/$defs/TypeWrapperArray"\n          - $ref: "#/$defs/TypeWrapperObject"\n\n    required:\n      - kind\n      - contains\n    examples:\n      - kind: array\n        contains:\n          type:\n            kind: uint\n            bits: 256\n      - kind: struct\n        contains:\n          - member: x\n            type:\n              kind: uint\n              bits: 256\n          - member: y\n            type:\n              kind: uint\n              bits: 256\n      - kind: mapping\n        contains:\n          key:\n            type:\n              kind: address\n              payable: true\n          value:\n            type:\n              kind: uint\n              bits: 256\n\n  TypeWrapper:\n    title: \'{ "type": ... }\'\n    description:\n      A wrapper around a type. Defines a `"type"` field that may include a full\n      Type representation or a reference to a known Type by ID. Note that this\n      schema permits additional properties on the same object.\n    type: object\n    properties:\n      type:\n        oneOf:\n          - $ref: "schema:ethdebug/format/type/base"\n          - $ref: "schema:ethdebug/format/type/reference"\n\n    required:\n      - type\n\n  TypeWrapperArray:\n    title: \'{ "type": ... }[]\'\n    description: A list of wrapped types, where the wrapper may add fields\n    type: array\n    items:\n      $ref: "#/$defs/TypeWrapper"\n\n  TypeWrapperObject:\n    title: \'{ "key": { "type": ... }, ... }\'\n    description: A key-value mapping of wrapped types, where the wrapper may add fields\n    type: object\n    additionalProperties:\n      $ref: "#/$defs/TypeWrapper"\n',"schema:ethdebug/format/type/complex/alias":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/type/complex/alias"\n\ntitle: ethdebug/format/type/complex/alias\ndescription: Schema representing a type alias to another type\n\ntype: object\nproperties:\n  class:\n    type: string\n    const: complex\n  kind:\n    type: string\n    const: alias\n  contains:\n    $ref: "schema:ethdebug/format/type/wrapper"\n  definition:\n    $ref: "schema:ethdebug/format/type/definition"\n\nrequired:\n  - kind\n  - contains\n\nexamples:\n  - kind: alias\n    contains:\n      type:\n        kind: uint\n        bits: 256\n\n  - kind: alias\n    contains:\n      type:\n        kind: array\n        contains:\n          type:\n            class: elementary\n            kind: super-uint # unsupported type\n            blits: -256\n',"schema:ethdebug/format/type/complex/array":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/type/complex/array"\n\ntitle: ethdebug/format/type/complex/array\ntype: object\nproperties:\n  class:\n    type: string\n    const: complex\n  kind:\n    type: string\n    const: array\n  contains:\n    $ref: "schema:ethdebug/format/type/wrapper"\n  count:\n    description: |\n      The fixed number of elements in this array. When omitted, the array\n      is dynamically sized.\n    $ref: "schema:ethdebug/format/data/value"\n\nrequired:\n  - kind\n  - contains\n\nexamples:\n  - kind: array\n    contains:\n      type:\n        kind: uint\n        bits: 256\n\n  - kind: array\n    count: 10\n    contains:\n      type:\n        kind: address\n\n  - kind: array\n    contains:\n      type:\n        kind: array\n        contains:\n          type:\n            class: elementary\n            kind: super-uint # unsupported type\n            blits: -256\n',"schema:ethdebug/format/type/complex/function":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/type/complex/function"\n\ntitle: ethdebug/format/type/complex/function\ndescription: |\n  Schema for representing a function type.\n\n  Type representations must indicate whether they represent a function that is\n  called internally (within the semantics of the language) or a function that\n  is called externally (via EVM contract call semantics and the Solidity ABI).\n  Internal function types require the `"internal": true` field; external\n  function types require `"external": true`.\n\n  Note that external function types may include a representation of the\n  contract type that defines or provides this function as an external\n  interface.\n\ntype: object\nproperties:\n  class:\n    type: string\n    const: complex\n  kind:\n    type: string\n    const: function\n  contains:\n    type: object\n    title: Parameter and return types\n    description: |\n      Types this function type composes. Function types inherently compose\n      two groupings of types (an ordered list of parameter types and typically\n      either a return value or return parameters). Function types\' `contains`\n      field is organized as a mapping of `parameters` types (a type wrapper for\n      a tuple type) and an optional `returns` type (either a generic type\n      wrapper or a type wrapper for a tuple type).\n\n      This definition applies for both cases (internal and external function\n      types). Each of those specific types may expand this `contains` field\n      schema with other semantic details (such as an external function type\n      indicating the contract type from which it is exposed).\n    properties:\n      parameters:\n        $ref: "#/$defs/Parameters"\n      returns:\n        type: object\n        title: Return type (or tuple of types)\n        description: |\n          To accommodate languages differing in whether functions return single\n          values or lists of values, this field may be either a generic type\n          wrapper or explicitly defined as a type wrapper around a tuple type.\n\n          Debuggers that implement this schema **should** be aware that\n          languages whose functions return sole values might return tuple\n          types. Resolving this ambiguity remains outside the scope of the\n          schema (but compilers **must** be consistent when representing\n          function types in this schema).\n        anyOf:\n          - $ref: "schema:ethdebug/format/type/wrapper"\n          - $ref: "#/$defs/Parameters"\n    required:\n      - parameters\n  definition:\n    $ref: "schema:ethdebug/format/type/definition"\n\noneOf:\n  - type: object\n    title: External function type\n    properties:\n      internal:\n        const: false\n      external:\n        const: true\n      contains:\n        type: object\n        title: Additional contents\n        properties:\n          contract:\n            type: object\n            title: Contract type providing external function\n            description:\n              A wrapper around the contract type that composes this external\n              function type.\n            allOf:\n              - $ref: "schema:ethdebug/format/type/wrapper"\n              - type: object\n                title: Contract type wrapper\n                properties:\n                  type:\n                    $ref: "schema:ethdebug/format/type/elementary/contract"\n    required:\n      - external\n\n  - type: object\n    title: Internal function type\n    properties:\n      internal:\n        const: true\n      external:\n        const: false\n    required:\n      - internal\n\nexamples:\n  - kind: function\n    internal: true\n    definition:\n      name: increment\n    contains:\n      parameters:\n        type:\n          kind: tuple\n          contains:\n            - name: value\n              type:\n                kind: uint\n                bits: 256\n      returns:\n        type:\n          kind: uint\n          bits: 256\n  - kind: function\n    external: true\n    definition:\n      name: withdraw\n    contains:\n      contract:\n        type:\n          kind: contract\n          payable: true\n          interface: true\n          definition:\n            name: Bank\n      parameters:\n        type:\n          kind: tuple\n          contains:\n            - name: beneficiary\n              type:\n                kind: address\n                payable: true\n            - name: amount\n              type:\n                kind: ufixed\n                bits: 128\n                places: 18\n      returns:\n        type:\n          kind: tuple\n          contains: []\n\n$defs:\n  Parameters:\n    type: object\n    title: Parameters\n    description:\n      A type wrapper around a tuple of types. This schema uses a tuple type to\n      represent an ordered list of types.\n    allOf:\n      - $ref: "schema:ethdebug/format/type/wrapper"\n      - title: Tuple type wrapper\n        type: object\n        properties:\n          type:\n            $ref: "schema:ethdebug/format/type/complex/tuple"\n',"schema:ethdebug/format/type/complex/mapping":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/type/complex/mapping"\n\ntitle: ethdebug/format/type/complex/mapping\ndescription: Schema for representing mapping types\n\ntype: object\nproperties:\n  class:\n    type: string\n    const: complex\n  kind:\n    type: string\n    const: mapping\n  contains:\n    type: object\n    title: Mapping key/value types\n    properties:\n      key:\n        $ref: "schema:ethdebug/format/type/wrapper"\n      value:\n        $ref: "schema:ethdebug/format/type/wrapper"\n    required:\n      - key\n      - value\n\nrequired:\n  - kind\n  - contains\n\nexamples:\n  - kind: mapping\n    contains:\n      key:\n        type:\n          kind: address\n      value:\n        type:\n          kind: uint\n          bits: 256\n',"schema:ethdebug/format/type/complex/struct":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/type/complex/struct"\n\ntitle: ethdebug/format/type/complex/struct\ndescription: Schema for representing struct types\n\ntype: object\nproperties:\n  class:\n    type: string\n    const: complex\n  kind:\n    type: string\n    const: struct\n  contains:\n    type: array\n    items:\n      $ref: "#/$defs/MemberField"\n  definition:\n    $ref: "schema:ethdebug/format/type/definition"\n\nrequired:\n  - kind\n  - contains\n\nexamples:\n  - kind: struct\n    contains:\n      - name: x\n        type:\n          kind: uint\n          bits: 128\n      - name: y\n        type:\n          kind: uint\n          bits: 128\n\n$defs:\n  MemberField:\n    type: object\n    title: MemberField\n    description:\n      A schema representing a member field inside a struct type. This is an\n      **ethdebug/format/type/wrapper** with additional fields.\n    allOf:\n      - $ref: "schema:ethdebug/format/type/wrapper"\n      - title: Additional fields\n        description:\n          An object with optional `name` property for identifying named struct\n          member fields. **Note** that this language does not specify that a\n          struct must be consistent in its use of naming for all fields or none\n        type: object\n        properties:\n          name:\n            type: string\n',"schema:ethdebug/format/type/complex/tuple":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/type/complex/tuple"\n\ntitle: ethdebug/format/type/complex/tuple\ndescription: Schema for representing tuple types\n\ntype: object\nproperties:\n  class:\n    type: string\n    const: complex\n  kind:\n    type: string\n    const: tuple\n  contains:\n    type: array\n    items:\n      $ref: "#/$defs/Element"\n\nrequired:\n  - kind\n  - contains\n\nexamples:\n  - # empty tuple type\n    kind: tuple\n    contains: []\n\n  - kind: tuple\n    contains:\n      - name: x\n        type:\n          kind: uint\n          bits: 128\n      - name: y\n        type:\n          kind: uint\n          bits: 128\n\n$defs:\n  Element:\n    type: object\n    title: Element\n    description: An optionally named element type within a tuple. This is an\n      **ethdebug/format/type/wrapper** with additional fields.\n    allOf:\n      - $ref: "schema:ethdebug/format/type/wrapper"\n      - title: Additional fields\n        type: object\n        properties:\n          name:\n            type: string\n            description:\n              For tuple types where positional element types are identified\n              by name, this field **should** include this information.\n\n              This schema makes no restriction on whether all-or-no elements\n              have names, and so this field may be sparse across elements of\n              the same tuple.\n',"schema:ethdebug/format/type/complex":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/type/complex"\n\ntitle: ethdebug/format/type/complex\ndescription: Canonical representation of a complex type\n\ntype: object\nproperties:\n  kind:\n    $ref: "#/$defs/Kind"\nrequired:\n  - kind\n\nallOf:\n  - if:\n      properties:\n        kind:\n          const: alias\n    then:\n      $ref: "schema:ethdebug/format/type/complex/alias"\n\n  - if:\n      properties:\n        kind:\n          const: tuple\n    then:\n      $ref: "schema:ethdebug/format/type/complex/tuple"\n\n  - if:\n      properties:\n        kind:\n          const: array\n    then:\n      $ref: "schema:ethdebug/format/type/complex/array"\n\n  - if:\n      properties:\n        kind:\n          const: mapping\n    then:\n      $ref: "schema:ethdebug/format/type/complex/mapping"\n\n  - if:\n      properties:\n        kind:\n          const: struct\n    then:\n      $ref: "schema:ethdebug/format/type/complex/struct"\n\n  - if:\n      properties:\n        kind:\n          const: function\n    then:\n      $ref: "schema:ethdebug/format/type/complex/function"\n\n$defs:\n  Kind:\n    title: Known complex kind\n    description:\n      A schema for the values of `kind` reserved for known complex types\n      included in ethdebug/format\n    type: string\n    enum:\n      - alias\n      - tuple\n      - array\n      - mapping\n      - struct\n      - function\n',"schema:ethdebug/format/type/definition":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/type/definition"\n\ntitle: ethdebug/format/type/definition\ndescription: |\n  Object containing name and location information for a type.\n\n  This schema does not require any particular field, but it **must** contain\n  at least one property.\n\ntype: object\nproperties:\n  name:\n    type: string\n\n  location:\n    $ref: "schema:ethdebug/format/materials/source-range"\n\nanyOf:\n  - title: Required `name`\n    required: [name]\n  - title: Required `location`\n    required: [location]\n\nexamples:\n  - name: Ballot\n    location:\n      source:\n        id: 5\n      range:\n        offset: 10\n        length: 56\n',"schema:ethdebug/format/type/elementary/address":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/type/elementary/address"\n\ntitle: ethdebug/format/type/elementary/address\ndescription: Schema describing the representation of an address type\n\ntype: object\nproperties:\n  class:\n    const: elementary\n  kind:\n    const: address\n  payable:\n    type: boolean\n    description: If this field is omitted, this type represents an address whose\n      payability is not known.\nrequired:\n  - kind\nexamples:\n  - # a type for addresses of unknown payability\n    kind: address\n\n  - # a type for payable addresses\n    kind: address\n    payable: true\n',"schema:ethdebug/format/type/elementary/bool":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/type/elementary/bool"\n\ntitle: ethdebug/format/type/elementary/bool\ndescription: Schema describing the representation of the boolean type\n\ntype: object\nproperties:\n  class:\n    const: elementary\n  kind:\n    const: bool\nrequired:\n  - kind\nexamples:\n  - kind: bool\n',"schema:ethdebug/format/type/elementary/bytes":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/type/elementary/bytes"\n\ntitle: ethdebug/format/type/elementary/bytes\ndescription: Schema describing the representation of a type of bytes string\n  (either dynamic or static)\n\ntype: object\nproperties:\n  class:\n    const: elementary\n  kind:\n    const: bytes\n  size:\n    description:\n      The number of bytes in the bytes string. If this field is omitted, this\n      type is the dynamic bytes string type.\n    $ref: "schema:ethdebug/format/data/unsigned"\nrequired:\n  - kind\nexamples:\n  - # example static bytes type\n    kind: bytes\n    size: 32\n  - # example dynamic bytes type\n    kind: bytes\n',"schema:ethdebug/format/type/elementary/contract":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/type/elementary/contract"\n\ntitle: ethdebug/format/type/elementary/contract\ndescription: Schema describing the representation of a contract type\n\ntype: object\nproperties:\n  class:\n    const: elementary\n  kind:\n    const: contract\n  payable:\n    type: boolean\n    description: If this field is omitted, this type represents an address whose\n      payability is not known.\n  definition:\n    $ref: "schema:ethdebug/format/type/definition"\n\noneOf:\n  - title: Normal contract type\n    properties:\n      library:\n        const: false\n      interface:\n        const: false\n\n  - title: Contract library type\n    properties:\n      library:\n        const: true\n        description: Indicates that this is a type representing a library\n    required:\n      - library\n\n  - title: Contract interface type\n    properties:\n      interface:\n        const: true\n        description: Indicates that this is a type representing an interface\n    required:\n      - interface\n\nrequired:\n  - kind\n\nexamples:\n  - kind: contract\n\n  - kind: contract\n    library: false\n    interface: false\n    payable: true\n',"schema:ethdebug/format/type/elementary/enum":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/type/elementary/enum"\n\ntitle: ethdebug/format/type/elementary/enum\ndescription: Schema describing the representation of an enumerated type\n\ntype: object\nproperties:\n  class:\n    const: elementary\n  kind:\n    const: enum\n  values:\n    description:\n      The allowed values of an enum. This format makes no restriction on which\n      values are allowed here.\n    type: array\n    items: true\n  definition:\n    $ref: "schema:ethdebug/format/type/definition"\n\nrequired:\n  - kind\n  - values\n\nexamples:\n  - kind: enum\n    values:\n      - A\n      - B\n      - C\n',"schema:ethdebug/format/type/elementary/fixed":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/type/elementary/fixed"\n\ntitle: ethdebug/format/type/elementary/fixed\ndescription: Schema describing the representation of a signed fixed decimal type\n\ntype: object\nproperties:\n  class:\n    const: elementary\n  kind:\n    const: fixed\n  bits:\n    type: integer\n    multipleOf: 8\n    minimum: 8\n    maximum: 256\n  places:\n    type: integer\n    description:\n      How many decimal places, implying that a raw value `v` of this type\n      should be interpreted as `v / (10**places)`\n    minimum: 1\n    maximum: 80\nrequired:\n  - kind\n  - bits\n  - places\nexamples:\n  - kind: fixed\n    bits: 256\n    places: 10\n',"schema:ethdebug/format/type/elementary/int":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/type/elementary/int"\n\ntitle: ethdebug/format/type/elementary/int\ndescription: Schema describing the representation of a signed integer type\n\ntype: object\nproperties:\n  class:\n    const: elementary\n  kind:\n    const: int\n  bits:\n    type: integer\n    multipleOf: 8\n    minimum: 8\n    maximum: 256\nrequired:\n  - kind\n  - bits\nexamples:\n  - kind: int\n    bits: 256\n',"schema:ethdebug/format/type/elementary/string":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/type/elementary/string"\n\ntitle: ethdebug/format/type/elementary/string\ndescription: Schema describing the representation of a string type\n\ntype: object\nproperties:\n  class:\n    const: elementary\n  kind:\n    const: string\n  encoding:\n    type: string\n    default: utf-8\nrequired:\n  - kind\nexamples:\n  - kind: string\n  - kind: string\n    encoding: utf-16\n',"schema:ethdebug/format/type/elementary/ufixed":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/type/elementary/ufixed"\n\ntitle: ethdebug/format/type/elementary/ufixed\ndescription: Schema describing the representation of an unsigned fixed decimal type\n\ntype: object\nproperties:\n  class:\n    const: elementary\n  kind:\n    const: ufixed\n  bits:\n    type: integer\n    multipleOf: 8\n    minimum: 8\n    maximum: 256\n  places:\n    type: integer\n    description:\n      How many decimal places, implying that a raw value `v` of this type\n      should be interpreted as `v / (10**places)`\n    minimum: 1\n    maximum: 80\nrequired:\n  - kind\n  - bits\n  - places\nexamples:\n  - kind: ufixed\n    bits: 256\n    places: 10\n',"schema:ethdebug/format/type/elementary/uint":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/type/elementary/uint"\n\ntitle: ethdebug/format/type/elementary/uint\ndescription: Schema describing the representation of an unsigned integer type\n\ntype: object\nproperties:\n  class:\n    const: elementary\n  kind:\n    const: uint\n  bits:\n    type: integer\n    multipleOf: 8\n    minimum: 8\n    maximum: 256\nrequired:\n  - kind\n  - bits\nexamples:\n  - kind: uint\n    bits: 256\n',"schema:ethdebug/format/type/elementary":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/type/elementary"\n\ntitle: ethdebug/format/type/elementary\ndescription: Canonical representation of an elementary type\n\ntype: object\nproperties:\n  kind:\n    $ref: "#/$defs/Kind"\nrequired:\n  - kind\n\nallOf:\n  - if:\n      properties:\n        kind:\n          const: uint\n    then:\n      $ref: "schema:ethdebug/format/type/elementary/uint"\n\n  - if:\n      properties:\n        kind:\n          const: int\n    then:\n      $ref: "schema:ethdebug/format/type/elementary/int"\n\n  - if:\n      properties:\n        kind:\n          const: bool\n    then:\n      $ref: "schema:ethdebug/format/type/elementary/bool"\n\n  - if:\n      properties:\n        kind:\n          const: bytes\n    then:\n      $ref: "schema:ethdebug/format/type/elementary/bytes"\n\n  - if:\n      properties:\n        kind:\n          const: string\n    then:\n      $ref: "schema:ethdebug/format/type/elementary/string"\n\n  - if:\n      properties:\n        kind:\n          const: ufixed\n    then:\n      $ref: "schema:ethdebug/format/type/elementary/ufixed"\n\n  - if:\n      properties:\n        kind:\n          const: fixed\n    then:\n      $ref: "schema:ethdebug/format/type/elementary/fixed"\n  - if:\n      properties:\n        kind:\n          const: address\n    then:\n      $ref: "schema:ethdebug/format/type/elementary/address"\n\n  - if:\n      properties:\n        kind:\n          const: contract\n    then:\n      $ref: "schema:ethdebug/format/type/elementary/contract"\n\n  - if:\n      properties:\n        kind:\n          const: enum\n    then:\n      $ref: "schema:ethdebug/format/type/elementary/enum"\n\n$defs:\n  Kind:\n    title: Known elementary kind\n    description:\n      A schema for the values of `kind` reserved for known elementary types\n      included in ethdebug/format\n    type: string\n    enum:\n      - uint\n      - int\n      - bool\n      - bytes\n      - string\n      - ufixed\n      - fixed\n      - address\n      - contract\n      - enum\n',"schema:ethdebug/format/type/reference":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/type/reference"\n\ntitle: ethdebug/format/type/reference\ndescription: A reference to a known type by ID\ntype: object\nproperties:\n  id:\n    type:\n      - string\n      - number\nadditionalProperties: false\nrequired:\n  - id\nexamples:\n  - id: 5\n',"schema:ethdebug/format/type/wrapper":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/type/wrapper"\n\ntitle: ethdebug/format/type/wrapper\ndescription:\n  A wrapper around a type. Defines a `"type"` field that may include a full\n  Type representation or a reference to a known Type by ID. Note that this\n  schema permits additional properties on the same object.\ntype: object\nproperties:\n  type:\n    # Discriminate between reference and type based on presence of `id`\n    if:\n      required:\n        - id\n    then:\n      $ref: "schema:ethdebug/format/type/reference"\n    else:\n      $ref: "schema:ethdebug/format/type"\n\nrequired:\n  - type\n\nexamples:\n  - name: beneficiary\n    type:\n      kind: address\n      payable: true\n  - type:\n      id: "<opaque-id>"\n\n$defs:\n  Array:\n    title: \'{ "type": ... }[]\'\n    description: A list of wrapped types, where the wrapper may add fields\n    type: array\n    items:\n      $ref: "schema:ethdebug/format/type/wrapper"\n\n  Object:\n    title: \'{ "key": { "type": ... }, ... }\'\n    description: A key-value mapping of wrapped types, where the wrapper may add fields\n    type: object\n    additionalProperties:\n      $ref: "schema:ethdebug/format/type/wrapper"\n',"schema:ethdebug/format/type":'$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/type"\n\ntitle: ethdebug/format/type\ndescription: Canonical representation for all types.\ntype: object\n\nif:\n  type: object\n  title: Known kind\n  description: If `kind` adheres to the set of known kinds defined by this format\n  properties:\n    kind:\n      anyOf:\n        - $ref: "schema:ethdebug/format/type/elementary#/$defs/Kind"\n        - $ref: "schema:ethdebug/format/type/complex#/$defs/Kind"\n\nthen:\n  type: object\n  title: KnownType\n  description: Then the object must adhere to exactly one known kind of type\n  allOf:\n    - if:\n        properties:\n          kind:\n            $ref: "schema:ethdebug/format/type/elementary#/$defs/Kind"\n      then:\n        $ref: "schema:ethdebug/format/type/elementary"\n    - if:\n        properties:\n          kind:\n            $ref: "schema:ethdebug/format/type/complex#/$defs/Kind"\n      then:\n        $ref: "schema:ethdebug/format/type/complex"\n\nelse:\n  type: object\n  description:\n    Else the object must be a valid **ethdebug/format/type/base** with\n    additional constraints\n  allOf:\n    - $ref: "schema:ethdebug/format/type/base"\n    - title: Required `class` field\n      required:\n        - class\n    - title: Specialized complex type `contains` field\n      type: object\n      if:\n        description: If this object is a complex type\n        properties:\n          class:\n            const: complex\n      then:\n        description: Then the `contains` field must adhere to\n          **ethdebug/format/type/wrapper** schemas, not the\n          **ethdebug/format/type/base** equivalent.\n\n          (i.e., these additional constraints must apply recursively)\n        properties:\n          contains:\n            oneOf:\n              - $ref: "schema:ethdebug/format/type/wrapper"\n              - $ref: "schema:ethdebug/format/type/wrapper#/$defs/Array"\n              - $ref: "schema:ethdebug/format/type/wrapper#/$defs/Object"\n'},An={merge:!0};function Nn({schema:e,pointer:t}){if("string"==typeof t&&!t.startsWith("#"))throw new Error("`pointer` option must start with '#'");const n=t?{pointer:t}:{};return function(e){return"string"==typeof e||1===Object.keys(e).length&&"id"in e}(e)?function({schema:{id:e},pointer:t}){const[n,s]=e.split("#"),i=s?function(e){const t=e.filter((e=>"string"==typeof e)).map((e=>e.slice(1))).join("");if(0===t.length)return;return`#${t}`}([`#${s}`,t]):t,o=Sn[n];if(!o)throw new Error(`Unknown schema with $id "${n}"`);const r=En(o,i),a=$n(r,An),c=$n(o,An);return{id:n,...i?{pointer:i}:{},yaml:r,schema:a,rootSchema:c}}({schema:"object"==typeof e?e:{id:e},...n}):function(e){return"object"==typeof e&&1===Object.keys(e).length&&"yaml"in e}(e)?function({schema:{yaml:e},pointer:t}){const n=En(e,t),s=$n(n,An),i=$n(e,An),o=s.$id;return o?{id:o,...t?{pointer:t}:{},yaml:n,schema:s,rootSchema:i}:{...t?{pointer:t}:{},yaml:n,schema:s,rootSchema:i}}({schema:e,...n}):function({schema:e,pointer:t}){const n=En(jn(e),t),s=$n(n,An),i=s.$id;return i?{id:i,...t?{pointer:t}:{},yaml:n,schema:s,rootSchema:e}:{...t?{pointer:t}:{},yaml:n,schema:s,rootSchema:e}}({schema:e,...n})}function En(e,t){if(!t)return e;let n=xn(e);for(const s of t.slice(2).split("/"))if(n=n.get(s,!0),!n)throw new Error(`Pointer ${t} not found in schema`);return jn(n)}const On=Object.keys(Sn).map((e=>({[e]:Nn({schema:{id:e}}).schema}))).reduce(((e,t)=>({...e,...t})),{});var Tn,In;!function(e){e.isValue=t=>[e.isUnsigned,e.isHex].some((e=>e(t))),e.isUnsigned=e=>"number"==typeof e&&e>=0;const t=new RegExp(/^0x[0-9a-fA-F]{1,}$/);e.isHex=e=>"string"==typeof e&&t.test(e)}(Tn||(Tn={})),function(e){e.isId=e=>["number","string"].includes(typeof e),e.isReference=t=>"object"==typeof t&&!!t&&"id"in t&&e.isId(t.id),e.toReference=function(t){return{id:t.id,...[[e.isCompilation,"compilation"],[e.isSource,"source"]].filter((([e])=>e(t))).map((([e,t])=>({type:t})))[0]||{}}},e.isCompilation=t=>"object"==typeof t&&!!t&&"id"in t&&e.isId(t.id)&&"compiler"in t&&"object"==typeof t.compiler&&!!t.compiler&&"name"in t.compiler&&"string"==typeof t.compiler.name&&"version"in t.compiler&&"string"==typeof t.compiler.version&&"sources"in t&&t.sources instanceof Array&&t.sources.every(e.isSource),e.isSource=t=>"object"==typeof t&&!!t&&"id"in t&&e.isId(t.id)&&"path"in t&&"string"==typeof t.path&&"contents"in t&&"string"==typeof t.contents&&"language"in t&&"string"==typeof t.language&&(!("encoding"in t)||"string"==typeof t.encoding),e.isSourceRange=t=>"object"==typeof t&&!!t&&"source"in t&&e.isReference(t.source)&&(!("range"in t)||"object"==typeof t.range&&!!t.range&&"offset"in t.range&&Tn.isValue(t.range.offset)&&"length"in t.range&&Tn.isValue(t.range.length))&&(!("compilation"in t)||e.isReference(t.compilation))}(In||(In={}));const Cn=e=>[_n,Ln].some((t=>t(e))),_n=e=>!("object"!=typeof e||!e||!("kind"in e)||"string"!=typeof e.kind||"class"in e&&"elementary"!==e.class||"contains"in e),Ln=e=>"object"==typeof e&&!!e&&"kind"in e&&"string"==typeof e.kind&&(!("class"in e)||"complex"===e.class)&&"contains"in e&&!!e.contains&&(qn(e.contains)||e.contains instanceof Array&&e.contains.every(qn)||"object"==typeof e.contains&&Object.values(e.contains).every(qn)),qn=e=>"object"==typeof e&&!!e&&"type"in e&&(Cn(e.type)||"object"==typeof e.type&&!!e.type&&"id"in e.type),Bn=e=>Pn.hasElementaryKind(e)||Pn.hasComplexKind(e)?Pn.isKnown(e):Pn.isUnknown(e);var Pn;!function(e){let t,n;e.Base=s,e.isKnown=t=>[e.isElementary,e.isComplex].some((e=>e(t))),e.isUnknown=t=>e.Base.isType(t)&&"class"in t&&(!("contains"in t)||e.isWrapper(t.contains)||t.contains instanceof Array&&t.contains.every(e.isWrapper)||"object"==typeof t.contains&&Object.values(t.contains).every(e.isWrapper)),e.isWrapper=e=>"object"==typeof e&&!!e&&"type"in e&&(Bn(e.type)||"object"==typeof e.type&&!!e.type&&"id"in e.type),e.hasElementaryKind=e=>"object"==typeof e&&!!e&&"kind"in e&&"string"==typeof e.kind&&["uint","int","ufixed","fixed","bool","bytes","string","address","contract","enum"].includes(e.kind),e.isElementary=e=>[t.isUint,t.isInt,t.isUfixed,t.isFixed,t.isBool,t.isBytes,t.isString,t.isAddress,t.isContract,t.isEnum].some((t=>t(e))),function(t){t.isUint=e=>"object"==typeof e&&!!e&&Dn(e,"elementary")&&Rn(e,"uint")&&"bits"in e&&"number"==typeof e.bits&&e.bits>=8&&e.bits<=256&&e.bits%8==0,t.isInt=e=>"object"==typeof e&&!!e&&Dn(e,"elementary")&&Rn(e,"int")&&"bits"in e&&"number"==typeof e.bits&&e.bits>=8&&e.bits<=256&&e.bits%8==0,t.isUfixed=e=>"object"==typeof e&&!!e&&Dn(e,"elementary")&&Rn(e,"ufixed")&&"bits"in e&&"number"==typeof e.bits&&e.bits>=8&&e.bits<=256&&e.bits%8==0&&"places"in e&&"number"==typeof e.places&&e.places>=1&&e.places<=80,t.isFixed=e=>"object"==typeof e&&!!e&&Dn(e,"elementary")&&Rn(e,"fixed")&&"bits"in e&&"number"==typeof e.bits&&e.bits>=8&&e.bits<=256&&e.bits%8==0&&"places"in e&&"number"==typeof e.places&&e.places>=1&&e.places<=80,t.isBool=e=>"object"==typeof e&&!!e&&Dn(e,"elementary")&&Rn(e,"bool"),t.isBytes=e=>"object"==typeof e&&!!e&&Dn(e,"elementary")&&Rn(e,"bytes")&&(!("size"in e)||Tn.isUnsigned(e.size)),t.isString=e=>"object"==typeof e&&!!e&&Dn(e,"elementary")&&Rn(e,"string")&&(!("encoding"in e)||"string"==typeof e.encoding),t.isAddress=e=>"object"==typeof e&&!!e&&Dn(e,"elementary")&&Rn(e,"address")&&(!("payable"in e)||"boolean"==typeof e.payable),t.isContract=t=>"object"==typeof t&&!!t&&Dn(t,"elementary")&&Rn(t,"contract")&&(!("payable"in t)||"boolean"==typeof t.payable)&&(!("definition"in t)||e.isDefinition(t.definition)),t.isEnum=t=>"object"==typeof t&&!!t&&Dn(t,"elementary")&&Rn(t,"enum")&&"values"in t&&t.values instanceof Array&&(!("definition"in t)||e.isDefinition(t.definition))}(t=e.Elementary||(e.Elementary={})),e.hasComplexKind=e=>"object"==typeof e&&!!e&&"kind"in e&&"string"==typeof e.kind&&["alias","tuple","array","mapping","struct"].includes(e.kind),e.isComplex=e=>[n.isAlias,n.isTuple,n.isArray,n.isMapping,n.isStruct].some((t=>t(e))),function(t){t.isAlias=t=>"object"==typeof t&&!!t&&Dn(t,"complex")&&Rn(t,"alias")&&"contains"in t&&e.isWrapper(t.contains)&&(!("definition"in t)||e.isDefinition(t.definition)),t.isTuple=t=>"object"==typeof t&&!!t&&Dn(t,"complex")&&Rn(t,"tuple")&&"contains"in t&&t.contains instanceof Array&&t.contains.every((t=>e.isWrapper(t)&&(!("name"in t)||"string"==typeof t.name))),t.isArray=t=>"object"==typeof t&&!!t&&Dn(t,"complex")&&Rn(t,"array")&&"contains"in t&&e.isWrapper(t.contains),t.isMapping=t=>"object"==typeof t&&!!t&&Dn(t,"complex")&&Rn(t,"mapping")&&"contains"in t&&"object"==typeof t.contains&&!!t.contains&&"key"in t.contains&&e.isWrapper(t.contains.key)&&"value"in t.contains&&e.isWrapper(t.contains.value),t.isStruct=t=>"object"==typeof t&&!!t&&Dn(t,"complex")&&Rn(t,"struct")&&"contains"in t&&t.contains instanceof Array&&t.contains.every((t=>e.isWrapper(t)&&(!("name"in t)||"string"==typeof t.name)))&&(!("definition"in t)||e.isDefinition(t.definition))}(n=e.Complex||(e.Complex={})),e.isDefinition=e=>"object"==typeof e&&!!e&&(!("name"in e)||"string"==typeof e.name)&&(!("location"in e)||In.isSourceRange(e.location))&&(Object.keys(e).includes("name")||Object.keys(e).includes("location"))}(Pn||(Pn={}));const Dn=(e,t)=>!("class"in e)||e.class===t,Rn=(e,t)=>"kind"in e&&e.kind===t,Mn=e=>[Kn.isRegion,Kn.isCollection].some((t=>t(e)));var Kn;!function(e){let t,n,s,i;e.isIdentifier=e=>"string"==typeof e&&/^[a-zA-Z_\\-]+[a-zA-Z0-9$_\\-]*$/.test(e),e.isRegion=e=>[t.isStack,t.isMemory,t.isStorage,t.isCalldata,t.isReturndata,t.isTransient,t.isCode].some((t=>t(e))),function(e){e.isBase=e=>!!e&&"object"==typeof e&&(!("name"in e)||"string"==typeof e.name)&&"location"in e&&"string"==typeof e.location,e.isStack=t=>e.isBase(t)&&n.isSegment(t)&&"stack"===t.location,e.isMemory=t=>e.isBase(t)&&n.isSlice(t)&&"memory"===t.location,e.isStorage=t=>e.isBase(t)&&n.isSegment(t)&&"storage"===t.location,e.isCalldata=t=>e.isBase(t)&&n.isSlice(t)&&"calldata"===t.location,e.isReturndata=t=>e.isBase(t)&&n.isSlice(t)&&"returndata"===t.location,e.isTransient=t=>e.isBase(t)&&n.isSegment(t)&&"transient"===t.location,e.isCode=t=>e.isBase(t)&&n.isSlice(t)&&"code"===t.location}(t=e.Region||(e.Region={})),function(t){t.isSegment=t=>!!t&&"object"==typeof t&&"slot"in t&&e.isExpression(t.slot)&&(!("offset"in t)||e.isExpression(t.offset))&&(!("length"in t)||e.isExpression(t.length)),t.isSlice=t=>!!t&&"object"==typeof t&&"offset"in t&&e.isExpression(t.offset)&&"length"in t&&e.isExpression(t.length)}(n=e.Scheme||(e.Scheme={})),e.isCollection=e=>[s.isGroup,s.isList,s.isConditional,s.isScope,s.isReference,s.isTemplates].some((t=>t(e))),function(t){t.isGroup=e=>!!e&&"object"==typeof e&&1===Object.keys(e).length&&"group"in e&&e.group instanceof Array&&e.group.length>=1&&e.group.every(Mn),t.isList=t=>!!t&&"object"==typeof t&&1===Object.keys(t).length&&"list"in t&&!!t.list&&"object"==typeof t.list&&3===Object.keys(t.list).length&&"count"in t.list&&e.isExpression(t.list.count)&&"each"in t.list&&e.isIdentifier(t.list.each)&&"is"in t.list&&Mn(t.list.is),t.isConditional=t=>!!t&&"object"==typeof t&&"if"in t&&e.isExpression(t.if)&&"then"in t&&Mn(t.then)&&(!("else"in t)||Mn(t.else)),t.isScope=t=>!!t&&"object"==typeof t&&"define"in t&&"object"==typeof t.define&&!!t.define&&Object.keys(t.define).every((t=>e.isIdentifier(t)))&&"in"in t&&Mn(t.in),t.isReference=t=>!!t&&"object"==typeof t&&"template"in t&&"string"==typeof t.template&&!!t.template&&(!("yields"in t)||"object"==typeof t.yields&&null!==t.yields&&Object.entries(t.yields).every((([t,n])=>e.isIdentifier(t)&&e.isIdentifier(n)))),t.isTemplates=t=>!!t&&"object"==typeof t&&"templates"in t&&"object"==typeof t.templates&&!!t.templates&&Object.keys(t.templates).every(e.isIdentifier)&&Object.values(t.templates).every(e.isTemplate)&&"in"in t&&Mn(t.in)}(s=e.Collection||(e.Collection={})),e.isExpression=e=>[i.isLiteral,i.isConstant,i.isVariable,i.isArithmetic,i.isLookup,i.isRead,i.isKeccak256,i.isConcat,i.isResize].some((t=>t(e))),function(t){t.isLiteral=e=>"number"==typeof e||"string"==typeof e&&/^0x[0-9a-fA-F]+$/.test(e),t.isConstant=e=>"string"==typeof e&&["$wordsize"].includes(e),t.isVariable=t=>e.isIdentifier(t),t.isArithmetic=e=>[s.isSum,s.isDifference,s.isProduct,s.isQuotient,s.isRemainder].some((t=>t(e)));const n=(e,t)=>n=>!!n&&"object"==typeof n&&1===Object.keys(n).length&&e in n&&t(n[e]);let s,i,o;t.isOperands=t=>t instanceof Array&&t.every(e.isExpression),function(e){e.isTwoOperands=e=>t.isOperands(e)&&2===e.length,e.isSum=n("$sum",t.isOperands),e.isDifference=n("$difference",e.isTwoOperands),e.isProduct=n("$product",t.isOperands),e.isQuotient=n("$quotient",e.isTwoOperands),e.isRemainder=n("$remainder",e.isTwoOperands)}(s=t.Arithmetic||(t.Arithmetic={})),t.isReference=t=>e.isIdentifier(t)||"$this"===t,t.isLookup=e=>[i.isOffset,i.isLength,i.isSlot].some((t=>t(e))),function(e){e.propertyFrom=e=>e.slice(1),e.isOffset=n(".offset",t.isReference),e.isLength=n(".length",t.isReference),e.isSlot=n(".slot",t.isReference)}(i=t.Lookup||(t.Lookup={})),t.isRead=n("$read",t.isReference),t.isKeccak256=n("$keccak256",t.isOperands),t.isConcat=n("$concat",t.isOperands),t.isResize=e=>[o.isToWordsize,o.isToNumber].some((t=>t(e))),function(t){t.isToNumber=e=>{if(!e||"object"!=typeof e||1!==Object.keys(e).length)return!1;const[t]=Object.keys(e);return"string"==typeof t&&/^\$sized([1-9]+[0-9]*)$/.test(t)},t.isToWordsize=t=>!!t&&"object"==typeof t&&1===Object.keys(t).length&&"$wordsized"in t&&void 0!==t.$wordsized&&e.isExpression(t.$wordsized)}(o=t.Resize||(t.Resize={}))}(i=e.Expression||(e.Expression={})),e.isTemplates=t=>!!t&&"object"==typeof t&&Object.keys(t).every(e.isIdentifier)&&Object.values(t).every(e.isTemplate),e.isTemplate=t=>!!t&&"object"==typeof t&&2===Object.keys(t).length&&"expect"in t&&t.expect instanceof Array&&t.expect.every(e.isIdentifier)&&"for"in t&&Mn(t.for)}(Kn||(Kn={}));const Un=e=>[zn.isCode,zn.isVariables,zn.isRemark,zn.isPick,zn.isFrame,zn.isGather].some((t=>t(e)));var zn;!function(e){let t;e.isCode=e=>"object"==typeof e&&!!e&&"code"in e&&In.isSourceRange(e.code),e.isVariables=e=>"object"==typeof e&&!!e&&"variables"in e&&e.variables instanceof Array&&e.variables.length>0&&e.variables.every(t.isVariable),function(e){const t=new Set(["identifier","declaration","type","pointer"]);e.isVariable=e=>"object"==typeof e&&!!e&&Object.keys(e).length>0&&Object.keys(e).every((e=>t.has(e)))&&(!("identifier"in e)||"string"==typeof e.identifier)&&(!("declaration"in e)||In.isSourceRange(e.declaration))&&(!("type"in e)||Bn(e.type))&&(!("pointer"in e)||Mn(e.pointer))}(t=e.Variables||(e.Variables={})),e.isRemark=e=>"object"==typeof e&&!!e&&"remark"in e&&"string"==typeof e.remark,e.isPick=e=>"object"==typeof e&&!!e&&"pick"in e&&Array.isArray(e.pick)&&e.pick.every(Un),e.isGather=e=>"object"==typeof e&&!!e&&"gather"in e&&Array.isArray(e.gather)&&e.gather.every(Un),e.isFrame=e=>"object"==typeof e&&!!e&&"frame"in e&&"string"==typeof e.frame}(zn||(zn={}));const Fn=e=>"object"==typeof e&&!!e&&"offset"in e&&Tn.isValue(e.offset)&&(!("context"in e)||Un(e.context))&&(!("operation"in e)||Vn.isOperation(e.operation));var Vn;!function(e){e.isOperation=e=>"object"==typeof e&&!!e&&"mnemonic"in e&&"string"==typeof e.mnemonic&&(!("arguments"in e)||e.arguments instanceof Array&&e.arguments.every(Tn.isValue))}(Vn||(Vn={}));var Wn;!function(e){e.Context=zn,e.isContext=Un,e.Instruction=Vn,e.isInstruction=Fn,e.isEnvironment=e=>"string"==typeof e&&["call","create"].includes(e),e.isContract=e=>"object"==typeof e&&!!e&&"definition"in e&&In.isSourceRange(e.definition)&&(!("name"in e)||"string"==typeof e.name)}(Wn||(Wn={}))},33977(e,t,n){"use strict";var s=this&&this.__createBinding||(Object.create?function(e,t,n,s){void 0===s&&(s=n);var i=Object.getOwnPropertyDescriptor(t,n);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,s,i)}:function(e,t,n,s){void 0===s&&(s=n),e[s]=t[n]}),i=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&s(t,e,n);return i(t,e),t},r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.codeReducer=t.parseCustomization=t.parseReference=void 0;const a=o(n(14041)),c=r(n(70460)),l={code:"loading...",error:null,loading:null},p={fontSize:".9em",fontWeight:600,color:"#0E75DD",textAlign:"center",paddingBottom:"13px",textDecoration:"underline"};function d(e){const t=e.slice(e.indexOf("https"),-1),[n,s]=t.split("#"),i=globalThis||{};i.URL||(i.URL=URL);const[o,r,a,c,...l]=new i.URL(n).pathname.split("/").slice(1),[p,d]=s?s.split("-").map((e=>parseInt(e.slice(1),10)-1)):[0,1/0];return{url:`https://raw.githubusercontent.com/${o}/${r}/${c}/${l.join("/")}`,fromLine:p,toLine:d,title:l.join("/")}}function f(e){var t,n,s,i;const o=null===(n=null===(t=null==e?void 0:e.match(/title="(?<title>.*?)"/))||void 0===t?void 0:t.groups)||void 0===n?void 0:n.title,r=null==e?void 0:e.match(/referenceLinkText="(?<referenceLinkText>.*?)"/),a=null!==(i=null===(s=null==r?void 0:r.groups)||void 0===s?void 0:s.referenceLinkText)&&void 0!==i?i:"See full example on GitHub",c=null==e?void 0:e.match(/customStyling/),l=1===(null==c?void 0:c.length);return{title:o,linkText:a,noteStyling:1===(null==c?void 0:c.length)?{}:p,useCustomStyling:l}}function h(e,{type:t,value:n}){switch(t){case"reset":return l;case"loading":return{...e,loading:!0};case"loaded":return{...e,code:n,loading:!1};case"error":return{...e,error:n,loading:!1};default:return e}}t.parseReference=d,t.parseCustomization=f,t.codeReducer=h,t.default=function(e){const[t,n]=(0,a.useReducer)(h,l),s=d(e.children);!1!==t.loading&&async function({url:e,fromLine:t,toLine:n},s){let i;try{i=await fetch(e)}catch(a){return s({type:"error",value:a})}if(200!==i.status)return s({type:"error",value:await i.text()});const o=(await i.text()).split("\n").slice(t,(n||t)+1),r=o.reduce(((e,t)=>{if(0===t.length)return e;const n=t.match(/^\s+/);return n?Math.min(e,n[0].length):0}),1/0);s({type:"loaded",value:o.map((e=>e.slice(r))).join("\n")})}(s,n);const i=f(e.metastring),o={...e,metastring:i.title?` title="${i.title}"`:` title="${s.title}"`,children:l.code};return a.default.createElement("div",null,a.default.createElement(c.default,{...o},t.code),a.default.createElement("div",{style:i.noteStyling,className:i.useCustomStyling?"github-codeblock-reference-link":""},a.default.createElement("a",{href:e.children,target:"_blank"},i.linkText)))}},49499(e,t,n){"use strict";n.d(t,{A:()=>o});n(14041);var s=n(34280),i=n(31085);function o({children:e,fallback:t}){return(0,s.A)()?(0,i.jsx)(i.Fragment,{children:e?.()}):t??null}},54034(e,t,n){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=s(n(14041)),o=s(n(33977)),r=s(n(70460));e.exports=(r.default,e=>e.reference?i.default.createElement(o.default,{...e}):i.default.createElement(r.default,{...e}))},70460(e,t,n){"use strict";n.r(t),n.d(t,{default:()=>pe});var s=n(14041),i=n(34280),o=n(54357),r=n(95500),a=n(76323);function c(){const{prism:e}=(0,a.p)(),{colorMode:t}=(0,r.G)(),n=e.theme,s=e.darkTheme||n;return"dark"===t?s:n}var l=n(93796),p=n(11431),d=n.n(p),f=n(61625),h=n(31085);const u=/title=(?<quote>["'])(?<title>.*?)\1/,m=/\{(?<range>[\d,-]+)\}/,g={js:{start:"\\/\\/",end:""},jsBlock:{start:"\\/\\*",end:"\\*\\/"},jsx:{start:"\\{\\s*\\/\\*",end:"\\*\\/\\s*\\}"},bash:{start:"#",end:""},html:{start:"\x3c!--",end:"--\x3e"}},y={...g,lua:{start:"--",end:""},wasm:{start:"\\;\\;",end:""},tex:{start:"%",end:""},vb:{start:"['\u2018\u2019]",end:""},vbnet:{start:"(?:_\\s*)?['\u2018\u2019]",end:""},rem:{start:"[Rr][Ee][Mm]\\b",end:""},f90:{start:"!",end:""},ml:{start:"\\(\\*",end:"\\*\\)"},cobol:{start:"\\*>",end:""}},b=Object.keys(g);function v(e,t){const n=e.map((e=>{const{start:n,end:s}=y[e];return`(?:${n}\\s*(${t.flatMap((e=>[e.line,e.block?.start,e.block?.end].filter(Boolean))).join("|")})\\s*${s})`})).join("|");return new RegExp(`^\\s*(?:${n})\\s*$`)}function k({showLineNumbers:e,metastring:t}){return"boolean"==typeof e?e?1:void 0:"number"==typeof e?e:function(e){const t=e?.split(" ").find((e=>e.startsWith("showLineNumbers")));if(t){if(t.startsWith("showLineNumbers=")){const e=t.replace("showLineNumbers=","");return parseInt(e,10)}return 1}}(t)}function w(e,t){const{language:n,magicComments:s}=t;if(void 0===n)return{lineClassNames:{},code:e};const i=function(e,t){switch(e){case"js":case"javascript":case"ts":case"typescript":return v(["js","jsBlock"],t);case"jsx":case"tsx":return v(["js","jsBlock","jsx"],t);case"html":return v(["js","jsBlock","html"],t);case"python":case"py":case"bash":return v(["bash"],t);case"markdown":case"md":return v(["html","jsx","bash"],t);case"tex":case"latex":case"matlab":return v(["tex"],t);case"lua":case"haskell":return v(["lua"],t);case"sql":return v(["lua","jsBlock"],t);case"wasm":return v(["wasm"],t);case"vb":case"vba":case"visual-basic":return v(["vb","rem"],t);case"vbnet":return v(["vbnet","rem"],t);case"batch":return v(["rem"],t);case"basic":return v(["rem","f90"],t);case"fsharp":return v(["js","ml"],t);case"ocaml":case"sml":return v(["ml"],t);case"fortran":return v(["f90"],t);case"cobol":return v(["cobol"],t);default:return v(b,t)}}(n,s),o=e.split(/\r?\n/),r=Object.fromEntries(s.map((e=>[e.className,{start:0,range:""}]))),a=Object.fromEntries(s.filter((e=>e.line)).map((({className:e,line:t})=>[t,e]))),c=Object.fromEntries(s.filter((e=>e.block)).map((({className:e,block:t})=>[t.start,e]))),l=Object.fromEntries(s.filter((e=>e.block)).map((({className:e,block:t})=>[t.end,e])));for(let d=0;d<o.length;){const e=o[d].match(i);if(!e){d+=1;continue}const t=e.slice(1).find((e=>void 0!==e));a[t]?r[a[t]].range+=`${d},`:c[t]?r[c[t]].start=d:l[t]&&(r[l[t]].range+=`${r[l[t]].start}-${d-1},`),o.splice(d,1)}const p={};return Object.entries(r).forEach((([e,{range:t}])=>{d()(t).forEach((t=>{p[t]??=[],p[t].push(e)}))})),{code:o.join("\n"),lineClassNames:p}}function x(e,t){const n=e.replace(/\r?\n$/,"");return function(e,{metastring:t,magicComments:n}){if(t&&m.test(t)){const s=t.match(m).groups.range;if(0===n.length)throw new Error(`A highlight range has been given in code block's metastring (\`\`\` ${t}), but no magic comment config is available. Docusaurus applies the first magic comment entry's className for metastring ranges.`);const i=n[0].className,o=d()(s).filter((e=>e>0)).map((e=>[e-1,[i]]));return{lineClassNames:Object.fromEntries(o),code:e}}return null}(n,{...t})??w(n,{...t})}function $(e){const t=function(e){return t=e.language??function(e){if(!e)return;const t=e.split(" ").find((e=>e.startsWith("language-")));return t?.replace(/language-/,"")}(e.className)??e.defaultLanguage,t?.toLowerCase()??"text";var t}({language:e.language,defaultLanguage:e.defaultLanguage,className:e.className}),{lineClassNames:n,code:s}=x(e.code,{metastring:e.metastring,magicComments:e.magicComments,language:t}),i=function({className:e,language:t}){return(0,o.A)(e,t&&!e?.includes(`language-${t}`)&&`language-${t}`)}({className:e.className,language:t}),r=(a=e.metastring,(a?.match(u)?.groups.title??"")||e.title);var a;const c=k({showLineNumbers:e.showLineNumbers,metastring:e.metastring});return{codeInput:e.code,code:s,className:i,language:t,title:r,lineNumbersStart:c,lineClassNames:n}}const j=(0,s.createContext)(null);function S({metadata:e,wordWrap:t,children:n}){const i=(0,s.useMemo)((()=>({metadata:e,wordWrap:t})),[e,t]);return(0,h.jsx)(j.Provider,{value:i,children:n})}function A(){const e=(0,s.useContext)(j);if(null===e)throw new f.dV("CodeBlockContextProvider");return e}const N="codeBlockContainer_ZGJx";function E({as:e,...t}){const n=function(e){const t={color:"--prism-color",backgroundColor:"--prism-background-color"},n={};return Object.entries(e.plain).forEach((([e,s])=>{const i=t[e];i&&"string"==typeof s&&(n[i]=s)})),n}(c());return(0,h.jsx)(e,{...t,style:n,className:(0,o.A)(t.className,N,l.G.common.codeBlock)})}const O="codeBlock_TAPP",T="codeBlockStandalone_K9VJ",I="codeBlockLines_AdAo",C="codeBlockLinesWithNumbering_p5De";function _({children:e,className:t}){return(0,h.jsx)(E,{as:"pre",tabIndex:0,className:(0,o.A)(T,"thin-scrollbar",t),children:(0,h.jsx)("code",{className:I,children:e})})}const L={attributes:!0,characterData:!0,childList:!0,subtree:!0};function q(e,t){const[n,i]=(0,s.useState)(),o=(0,s.useCallback)((()=>{i(e.current?.closest("[role=tabpanel][hidden]"))}),[e,i]);(0,s.useEffect)((()=>{o()}),[o]),function(e,t,n=L){const i=(0,f._q)(t),o=(0,f.Be)(n);(0,s.useEffect)((()=>{const t=new MutationObserver(i);return e&&t.observe(e,o),()=>t.disconnect()}),[e,i,o])}(n,(e=>{e.forEach((e=>{"attributes"===e.type&&"hidden"===e.attributeName&&(t(),o())}))}),{attributes:!0,characterData:!1,childList:!1,subtree:!1})}function B({children:e}){return e}var P=n(74370);function D({line:e,token:t,...n}){return(0,h.jsx)("span",{...n})}const R="codeLine_DPDv",M="codeLineNumber_YxQB",K="codeLineContent_SOIp";function U({line:e,classNames:t,showLineNumbers:n,getLineProps:s,getTokenProps:i}){const r=function(e){const t=1===e.length&&"\n"===e[0].content?e[0]:void 0;return t?[{...t,content:""}]:e}(e),a=s({line:r,className:(0,o.A)(t,n&&R)}),c=r.map(((e,t)=>{const n=i({token:e});return(0,h.jsx)(D,{...n,line:r,token:e,children:n.children},t)}));return(0,h.jsxs)("span",{...a,children:[n?(0,h.jsxs)(h.Fragment,{children:[(0,h.jsx)("span",{className:M}),(0,h.jsx)("span",{className:K,children:c})]}):c,(0,h.jsx)("br",{})]})}const z=s.forwardRef(((e,t)=>(0,h.jsx)("pre",{ref:t,tabIndex:0,...e,className:(0,o.A)(e.className,O,"thin-scrollbar")})));function F(e){const{metadata:t}=A();return(0,h.jsx)("code",{...e,className:(0,o.A)(e.className,I,void 0!==t.lineNumbersStart&&C),style:{...e.style,counterReset:void 0===t.lineNumbersStart?void 0:"line-count "+(t.lineNumbersStart-1)}})}function V({className:e}){const{metadata:t,wordWrap:n}=A(),s=c(),{code:i,language:r,lineNumbersStart:a,lineClassNames:l}=t;return(0,h.jsx)(P.f4,{theme:s,code:i,language:r,children:({className:t,style:s,tokens:i,getLineProps:r,getTokenProps:c})=>(0,h.jsx)(z,{ref:n.codeBlockRef,className:(0,o.A)(e,t),style:s,children:(0,h.jsx)(F,{children:i.map(((e,t)=>(0,h.jsx)(U,{line:e,getLineProps:r,getTokenProps:c,classNames:l[t],showLineNumbers:void 0!==a},t)))})})})}var W=n(49499),J=n(35406);function H({className:e,...t}){return(0,h.jsx)("button",{type:"button",...t,className:(0,o.A)("clean-btn",e)})}function G(e){return(0,h.jsx)("svg",{viewBox:"0 0 24 24",...e,children:(0,h.jsx)("path",{fill:"currentColor",d:"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"})})}function Y(e){return(0,h.jsx)("svg",{viewBox:"0 0 24 24",...e,children:(0,h.jsx)("path",{fill:"currentColor",d:"M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"})})}const Q={copyButtonCopied:"copyButtonCopied_TFXo",copyButtonIcons:"copyButtonIcons_akOg",copyButtonIcon:"copyButtonIcon_a21a",copyButtonSuccessIcon:"copyButtonSuccessIcon_v2Tw"};function X(e){return e?(0,J.translate)({id:"theme.CodeBlock.copied",message:"Copied",description:"The copied button label on code blocks"}):(0,J.translate)({id:"theme.CodeBlock.copyButtonAriaLabel",message:"Copy code to clipboard",description:"The ARIA label for copy code blocks button"})}function Z({className:e}){const{copyCode:t,isCopied:n}=function(){const{metadata:{code:e}}=A(),[t,n]=(0,s.useState)(!1),i=(0,s.useRef)(void 0),o=(0,s.useCallback)((()=>{navigator.clipboard.writeText(e).then((()=>{n(!0),i.current=window.setTimeout((()=>{n(!1)}),1e3)}))}),[e]);return(0,s.useEffect)((()=>()=>window.clearTimeout(i.current)),[]),{copyCode:o,isCopied:t}}();return(0,h.jsx)(H,{"aria-label":X(n),title:(0,J.translate)({id:"theme.CodeBlock.copy",message:"Copy",description:"The copy button label on code blocks"}),className:(0,o.A)(e,Q.copyButton,n&&Q.copyButtonCopied),onClick:t,children:(0,h.jsxs)("span",{className:Q.copyButtonIcons,"aria-hidden":"true",children:[(0,h.jsx)(G,{className:Q.copyButtonIcon}),(0,h.jsx)(Y,{className:Q.copyButtonSuccessIcon})]})})}function ee(e){return(0,h.jsx)("svg",{viewBox:"0 0 24 24",...e,children:(0,h.jsx)("path",{fill:"currentColor",d:"M4 19h6v-2H4v2zM20 5H4v2h16V5zm-3 6H4v2h13.25c1.1 0 2 .9 2 2s-.9 2-2 2H15v-2l-3 3l3 3v-2h2c2.21 0 4-1.79 4-4s-1.79-4-4-4z"})})}const te="wordWrapButtonIcon_fUEG",ne="wordWrapButtonEnabled_wDKE";function se({className:e}){const{wordWrap:t}=A();if(!(t.isEnabled||t.isCodeScrollable))return!1;const n=(0,J.translate)({id:"theme.CodeBlock.wordWrapToggle",message:"Toggle word wrap",description:"The title attribute for toggle word wrapping button of code block lines"});return(0,h.jsx)(H,{onClick:()=>t.toggle(),className:(0,o.A)(e,t.isEnabled&&ne),"aria-label":n,title:n,children:(0,h.jsx)(ee,{className:te,"aria-hidden":"true"})})}const ie="buttonGroup_dke2";function oe({className:e}){return(0,h.jsx)(W.A,{children:()=>(0,h.jsxs)("div",{className:(0,o.A)(e,ie),children:[(0,h.jsx)(se,{}),(0,h.jsx)(Z,{})]})})}const re="codeBlockContent_kX1v",ae="codeBlockTitle_L5qy";function ce({className:e}){const{metadata:t}=A();return(0,h.jsxs)(E,{as:"div",className:(0,o.A)(e,t.className),children:[t.title&&(0,h.jsx)("div",{className:ae,children:(0,h.jsx)(B,{children:t.title})}),(0,h.jsxs)("div",{className:re,children:[(0,h.jsx)(V,{}),(0,h.jsx)(oe,{})]})]})}function le(e){const t=function(e){const{prism:t}=(0,a.p)();return $({code:e.children,className:e.className,metastring:e.metastring,magicComments:t.magicComments,defaultLanguage:t.defaultLanguage,language:e.language,title:e.title,showLineNumbers:e.showLineNumbers})}(e),n=function(){const[e,t]=(0,s.useState)(!1),[n,i]=(0,s.useState)(!1),o=(0,s.useRef)(null),r=(0,s.useCallback)((()=>{const n=o.current.querySelector("code");e?n.removeAttribute("style"):(n.style.whiteSpace="pre-wrap",n.style.overflowWrap="anywhere"),t((e=>!e))}),[o,e]),a=(0,s.useCallback)((()=>{const{scrollWidth:e,clientWidth:t}=o.current,n=e>t||o.current.querySelector("code").hasAttribute("style");i(n)}),[o]);return q(o,a),(0,s.useEffect)((()=>{a()}),[e,a]),(0,s.useEffect)((()=>(window.addEventListener("resize",a,{passive:!0}),()=>{window.removeEventListener("resize",a)})),[a]),{codeBlockRef:o,isEnabled:e,isCodeScrollable:n,toggle:r}}();return(0,h.jsx)(S,{metadata:t,wordWrap:n,children:(0,h.jsx)(ce,{})})}function pe({children:e,...t}){const n=(0,i.A)(),o=function(e){return s.Children.toArray(e).some((e=>(0,s.isValidElement)(e)))?e:Array.isArray(e)?e.join(""):e}(e),r="string"==typeof o?le:_;return(0,h.jsx)(r,{...t,children:o},String(n))}},71184(e,t,n){"use strict";n.d(t,{R:()=>r,x:()=>a});var s=n(14041);const i={},o=s.createContext(i);function r(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);