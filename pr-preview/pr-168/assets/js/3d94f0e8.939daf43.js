"use strict";(globalThis.webpackChunk_ethdebug_format_web=globalThis.webpackChunk_ethdebug_format_web||[]).push([[9620],{792(e,n,r){r.d(n,{A:()=>d});r(14041);var t=r(40665);const s="container_Hrln",i="link_y57m",o="label_feh8",c="schema_kJnE",a="arrow_YbSg";var l=r(31085);function d({schema:e,href:n}){return(0,l.jsx)("div",{className:s,children:(0,l.jsxs)(t.A,{to:n,className:i,children:[(0,l.jsx)("span",{className:o,children:"Schema:"}),(0,l.jsx)("span",{className:c,children:e}),(0,l.jsx)("span",{className:a,children:"\u2192"})]})})}},48044(e,n,r){r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>x,frontMatter:()=>a,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"core-schemas/programs/instructions","title":"Instructions","description":"<SpecLink","source":"@site/docs/core-schemas/programs/instructions.mdx","sourceDirName":"core-schemas/programs","slug":"/core-schemas/programs/instructions","permalink":"/format/pr-preview/pr-168/docs/core-schemas/programs/instructions","draft":false,"unlisted":false,"editUrl":"https://github.com/ethdebug/format/tree/main/packages/web/docs/core-schemas/programs/instructions.mdx","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Programs","permalink":"/format/pr-preview/pr-168/docs/core-schemas/programs/"},"next":{"title":"Variables","permalink":"/format/pr-preview/pr-168/docs/core-schemas/programs/variables"}}');var s=r(31085),i=r(71184),o=r(792),c=r(87270);const a={sidebar_position:2},l="Instructions",d={},h=[{value:"Structure",id:"structure",level:2},{value:"Operation",id:"operation",level:2},{value:"Context types",id:"context-types",level:2},{value:"Code context",id:"code-context",level:3},{value:"Variables context",id:"variables-context",level:3},{value:"Frame context",id:"frame-context",level:3},{value:"Composing contexts",id:"composing-contexts",level:2},{value:"Gather",id:"gather",level:3},{value:"Pick",id:"pick",level:3},{value:"Remark",id:"remark",level:3},{value:"Instruction ordering",id:"instruction-ordering",level:2},{value:"Learn more",id:"learn-more",level:2}];function m(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"instructions",children:"Instructions"})}),"\n",(0,s.jsx)(o.A,{schema:"ethdebug/format/program/instruction",href:"/spec/program/instruction"}),"\n",(0,s.jsx)(n.p,{children:"Each instruction record in a program corresponds to one EVM opcode in the\nbytecode. Instructions carry the context information that debuggers need."}),"\n",(0,s.jsx)(n.h2,{id:"structure",children:"Structure"}),"\n",(0,s.jsxs)(n.p,{children:["An instruction requires only ",(0,s.jsx)(n.code,{children:"offset"}),"; ",(0,s.jsx)(n.code,{children:"operation"})," and ",(0,s.jsx)(n.code,{children:"context"})," are\noptional:"]}),"\n",(0,s.jsx)(c.A,{schema:"program/instruction",href:"/spec/program/instruction",children:'{\n  "offset": 42,\n  "operation": {\n    "mnemonic": "SSTORE"\n  },\n  "context": { }\n}'}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"offset"})}),": byte position in the bytecode (the program counter\nvalue when this instruction executes)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"operation"})}),": machine operation info \u2014 includes ",(0,s.jsx)(n.code,{children:"mnemonic"}),"\n(required) and optional ",(0,s.jsx)(n.code,{children:"arguments"})," (immediate values)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"context"})}),": high-level information valid after this instruction\n(defaults to ",(0,s.jsx)(n.code,{children:"{}"})," when omitted)"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"operation",children:"Operation"}),"\n",(0,s.jsxs)(n.p,{children:["The optional ",(0,s.jsx)(n.code,{children:"operation"})," field describes the machine-level operation:"]}),"\n",(0,s.jsx)(c.A,{schema:"program/instruction",href:"/spec/program/instruction",title:"Instruction with operation",children:'{\n  "offset": 0,\n  "operation": {\n    "mnemonic": "PUSH1",\n    "arguments": ["0x60"]\n  }\n}'}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"mnemonic"})})," (required): the opcode name (e.g., ",(0,s.jsx)(n.code,{children:'"PUSH1"'}),",\n",(0,s.jsx)(n.code,{children:'"SSTORE"'}),", ",(0,s.jsx)(n.code,{children:'"ADD"'}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"arguments"})})," (optional): immediate values passed to the opcode\n(relevant for ",(0,s.jsx)(n.code,{children:"PUSH"})," instructions)"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"context-types",children:"Context types"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"context"})," field can take several forms:"]}),"\n",(0,s.jsx)(n.h3,{id:"code-context",children:"Code context"}),"\n",(0,s.jsx)(n.p,{children:"Maps the instruction to source code:"}),"\n",(0,s.jsx)(c.A,{schema:"program/context/code",href:"/spec/program/context/code",title:"Source mapping",children:'{\n  "offset": 42,\n  "context": {\n    "code": {\n      "source": { "id": 0 },\n      "range": {\n        "offset": 150,\n        "length": 16\n      }\n    }\n  }\n}'}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"source"})," field references a source file by ID and specifies the exact\ncharacter range."]}),"\n",(0,s.jsx)(n.h3,{id:"variables-context",children:"Variables context"}),"\n",(0,s.jsx)(n.p,{children:"Declares variables that are in scope:"}),"\n",(0,s.jsx)(c.A,{schema:"program/context/variables",href:"/spec/program/context/variables",title:"Variable declaration",children:'{\n  "offset": 100,\n  "context": {\n    "variables": [\n      {\n        "identifier": "amount",\n        "type": { "kind": "uint", "bits": 256 },\n        "pointer": {\n          "location": "stack",\n          "slot": 0\n        }\n      }\n    ]\n  }\n}'}),"\n",(0,s.jsx)(n.p,{children:"Each variable includes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"identifier"}),": the variable name from source code"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"type"}),": an ",(0,s.jsx)(n.strong,{children:"ethdebug/format"})," type reference"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"pointer"}),": where to find the variable's value"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"frame-context",children:"Frame context"}),"\n",(0,s.jsx)(n.p,{children:"Indicates which compilation frame the context applies to. This is\nuseful for compilers with distinct frontend/backend stages (e.g.,\nsource language vs. intermediate representation):"}),"\n",(0,s.jsx)(c.A,{schema:"program/context/frame",href:"/spec/program/context/frame",children:'{\n  "offset": 200,\n  "context": {\n    "frame": "ir"\n  }\n}'}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"frame"})," value is a string naming the compilation frame, e.g.:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:'"source"'}),": the original source language"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:'"ir"'}),": an intermediate representation"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"composing-contexts",children:"Composing contexts"}),"\n",(0,s.jsx)(n.h3,{id:"gather",children:"Gather"}),"\n",(0,s.jsx)(n.p,{children:"Combine multiple contexts (like nested scopes):"}),"\n",(0,s.jsx)(c.A,{schema:"program/context/gather",href:"/spec/program/context",title:"Combining contexts",children:'{\n  "offset": 150,\n  "context": {\n    "gather": [\n      {\n        "code": {\n          "source": { "id": 0 },\n          "range": { "offset": 200, "length": 12 }\n        }\n      },\n      {\n        "variables": [\n          {\n            "identifier": "x",\n            "type": { "kind": "uint", "bits": 256 },\n            "pointer": { "location": "stack", "slot": 0 }\n          }\n        ]\n      }\n    ]\n  }\n}'}),"\n",(0,s.jsx)(n.h3,{id:"pick",children:"Pick"}),"\n",(0,s.jsx)(n.p,{children:"Indicate that one of several possible contexts is true, possibly\nrequiring additional information to disambiguate:"}),"\n",(0,s.jsx)(c.A,{schema:"program/context/pick",href:"/spec/program/context",title:"Pick between contexts",children:'{\n  "offset": 175,\n  "context": {\n    "pick": [\n      {\n        "code": {\n          "source": { "id": 5 },\n          "range": { "offset": 68, "length": 16 }\n        }\n      },\n      {\n        "code": {\n          "source": { "id": 5 },\n          "range": { "offset": 132, "length": 16 }\n        }\n      }\n    ]\n  }\n}'}),"\n",(0,s.jsxs)(n.p,{children:["Each item in the ",(0,s.jsx)(n.code,{children:"pick"})," array is a full context object. The debugger\nmay need runtime information to determine which context applies."]}),"\n",(0,s.jsx)(n.h3,{id:"remark",children:"Remark"}),"\n",(0,s.jsx)(n.p,{children:"Add metadata without affecting scope:"}),"\n",(0,s.jsx)(c.A,{schema:"program/context/remark",href:"/spec/program/context",children:'{\n  "offset": 180,\n  "context": {\n    "remark": "loop iteration boundary"\n  }\n}'}),"\n",(0,s.jsx)(n.h2,{id:"instruction-ordering",children:"Instruction ordering"}),"\n",(0,s.jsx)(n.p,{children:"Instructions must be listed in bytecode order, matching the sequence of\nopcodes. The list is indexed by offset, so debuggers can quickly find the\ninstruction for any program counter value."}),"\n",(0,s.jsx)(n.p,{children:"Not every byte offset needs an instruction\u2014only positions where opcodes begin.\nPush data, for instance, doesn't get its own instruction entry."}),"\n",(0,s.jsx)(n.h2,{id:"learn-more",children:"Learn more"}),"\n",(0,s.jsx)(n.p,{children:"For complete schemas, see:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/spec/program/instruction",children:"Instruction schema"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/spec/program/context",children:"Context schema"})}),"\n"]})]})}function x(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(m,{...e})}):m(e)}},87270(e,n,r){r.d(n,{A:()=>x});r(14041);var t=r(40665),s=r(54034),i=r.n(s);const o="container_eo8G",c="header_CGit",a="title_NhXp",l="schemaLink_R3qF",d="schemaName_hPpq",h="schemaLabel_TlZH";var m=r(31085);function x({schema:e,href:n,children:r,title:s}){const x="string"==typeof r?r:JSON.stringify(r,null,2),p=e.startsWith("ethdebug/format/")?e:`ethdebug/format/${e}`;return(0,m.jsxs)("div",{className:o,children:[(0,m.jsxs)("div",{className:c,children:[s&&(0,m.jsx)("span",{className:a,children:s}),(0,m.jsxs)(t.A,{to:n,className:l,children:[(0,m.jsx)("span",{className:h,children:"Schema:"}),(0,m.jsx)("span",{className:d,children:p})]})]}),(0,m.jsx)(i(),{language:"json",children:x})]})}}}]);