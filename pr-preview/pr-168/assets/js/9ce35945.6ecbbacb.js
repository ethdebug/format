"use strict";(globalThis.webpackChunk_ethdebug_format_web=globalThis.webpackChunk_ethdebug_format_web||[]).push([[2124],{93091(e,n,i){i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"reference/glossary","title":"Glossary","description":"This page defines key terms used throughout the ethdebug/format specification","source":"@site/docs/reference/glossary.mdx","sourceDirName":"reference","slug":"/reference/glossary","permalink":"/format/pr-preview/pr-168/docs/reference/glossary","draft":false,"unlisted":false,"editUrl":"https://github.com/ethdebug/format/tree/main/packages/web/docs/reference/glossary.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Challenges","permalink":"/format/pr-preview/pr-168/docs/reference/challenges"}}');var s=i(31085),t=i(71184);const a={sidebar_position:3},l="Glossary",o={},c=[{value:"Core Concepts",id:"core-concepts",level:2},{value:"Pointer",id:"pointer",level:3},{value:"Region",id:"region",level:3},{value:"Cursor",id:"cursor",level:3},{value:"Type",id:"type",level:3},{value:"Program",id:"program",level:3},{value:"EVM Data Locations",id:"evm-data-locations",level:2},{value:"Storage",id:"storage",level:3},{value:"Memory",id:"memory",level:3},{value:"Stack",id:"stack",level:3},{value:"Calldata",id:"calldata",level:3},{value:"Returndata",id:"returndata",level:3},{value:"Code",id:"code",level:3},{value:"Transient Storage",id:"transient-storage",level:3},{value:"Pointer Expressions",id:"pointer-expressions",level:2},{value:"Expression",id:"expression",level:3},{value:"Variable (in Pointers)",id:"variable-in-pointers",level:3},{value:"Program Context",id:"program-context",level:2},{value:"Context",id:"context",level:3},{value:"Instruction",id:"instruction",level:3},{value:"Variable (in Programs)",id:"variable-in-programs",level:3},{value:"Execution Tracing",id:"execution-tracing",level:2},{value:"Trace",id:"trace",level:3},{value:"Machine State",id:"machine-state",level:3},{value:"Materials",id:"materials",level:2},{value:"Source",id:"source",level:3},{value:"Source Range",id:"source-range",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"glossary",children:"Glossary"})}),"\n",(0,s.jsx)(n.p,{children:"This page defines key terms used throughout the ethdebug/format specification\nand documentation."}),"\n",(0,s.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,s.jsx)(n.h3,{id:"pointer",children:"Pointer"}),"\n",(0,s.jsx)(n.p,{children:'A structured definition that describes how to locate data within EVM state.\nPointers act as "recipes" that can be evaluated against machine state to\nproduce concrete byte regions. Unlike static offsets, pointers can include\ndynamic computations (like keccak256 hashing for storage slots) that depend on\nruntime values.'}),"\n",(0,s.jsxs)(n.p,{children:["See: ",(0,s.jsx)(n.a,{href:"/docs/pointers",children:"Pointers documentation"})]}),"\n",(0,s.jsx)(n.h3,{id:"region",children:"Region"}),"\n",(0,s.jsx)(n.p,{children:"A contiguous range of bytes within a specific data location. A region\nspecifies:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Location"}),": Where the data lives (storage, memory, stack, etc.)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Offset/Slot"}),": Where in that location the region starts"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Length"}),": How many bytes the region spans"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Regions are the concrete output of pointer resolution."}),"\n",(0,s.jsxs)(n.p,{children:["See: ",(0,s.jsx)(n.a,{href:"/docs/pointers/regions",children:"Regions documentation"})]}),"\n",(0,s.jsx)(n.h3,{id:"cursor",children:"Cursor"}),"\n",(0,s.jsx)(n.p,{children:'The result of dereferencing a pointer. A cursor provides an interface for\nviewing pointer regions against different machine states. It can be thought of\nas a "resolved pointer" that knows how to extract data from the EVM.'}),"\n",(0,s.jsx)(n.h3,{id:"type",children:"Type"}),"\n",(0,s.jsxs)(n.p,{children:["A structured definition describing how to interpret bytes as meaningful data.\nTypes define the semantic meaning of raw bytes, enabling debuggers to display\nvalues in human-readable form (e.g., showing ",(0,s.jsx)(n.code,{children:"0x01"})," as ",(0,s.jsx)(n.code,{children:"true"})," for a boolean)."]}),"\n",(0,s.jsxs)(n.p,{children:["See: ",(0,s.jsx)(n.a,{href:"/docs/types",children:"Types documentation"})]}),"\n",(0,s.jsx)(n.h3,{id:"program",children:"Program"}),"\n",(0,s.jsx)(n.p,{children:"A representation of compiled code that maps bytecode instructions to their\nsemantic context. Programs describe what code means at each instruction,\nincluding:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Source code ranges"}),"\n",(0,s.jsx)(n.li,{children:"Variables in scope"}),"\n",(0,s.jsx)(n.li,{children:"Frame information"}),"\n",(0,s.jsx)(n.li,{children:"Remarks and annotations"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["See: ",(0,s.jsx)(n.a,{href:"/docs/programs",children:"Programs documentation"})]}),"\n",(0,s.jsx)(n.h2,{id:"evm-data-locations",children:"EVM Data Locations"}),"\n",(0,s.jsx)(n.h3,{id:"storage",children:"Storage"}),"\n",(0,s.jsx)(n.p,{children:"Persistent, contract-specific data that survives between transactions.\nOrganized as a key-value store where:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Keys are 32-byte ",(0,s.jsx)(n.strong,{children:"slots"})," (often computed via keccak256)"]}),"\n",(0,s.jsx)(n.li,{children:"Values are 32-byte words"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Storage is the only data location that persists after execution ends."}),"\n",(0,s.jsx)(n.h3,{id:"memory",children:"Memory"}),"\n",(0,s.jsx)(n.p,{children:"Temporary, byte-addressable scratch space available during execution. Memory:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Starts empty at the beginning of each call"}),"\n",(0,s.jsx)(n.li,{children:"Can be expanded dynamically (costs gas)"}),"\n",(0,s.jsx)(n.li,{children:"Is byte-addressed (unlike word-addressed storage)"}),"\n",(0,s.jsx)(n.li,{children:"Is cleared when the call ends"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"stack",children:"Stack"}),"\n",(0,s.jsx)(n.p,{children:"The EVM's operand stack, used for computation. The stack:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Holds 256-bit (32-byte) values"}),"\n",(0,s.jsx)(n.li,{children:"Has a maximum depth of 1024 items"}),"\n",(0,s.jsx)(n.li,{children:"Is accessed from the top (LIFO)"}),"\n",(0,s.jsx)(n.li,{children:"Is ephemeral per call frame"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"calldata",children:"Calldata"}),"\n",(0,s.jsx)(n.p,{children:"Read-only input data provided to a transaction or call. Calldata:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Is byte-addressed"}),"\n",(0,s.jsx)(n.li,{children:"Cannot be modified during execution"}),"\n",(0,s.jsx)(n.li,{children:"Contains the function selector and encoded arguments"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"returndata",children:"Returndata"}),"\n",(0,s.jsx)(n.p,{children:"Data returned by the most recent external call. Returndata:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Is byte-addressed"}),"\n",(0,s.jsx)(n.li,{children:"Is overwritten by each subsequent call"}),"\n",(0,s.jsx)(n.li,{children:"Contains the return value or revert reason"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"code",children:"Code"}),"\n",(0,s.jsx)(n.p,{children:"The deployed bytecode of a contract. Code:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Is immutable after deployment"}),"\n",(0,s.jsx)(n.li,{children:"Can be read via CODECOPY/EXTCODECOPY"}),"\n",(0,s.jsx)(n.li,{children:"Contains both executable instructions and embedded data"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"transient-storage",children:"Transient Storage"}),"\n",(0,s.jsx)(n.p,{children:"Temporary storage that persists within a transaction but is cleared at the end.\nIntroduced in EIP-1153, transient storage:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Has the same slot/word structure as persistent storage"}),"\n",(0,s.jsx)(n.li,{children:"Is cleared after each transaction"}),"\n",(0,s.jsx)(n.li,{children:"Is cheaper than persistent storage"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"pointer-expressions",children:"Pointer Expressions"}),"\n",(0,s.jsx)(n.h3,{id:"expression",children:"Expression"}),"\n",(0,s.jsx)(n.p,{children:"A computation that produces a bytes value when evaluated against machine state.\nExpressions enable pointers to describe dynamic data locations. Common\nexpression types include:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Arithmetic"}),": ",(0,s.jsx)(n.code,{children:"$sum"}),", ",(0,s.jsx)(n.code,{children:"$difference"}),", ",(0,s.jsx)(n.code,{children:"$product"}),", ",(0,s.jsx)(n.code,{children:"$quotient"}),", ",(0,s.jsx)(n.code,{children:"$remainder"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Hashing"}),": ",(0,s.jsx)(n.code,{children:"$keccak256"})," (for computing storage slots)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lookups"}),": ",(0,s.jsx)(n.code,{children:"$offset"}),", ",(0,s.jsx)(n.code,{children:"$length"}),", ",(0,s.jsx)(n.code,{children:"$slot"})," (reading from defined regions)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"References"}),": ",(0,s.jsx)(n.code,{children:"$this"}),", variables by name"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"variable-in-pointers",children:"Variable (in Pointers)"}),"\n",(0,s.jsx)(n.p,{children:"A named binding that can be referenced within a pointer definition. Variables\nallow pointers to name and reuse intermediate computations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "define": { "name": "baseSlot", "location": "storage", "slot": 0 },\n  "in": {\n    "location": "storage",\n    "slot": { "$keccak256": [{ ".slot": "baseSlot" }] }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"program-context",children:"Program Context"}),"\n",(0,s.jsx)(n.h3,{id:"context",children:"Context"}),"\n",(0,s.jsx)(n.p,{children:"Information associated with a bytecode instruction that describes its semantic\nmeaning. Contexts can include:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Code"}),": Source location"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Variables"}),": Variables entering scope"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Remark"}),": Human-readable annotation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Frame"}),": Function/call frame identifier"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"instruction",children:"Instruction"}),"\n",(0,s.jsx)(n.p,{children:"A single bytecode operation at a specific program counter offset. Instructions\ncombine:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Offset"}),": Byte position in the bytecode"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Operation"}),": The opcode and its arguments"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Context"}),": Semantic information about what the instruction does"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"variable-in-programs",children:"Variable (in Programs)"}),"\n",(0,s.jsx)(n.p,{children:"A named value in the source program that can be inspected during debugging.\nProgram variables have:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Identifier"}),": The variable's name"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Declaration"}),": Where it was defined in source"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type"}),": How to interpret the value"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Pointer"}),": Where to find the value at runtime"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"execution-tracing",children:"Execution Tracing"}),"\n",(0,s.jsx)(n.h3,{id:"trace",children:"Trace"}),"\n",(0,s.jsx)(n.p,{children:"A record of EVM execution showing the state at each step. Traces capture:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Program counter"}),"\n",(0,s.jsx)(n.li,{children:"Opcode executed"}),"\n",(0,s.jsx)(n.li,{children:"Stack contents"}),"\n",(0,s.jsx)(n.li,{children:"Memory changes"}),"\n",(0,s.jsx)(n.li,{children:"Storage modifications"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"machine-state",children:"Machine State"}),"\n",(0,s.jsx)(n.p,{children:"A snapshot of all EVM state at a specific execution point. Machine state\nincludes the current values of:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Stack"}),"\n",(0,s.jsx)(n.li,{children:"Memory"}),"\n",(0,s.jsx)(n.li,{children:"Storage"}),"\n",(0,s.jsx)(n.li,{children:"Calldata"}),"\n",(0,s.jsx)(n.li,{children:"Returndata"}),"\n",(0,s.jsx)(n.li,{children:"Program counter"}),"\n",(0,s.jsx)(n.li,{children:"Gas remaining"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"materials",children:"Materials"}),"\n",(0,s.jsx)(n.h3,{id:"source",children:"Source"}),"\n",(0,s.jsx)(n.p,{children:"Original source code associated with a compiled program. Sources are referenced\nby ID and contain the raw text content."}),"\n",(0,s.jsx)(n.h3,{id:"source-range",children:"Source Range"}),"\n",(0,s.jsx)(n.p,{children:"A reference to a specific portion of source code, defined by:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Source"}),": Which source file"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Range"}),": Offset and length within that file"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Source ranges enable mapping bytecode back to the original code that produced\nit."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);