"use strict";(globalThis.webpackChunk_ethdebug_format_web=globalThis.webpackChunk_ethdebug_format_web||[]).push([[3707],{792(e,n,s){s.d(n,{A:()=>o});s(14041);var t=s(40665);const i="container_Hrln",r="link_y57m",c="label_feh8",a="schema_kJnE",l="arrow_YbSg";var d=s(31085);function o({schema:e,href:n}){return(0,d.jsx)("div",{className:i,children:(0,d.jsxs)(t.A,{to:n,className:r,children:[(0,d.jsx)("span",{className:c,children:"Schema:"}),(0,d.jsx)("span",{className:a,children:e}),(0,d.jsx)("span",{className:l,children:"\u2192"})]})})}},76108(e,n,s){s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>y,frontMatter:()=>l,metadata:()=>t,toc:()=>p});const t=JSON.parse('{"id":"concepts/types","title":"Types","description":"This page explains the mental model behind ethdebug/format type","source":"@site/docs/concepts/types.mdx","sourceDirName":"concepts","slug":"/concepts/types","permalink":"/format/pr-preview/pr-168/docs/concepts/types","draft":false,"unlisted":false,"editUrl":"https://github.com/ethdebug/format/tree/main/packages/web/docs/concepts/types.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Overview","permalink":"/format/pr-preview/pr-168/docs/concepts/"},"next":{"title":"Pointers","permalink":"/format/pr-preview/pr-168/docs/concepts/pointers"}}');var i=s(31085),r=s(71184),c=s(792),a=s(87270);const l={sidebar_position:3},d="Types",o={},p=[{value:"Types describe structure, not location",id:"types-describe-structure-not-location",level:2},{value:"All types have a <code>kind</code> field",id:"all-types-have-a-kind-field",level:2},{value:"Known vs. unknown kinds",id:"known-vs-unknown-kinds",level:2},{value:"The base type schema",id:"the-base-type-schema",level:2},{value:"Elementary vs. complex types",id:"elementary-vs-complex-types",level:2},{value:"The <code>contains</code> field for complex types",id:"the-contains-field-for-complex-types",level:2},{value:"Single type (e.g., arrays)",id:"single-type-eg-arrays",level:3},{value:"Ordered list (e.g., structs)",id:"ordered-list-eg-structs",level:3},{value:"Object mapping (e.g., mappings)",id:"object-mapping-eg-mappings",level:3},{value:"Type wrappers and references",id:"type-wrappers-and-references",level:2},{value:"Types with definitions",id:"types-with-definitions",level:2},{value:"Next steps",id:"next-steps",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"types",children:"Types"})}),"\n",(0,i.jsx)(c.A,{schema:"ethdebug/format/type",href:"/spec/type/overview"}),"\n",(0,i.jsxs)(n.p,{children:["This page explains the mental model behind ",(0,i.jsx)(n.strong,{children:"ethdebug/format"})," type\nrepresentations. For reference documentation on specific type kinds, see the\n",(0,i.jsx)(n.a,{href:"/docs/core-schemas/types",children:"Types reference"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"types-describe-structure-not-location",children:"Types describe structure, not location"}),"\n",(0,i.jsx)(n.p,{children:'A type definition tells you what shape data takes \u2014 not where that data lives.\nFor example, a type might say "this is an array of uint256 values" without\nspecifying whether those values are in storage, memory, or calldata.'}),"\n",(0,i.jsx)(n.p,{children:"This separation is intentional:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Types"})," describe the logical structure (what the data means)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pointers"})," describe the physical location (where to find the bytes)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Together, they enable a debugger to find bytes (via the pointer) and interpret\nthem correctly (via the type). The same type definition can be used regardless\nof where the data happens to be stored."}),"\n",(0,i.jsxs)(n.h2,{id:"all-types-have-a-kind-field",children:["All types have a ",(0,i.jsx)(n.code,{children:"kind"})," field"]}),"\n",(0,i.jsxs)(n.p,{children:["Every type representation is a JSON object with a ",(0,i.jsx)(n.code,{children:"kind"})," field that identifies\nwhat kind of type it is:"]}),"\n",(0,i.jsx)(a.A,{schema:"type/elementary/uint",href:"/spec/type/elementary/uint",children:'{\n  "kind": "uint",\n  "bits": 256\n}'}),"\n",(0,i.jsx)(a.A,{schema:"type/elementary/bool",href:"/spec/type/elementary/bool",children:'{\n  "kind": "bool"\n}'}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"kind"})," field serves as a discriminator, telling parsers which schema to use\nfor validation and how to interpret the rest of the object."]}),"\n",(0,i.jsx)(n.h2,{id:"known-vs-unknown-kinds",children:"Known vs. unknown kinds"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"ethdebug/format"})," defines specific schemas for known type kinds. These\ncorrespond to reserved string values for ",(0,i.jsx)(n.code,{children:"kind"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Elementary types: ",(0,i.jsx)(n.code,{children:"uint"}),", ",(0,i.jsx)(n.code,{children:"int"}),", ",(0,i.jsx)(n.code,{children:"bool"}),", ",(0,i.jsx)(n.code,{children:"address"}),", ",(0,i.jsx)(n.code,{children:"bytes"}),", ",(0,i.jsx)(n.code,{children:"string"}),",\n",(0,i.jsx)(n.code,{children:"fixed"}),", ",(0,i.jsx)(n.code,{children:"ufixed"}),", ",(0,i.jsx)(n.code,{children:"enum"}),", ",(0,i.jsx)(n.code,{children:"contract"})]}),"\n",(0,i.jsxs)(n.li,{children:["Complex types: ",(0,i.jsx)(n.code,{children:"array"}),", ",(0,i.jsx)(n.code,{children:"struct"}),", ",(0,i.jsx)(n.code,{children:"mapping"}),", ",(0,i.jsx)(n.code,{children:"tuple"}),", ",(0,i.jsx)(n.code,{children:"alias"}),", ",(0,i.jsx)(n.code,{children:"function"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Type representations ",(0,i.jsx)(n.strong,{children:"should"})," use the specific schema when representing a\nknown type. They ",(0,i.jsx)(n.strong,{children:"must not"})," reuse reserved ",(0,i.jsx)(n.code,{children:"kind"})," values for other purposes."]}),"\n",(0,i.jsxs)(n.p,{children:["For custom types or types not covered by the format, you ",(0,i.jsx)(n.strong,{children:"may"})," use other\n",(0,i.jsx)(n.code,{children:"kind"})," values with associated external schemas. This extensibility allows the\nformat to support new languages and type systems."]}),"\n",(0,i.jsx)(n.h2,{id:"the-base-type-schema",children:"The base type schema"}),"\n",(0,i.jsxs)(n.p,{children:["All type representations \u2014 both known and unknown kinds \u2014 must conform to the\n",(0,i.jsx)(n.a,{href:"/spec/type/base",children:"base type schema"}),". This ensures a minimum level of structure\neven for custom types."]}),"\n",(0,i.jsx)(n.p,{children:"Known types have specific subschemas that extend the base with additional\nrequired fields. Unknown types must still satisfy the base constraints plus\nany additional requirements for unknown types."}),"\n",(0,i.jsx)(n.h2,{id:"elementary-vs-complex-types",children:"Elementary vs. complex types"}),"\n",(0,i.jsx)(n.p,{children:"Types fall into one of two classes:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Elementary types"})," don't contain other types. They represent atomic values:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"uint256"})," \u2014 an unsigned integer"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"address"})," \u2014 a 20-byte account identifier"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"bool"})," \u2014 true or false"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Complex types"})," compose one or more other types:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"uint256[]"})," \u2014 an array containing uint256 elements"]}),"\n",(0,i.jsx)(n.li,{children:"A struct with multiple member types"}),"\n",(0,i.jsx)(n.li,{children:"A mapping from one type to another"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["This distinction is expressed through the presence or absence of a ",(0,i.jsx)(n.code,{children:"contains"}),"\nfield. Complex types always have ",(0,i.jsx)(n.code,{children:"contains"}),"; elementary types never do."]}),"\n",(0,i.jsxs)(n.h2,{id:"the-contains-field-for-complex-types",children:["The ",(0,i.jsx)(n.code,{children:"contains"})," field for complex types"]}),"\n",(0,i.jsxs)(n.p,{children:["Complex types use ",(0,i.jsx)(n.code,{children:"contains"})," to specify what types they compose. This field is\npolymorphic \u2014 it takes one of three forms depending on the type kind:"]}),"\n",(0,i.jsx)(n.h3,{id:"single-type-eg-arrays",children:"Single type (e.g., arrays)"}),"\n",(0,i.jsx)(n.p,{children:"Arrays compose exactly one element type:"}),"\n",(0,i.jsx)(a.A,{schema:"type/complex/array",href:"/spec/type/complex/array",children:'{\n  "kind": "array",\n  "contains": {\n    "type": {\n      "kind": "uint",\n      "bits": 256\n    }\n  }\n}'}),"\n",(0,i.jsx)(n.h3,{id:"ordered-list-eg-structs",children:"Ordered list (e.g., structs)"}),"\n",(0,i.jsx)(n.p,{children:"Structs compose an ordered list of named members:"}),"\n",(0,i.jsx)(a.A,{schema:"type/complex/struct",href:"/spec/type/complex/struct",children:'{\n  "kind": "struct",\n  "contains": [\n    {\n      "name": "balance",\n      "type": { "kind": "uint", "bits": 256 }\n    },\n    {\n      "name": "owner",\n      "type": { "kind": "address" }\n    }\n  ]\n}'}),"\n",(0,i.jsx)(n.p,{children:"Member order matters \u2014 it typically matches declaration order and affects\nstorage layout."}),"\n",(0,i.jsx)(n.h3,{id:"object-mapping-eg-mappings",children:"Object mapping (e.g., mappings)"}),"\n",(0,i.jsx)(n.p,{children:"Mappings compose a key type and a value type:"}),"\n",(0,i.jsx)(a.A,{schema:"type/complex/mapping",href:"/spec/type/complex/mapping",children:'{\n  "kind": "mapping",\n  "contains": {\n    "key": { "type": { "kind": "address" } },\n    "value": { "type": { "kind": "uint", "bits": 256 } }\n  }\n}'}),"\n",(0,i.jsx)(n.h2,{id:"type-wrappers-and-references",children:"Type wrappers and references"}),"\n",(0,i.jsxs)(n.p,{children:["Notice how types in ",(0,i.jsx)(n.code,{children:"contains"})," are wrapped in ",(0,i.jsx)(n.code,{children:'{ "type": ... }'})," objects. These\n",(0,i.jsx)(n.strong,{children:"type wrappers"})," serve two purposes:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["They allow additional properties alongside the type (like ",(0,i.jsx)(n.code,{children:'"name"'})," for\nstruct members)"]}),"\n",(0,i.jsx)(n.li,{children:"They enable type references"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Instead of duplicating a type definition, you can reference it by ID:"}),"\n",(0,i.jsx)(a.A,{schema:"type/reference",href:"/spec/type/base",children:'{\n  "type": {\n    "id": "some-opaque-id"\n  }\n}'}),"\n",(0,i.jsx)(n.p,{children:"IDs can be strings or numbers. This enables:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Avoiding duplication when the same type appears multiple times"}),"\n",(0,i.jsx)(n.li,{children:"Representing recursive types (a type that contains itself)"}),"\n",(0,i.jsx)(n.li,{children:"Sharing types across multiple pointers or programs"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"types-with-definitions",children:"Types with definitions"}),"\n",(0,i.jsxs)(n.p,{children:["Some types originate from source code definitions \u2014 structs, enums, and type\naliases are explicitly defined by developers. These types may include a\n",(0,i.jsx)(n.code,{children:"definition"})," field specifying the type's name and source location:"]}),"\n",(0,i.jsx)(a.A,{schema:"type/elementary/enum",href:"/spec/type/elementary/enum",title:"Enum with source location",children:'{\n  "kind": "enum",\n  "definition": {\n    "name": "Status",\n    "source": {\n      "id": "source-id",\n      "range": { "offset": 100, "length": 45 }\n    }\n  },\n  "values": ["Pending", "Active", "Completed"]\n}'}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"definition"})," field is optional even for these types, but when present it\nenables debuggers to display the type's declared name and navigate to its\ndefinition in source code."]}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/core-schemas/types/elementary",children:"Elementary types"})})," \u2014 Reference for atomic types"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/core-schemas/types/composite",children:"Composite types"})})," \u2014 Reference for complex types"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/spec/type",children:"Type specification"})})," \u2014 Formal schema definitions"]}),"\n"]})]})}function y(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},87270(e,n,s){s.d(n,{A:()=>y});s(14041);var t=s(40665),i=s(54034),r=s.n(i);const c="container_eo8G",a="header_CGit",l="title_NhXp",d="schemaLink_R3qF",o="schemaName_hPpq",p="schemaLabel_TlZH";var h=s(31085);function y({schema:e,href:n,children:s,title:i}){const y="string"==typeof s?s:JSON.stringify(s,null,2),m=e.startsWith("ethdebug/format/")?e:`ethdebug/format/${e}`;return(0,h.jsxs)("div",{className:c,children:[(0,h.jsxs)("div",{className:a,children:[i&&(0,h.jsx)("span",{className:l,children:i}),(0,h.jsxs)(t.A,{to:n,className:d,children:[(0,h.jsx)("span",{className:p,children:"Schema:"}),(0,h.jsx)("span",{className:o,children:m})]})]}),(0,h.jsx)(r(),{language:"json",children:y})]})}}}]);