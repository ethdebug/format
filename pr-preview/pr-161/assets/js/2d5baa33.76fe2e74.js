"use strict";(globalThis.webpackChunk_ethdebug_format_web=globalThis.webpackChunk_ethdebug_format_web||[]).push([[3580],{26790(e,t,n){n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"sketches/layout","title":"@haltman-at\'s allocation data draft","description":"Initial format sketch","source":"@site/docs/sketches/layout.mdx","sourceDirName":"sketches","slug":"/sketches/layout","permalink":"/format/pr-preview/pr-161/docs/sketches/layout","draft":false,"unlisted":false,"editUrl":"https://github.com/ethdebug/format/tree/main/packages/web/docs/sketches/layout.mdx","tags":[],"version":"current","frontMatter":{"description":"Initial format sketch"},"sidebar":"docsSidebar","previous":{"title":"Prototype sketches","permalink":"/format/pr-preview/pr-161/docs/category/prototype-sketches"},"next":{"title":"@jtoman\'s format prototype","permalink":"/format/pr-preview/pr-161/docs/sketches/prototype"}}');var i=n(31085),o=n(71184);const a={description:"Initial format sketch"},r="@haltman-at's allocation data draft",l={},d=[{value:"Status of this document",id:"status-of-this-document",level:2},{value:"Goal of this document",id:"goal-of-this-document",level:2},{value:"Things this doesn&#39;t do",id:"things-this-doesnt-do",level:3},{value:"Specifying variable positions",id:"specifying-variable-positions",level:2},{value:"Positions in memory, calldata, or code",id:"positions-in-memory-calldata-or-code",level:3},{value:"Positions on the stack",id:"positions-on-the-stack",level:3},{value:"Positions in storage",id:"positions-in-storage",level:3},{value:"A note on endianness in storage",id:"a-note-on-endianness-in-storage",level:4},{value:"Specifying complex storage slots (if necessary)",id:"specifying-complex-storage-slots-if-necessary",level:4},{value:"Specifying basic types",id:"specifying-basic-types",level:2},{value:"Integers",id:"integers",level:3},{value:"Specifying layout",id:"specifying-layout",level:4},{value:"Fixed-point numbers",id:"fixed-point-numbers",level:3},{value:"Specifying layout",id:"specifying-layout-1",level:4},{value:"Short fixed-length bytestrings",id:"short-fixed-length-bytestrings",level:3},{value:"Specifying layout",id:"specifying-layout-2",level:4},{value:"Booleans",id:"booleans",level:3},{value:"Specifying layout",id:"specifying-layout-3",level:4},{value:"Addresses and other primitive types?",id:"addresses-and-other-primitive-types",level:3},{value:"Specifying layout",id:"specifying-layout-4",level:4},{value:"A note on function pointers",id:"a-note-on-function-pointers",level:4},{value:"Specifying more complex types",id:"specifying-more-complex-types",level:2},{value:"Structs and tuples",id:"structs-and-tuples",level:3},{value:"Specifying layout",id:"specifying-layout-5",level:4},{value:"Tagged unions",id:"tagged-unions",level:3},{value:"Specifying layout",id:"specifying-layout-6",level:4},{value:"Union representations of non-union types",id:"union-representations-of-non-union-types",level:3},{value:"Enumerations",id:"enumerations",level:3},{value:"Strings and bytestrings",id:"strings-and-bytestrings",level:3},{value:"Specifying layout",id:"specifying-layout-7",level:4},{value:"Mappings",id:"mappings",level:3},{value:"Specifying layout",id:"specifying-layout-8",level:4},{value:"Arrays",id:"arrays",level:3},{value:"Specifying layout",id:"specifying-layout-9",level:4},{value:"Things probably not to include for now",id:"things-probably-not-to-include-for-now",level:4}];function h(e){const t={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"haltman-ats-allocation-data-draft",children:"@haltman-at's allocation data draft"})}),"\n",(0,i.jsx)(t.h2,{id:"status-of-this-document",children:"Status of this document"}),"\n",(0,i.jsx)(t.p,{children:"This is an initial draft for review and comment. It does not have consensus and should only be cited as work in progress."}),"\n",(0,i.jsx)(t.h2,{id:"goal-of-this-document",children:"Goal of this document"}),"\n",(0,i.jsx)(t.p,{children:"To present the skeleton of a format for describing layout of complex types or variables of those types (in storage or elsewhere) that is:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Expressive enough to cover what Solidity and Vyper actually do,"}),"\n",(0,i.jsx)(t.li,{children:"Simple enough to be usable, and"}),"\n",(0,i.jsx)(t.li,{children:"Decently general, avoiding too much building in of Solidity and Vyper behaviors, and instead providing a way to specify those behaviors"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Hopefully this approximately does that! (Note that it may make assumptions based on the EVM, rather than Solidity and Vyper;\ne.g., in our discussion of endianness, we'll say that we don't need to support little-endian numbers, because the EVM makes them\ndifficult; but note this is a property of the EVM, not any particular language.)"}),"\n",(0,i.jsx)(t.p,{children:"This is something of a skeleton. One big problem that needs to be solved is to what extent this is applied to types vs to what\nextent it's applied to individual variables. For now this will basically assume it's applied to types. Of course, it is also necessary\nto describe the placement of individual variables, but hopefully with type layout information it's not necessary to individually describe\ntheir layout."}),"\n",(0,i.jsx)(t.p,{children:"So, for each type, we'll discuss what needs to be specified to specify the type itself, and then what needs to be specified to specify how it's laid out\nin each particular location.\nAlso, we'll discuss how to specify locations of individual variables."}),"\n",(0,i.jsxs)(t.p,{children:["What's written here might not be entirely compatible with what's in ",(0,i.jsx)(t.a,{href:"/format/pr-preview/pr-161/docs/sketches/prototype",children:"prototype.mdx"}),". That will need to be hammered out."]}),"\n",(0,i.jsx)(t.h3,{id:"things-this-doesnt-do",children:"Things this doesn't do"}),"\n",(0,i.jsx)(t.p,{children:"There's one big thing that this doesn't attempt, which is arrays that are directly multidimensional; more generally it doesn't cover\nanything similar, like having arrays of structs where each struct takes up multiple words but they don't all start on word boundaries\nbut rather are packed in as if it was all just primitive types. That seems to be too much complexity."}),"\n",(0,i.jsx)(t.p,{children:"There's some other weird possibilities I didn't consider, like arrays that go downward in storage instead of upward."}),"\n",(0,i.jsx)(t.h2,{id:"specifying-variable-positions",children:"Specifying variable positions"}),"\n",(0,i.jsx)(t.p,{children:"Of course, the overall location itself will need to be specified, which (for now) can be memory, calldata, code, the stack, or storage.\n(Coming soon: Transient storage?) For each location, further information is then needed to specify the position within the location."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Discussion"}),': Should position specifications include both start and end? Notionally, end is redundant if layout is specified in the\ntype information. I\'ll just discuss start here. ("End" also potentially gets a bit messy when not everything runs the same way in\nstorage.)']}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Discussion"}),': This document mentions "bytes" a lot. Should many of these mentions be "bits"? In many cases this would make no sense,\nbut in some cases, it could conceptually be possible. The problem is that using bits instead of bytes is overall less convenient but\ndoesn\'t gain much generality. But, it does gain us one important case (regarding how strings are stored in storage in Solidity),\nso we need it at least there. It seems inconsistent to use it only there and not more generally, though. So likely we should more\noften be using bits instead of bytes? Something for later.']}),"\n",(0,i.jsxs)(t.admonition,{type:"note",children:[(0,i.jsx)(t.p,{children:"@cameel comments here:"}),(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"The string format does not really require this though. You can always look at\nthe last bit just as a part of the length field. I.e. the length is specified\nas either 2N or 2N+1 and odd numbers indicate one format and even ones the\nother.\n:::"}),"\n"]}),(0,i.jsx)(t.h3,{id:"positions-in-memory-calldata-or-code",children:"Positions in memory, calldata, or code"}),(0,i.jsx)(t.p,{children:"These locations are byte-based, so here, positions can just be described as byte offsets."}),(0,i.jsx)(t.h3,{id:"positions-on-the-stack",children:"Positions on the stack"}),(0,i.jsx)(t.p,{children:"The stack is word-based. So positions can be described as stack slots (counted from the bottom), plus a byte within the slot\n(numbered from the little end?). Now this last part may seem unnecessary, as who would put two different variables in the\nsame stack slot? Well, see below regarding internal function pointers; I think we may need this."}),(0,i.jsx)(t.h3,{id:"positions-in-storage",children:"Positions in storage"}),(0,i.jsx)(t.p,{children:"Note: This presumably will apply also to transient storage, although implementation there is yet to be seen."}),(0,i.jsx)(t.p,{children:"Sometimes multiple variables are packed into the same storage slot, so we need to specify both a storage slot and a byte within that slot (from the little end, probably)."}),(0,i.jsx)(t.p,{children:"This leaves the question of specifying a storage slot -- is it sufficient to just give the slot address, or do we need to show how it was constructed? For\ntop-level variables, the slot address should be enough. So if that's all we need, we don't need to say any more. But I'll cover the other case just to be sure."}),(0,i.jsx)(t.h4,{id:"a-note-on-endianness-in-storage",children:"A note on endianness in storage"}),(0,i.jsx)(t.p,{children:'Above speaks of the "start", but what\'s the "start" in storage for, e.g., an integer packed into the middle of a word? Is it the big end or the little end?'}),(0,i.jsx)(t.p,{children:'Assuming any particular endianness in storage seems bad (in Solidity e.g. it\'s different for arrays vs bytestrings), so each type should have a storage endianness\nspecified -- which does not need to agree with the endianness of its component types! It covers only the outermost layer.\nFor something like an integer this is meaningless per se, but it is necessary to make sense of the "start" of that integer.'}),(0,i.jsxs)(t.admonition,{type:"note",children:[(0,i.jsx)(t.p,{children:"@cameel asks about this:"}),(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"How do you define endianness for arrays?\n:::"}),"\n"]}),(0,i.jsx)(t.h4,{id:"specifying-complex-storage-slots-if-necessary",children:"Specifying complex storage slots (if necessary)"}),(0,i.jsx)(t.p,{children:"A storage slot can be specified as one of the following objects:"}),(0,i.jsx)(t.p,{children:(0,i.jsx)(t.code,{children:'{ slotType: "raw", offset: bigint }'})}),(0,i.jsx)(t.p,{children:(0,i.jsx)(t.code,{children:'{ slotType: "offset", path: Slot, offset: bigint }'})}),(0,i.jsx)(t.p,{children:(0,i.jsx)(t.code,{children:'{ slotType: "hashedoffset", path: Slot, offset: bigint }'})}),(0,i.jsxs)(t.admonition,{type:"note",children:[(0,i.jsx)(t.p,{children:"@cameel asks:"}),(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"Do we need a distinction between relative and absolute locations? I.e. when\ndescribing the nested layout or something like a struct you might want to\ninterpret locations as relative but then you might still want to have some\nthings interpreted as absolute (specifically the hashed locations).\n:::"}),"\n"]}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'{\nslotType: "mapentry",\npath: Slot,\nmapType: "prefix" | "postfix" | "postfix-prehashed" | "prefix-prehashed"\nkey: <however we\'re representing bytestrings>\n}\n'})}),(0,i.jsxs)(t.p,{children:['Here, prefix vs postfix means, does the key go before the map slot, or after? "Prehashed" means we hash the key separately and then hash the ',(0,i.jsx)(t.em,{children:"result"}),'\ntogether with the map slot (Vyper does this for certain types). The possibility "prefix-prehashed" isn\'t currently used anywhere but may as well include\nit form generality.']}),(0,i.jsx)(t.p,{children:"Ideally the key might be represented as some sort of decoded value, but that seems out of scope, so let's just record the raw bytes of it, I figure."}),(0,i.jsxs)(t.p,{children:["Possibly, for types that get padded before hashing, we could restrict the ",(0,i.jsx)(t.code,{children:"key"})," field to be the bytes that actually represent the value, and\ncorrespondingly increase the set of ",(0,i.jsx)(t.code,{children:"mapType"}),"s to also include information about how the value is padded. Something to consider. See the section\non specifying mappings for more discussion of this."]}),(0,i.jsx)(t.p,{children:"Question: Allow offset on map entry? Don't really see a need for this."}),(0,i.jsx)(t.h2,{id:"specifying-basic-types",children:"Specifying basic types"}),(0,i.jsxs)(t.p,{children:["This might not need to be this complex. The suggestions in ",(0,i.jsx)(t.a,{href:"/format/pr-preview/pr-161/docs/sketches/prototype",children:"prototype.mdx"})," suggest group all these together as just primitive types\nwith just ",(0,i.jsx)(t.code,{children:"keyword"}),", ",(0,i.jsx)(t.code,{children:"bitwidth"}),", and ",(0,i.jsx)(t.code,{children:"alignment"}),". Maybe that's better? Although ",(0,i.jsx)(t.code,{children:"alignment"})," should likely distinguish between zero-padding and sign-padding."]}),(0,i.jsx)(t.h3,{id:"integers",children:"Integers"}),(0,i.jsx)(t.p,{children:"Integers can be signed or unsigned and take up a specified number of bytes. No need for anything exotic here. We assume no integer type takes\nup more than a single word."}),(0,i.jsx)(t.p,{children:(0,i.jsx)(t.code,{children:"{ signed: boolean, bytes: number }"})}),(0,i.jsx)(t.h4,{id:"specifying-layout",children:"Specifying layout"}),(0,i.jsx)(t.p,{children:"There are two things here that might need to be specified: endianness and padding. Note that since we assume no integer type takes up more than a single word,\nendianness is only a question for byte-based locations (memory, calldata, code). It's not a meaningful question for storage or the stack, as these are word-based. (However for storage layout\ninformation there should still be an endianness specified, even though it's technically meaningless, so that sense can be made of which end is the \"start\".)"}),(0,i.jsx)(t.p,{children:"The EVM only really makes big-endian easy, so we probably don't need to specify endianness, and can just assume everything is big-endian. If anyone ever does\nlittle-endian for some reason, support for that can be added later. For now though we can ignore the distinction between bytes that are earlier and bytes that\nare more significant."}),(0,i.jsx)(t.p,{children:"That leaves padding. We can specify this as follows:"}),(0,i.jsx)(t.p,{children:(0,i.jsx)(t.code,{children:'{ paddedBytes: number, paddingType: "zero" | "sign" | "right" }'})}),(0,i.jsxs)(t.admonition,{type:"note",children:[(0,i.jsx)(t.p,{children:"@cameel asks about this:"}),(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"Does bytes include paddedBytes or not?"}),"\n",(0,i.jsx)(t.p,{children:'From the note below about "bytewidth of the unpadded type" I assume it does\nnot, but perhaps that should be said explicitly.\n:::'}),"\n"]}),(0,i.jsxs)(t.p,{children:["(Here ",(0,i.jsx)(t.code,{children:'"zero"'})," means left-padded with zeroes, and ",(0,i.jsx)(t.code,{children:'"right"'})," means right-padded with zeroes; ",(0,i.jsx)(t.code,{children:'"sign"'})," means sign-padding.)"]}),(0,i.jsxs)(t.p,{children:["Likely there should be some simpler way to indicate when no padding is used (",(0,i.jsx)(t.code,{children:'{paddingType: "none"}'}),"?), but this will do."]}),(0,i.jsx)(t.p,{children:"Note we don't include the bytewidth (or bitwidth) of the unpadded type, as that's in the type information rather than the layout information. But obviously it needs to be specified somewhere."}),(0,i.jsx)(t.h3,{id:"fixed-point-numbers",children:"Fixed-point numbers"}),(0,i.jsx)(t.p,{children:"These work like integers, except we also need to specify a denominator. Two possibilities:"}),(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["Add a ",(0,i.jsx)(t.code,{children:"bigint"})," ",(0,i.jsx)(t.code,{children:"denominator"})," field"]}),"\n",(0,i.jsxs)(t.li,{children:["Add a ",(0,i.jsx)(t.code,{children:"number"})," ",(0,i.jsx)(t.code,{children:"base"})," field and a ",(0,i.jsx)(t.code,{children:"number"})," ",(0,i.jsx)(t.code,{children:"places"})," field"]}),"\n"]}),(0,i.jsx)(t.p,{children:"Either should work."}),(0,i.jsxs)(t.p,{children:["One could argue that we only need ",(0,i.jsx)(t.code,{children:"places"}),", as only decimal fixed-point is implemented in any popular EVM language (Vyper), but binary fixed-point has\nalso been discussed in the past, and there's little cost to being general here. If someone wants to do ternary fixed-point for some reason, sure, we can support that,\nthat isn't costly to include."]}),(0,i.jsx)(t.h4,{id:"specifying-layout-1",children:"Specifying layout"}),(0,i.jsx)(t.p,{children:"Same as for integers."}),(0,i.jsx)(t.h3,{id:"short-fixed-length-bytestrings",children:"Short fixed-length bytestrings"}),(0,i.jsx)(t.p,{children:'"Short" meaning "fits in a word and is treated as a primitive type". Probably this should be folded in with bytestrings more generally rather than treated\nseparately, see below about that, but this is listed here in case we want to treat it separately.'}),(0,i.jsx)(t.p,{children:"Not much to say here, just number of bytes."}),(0,i.jsx)(t.h4,{id:"specifying-layout-2",children:"Specifying layout"}),(0,i.jsx)(t.p,{children:"Same as above!"}),(0,i.jsx)(t.h3,{id:"booleans",children:"Booleans"}),(0,i.jsx)(t.p,{children:"It's a boolean, nothing to say here."}),(0,i.jsx)(t.h4,{id:"specifying-layout-3",children:"Specifying layout"}),(0,i.jsx)(t.p,{children:"Same as above!"}),(0,i.jsx)(t.h3,{id:"addresses-and-other-primitive-types",children:"Addresses and other primitive types?"}),(0,i.jsx)(t.p,{children:"Addresses are often treated as primitive? The idea of not separating out primitive types is starting to sound like a better idea. So maybe that's the thing to do, or maybe we can have the types above\nand then just have a bucket for other primitives, such as addresses."}),(0,i.jsx)(t.h4,{id:"specifying-layout-4",children:"Specifying layout"}),(0,i.jsx)(t.p,{children:"Same as above!"}),(0,i.jsx)(t.h4,{id:"a-note-on-function-pointers",children:"A note on function pointers"}),(0,i.jsx)(t.p,{children:"What about function pointers? Those are treated as a primitive type in Solidity!"}),(0,i.jsx)(t.p,{children:"Well, external function pointers decompose into two parts, an address and a selector. So I think they should be treated as a complex type for our purposes here.\nInternal function pointers also decompose into two parts in non-IR Solidity."}),(0,i.jsxs)(t.p,{children:["But, in IR Solidity, they don't decompose. Also, in non-IR Solidity, what do they decompose into? We might want some way to mark one of these miscellaneous primitive types\nas an internal function pointer, so that whatever's reading this format can know to treat them as that. (I don't see that we need this for external function pointers, since\neach ",(0,i.jsx)(t.em,{children:"part"})," of those is meaningful without this annotation.)"]}),(0,i.jsxs)(t.admonition,{type:"note",children:[(0,i.jsx)(t.p,{children:"@cameel adds:"}),(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"They decompose into two separate jump destinations: one into the creation\ncode, the other into the deployed code. But this is something that feels like\nan implementation detail so not sure it has a place here.\n:::"}),"\n"]}),(0,i.jsx)(t.h2,{id:"specifying-more-complex-types",children:"Specifying more complex types"}),(0,i.jsx)(t.h3,{id:"structs-and-tuples",children:"Structs and tuples"}),(0,i.jsx)(t.p,{children:"This can include things that may not necessarily be structs according to the language, but similarly contain a fixed number of parts and which aren't arrays.\nSo, for instance, as suggested above, external function pointers could be handled here, as well as internal function pointers in non-IR Solidity (of course then the two\ncomponents of that need to be handled some other way)."}),(0,i.jsx)(t.p,{children:"Anyway, obviously, you have to specify the component types and their order."}),(0,i.jsx)(t.h4,{id:"specifying-layout-5",children:"Specifying layout"}),(0,i.jsx)(t.p,{children:"For byte-based locations: Each component needs to have its starting offset specified, but that's not enough. Each one also needs padding specified.\nYou can also specify an overall length for the whole thing, which is useful for in storage specifying that it should take up a whole number of words;\nfor storage this should be allowed in bytes or in words."}),(0,i.jsx)(t.p,{children:"Also, each component needs to have specified how it's stored. Based on how things are done in Solidity and Vyper, we can have several possibilities:"}),(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"It's stored inline. (This includes reference types in storage; they're not always \"inline\" per se\nbut they're inline for our purposes.)"}),"\n",(0,i.jsx)(t.li,{children:"It's stored as a pointer. In this case we'll need to specify the length of the pointer."}),"\n",(0,i.jsx)(t.li,{children:"It's stored as a relative pointer. Now, in Solidity, when relative pointers are used, they're not relative to\nthe current location, they're relative to the start of the container they're inside. We can allow for both possibilities,\nprobably (relative pointers aren't so exotic). And of course we need to know the length of the pointer."}),"\n"]}),(0,i.jsxs)(t.admonition,{type:"note",children:[(0,i.jsx)(t.p,{children:"@cameel adds:"}),(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"In the future in Solidity also pointers to data stored in other locations\nwill be possible. Things like a storage struct nested inside a memory struct.\nThe concept of located types in the main spec already allows for that in full\ngenerality.\n:::"}),"\n"]}),(0,i.jsx)(t.p,{children:"For the stack: Overall this is similar? Structs don't live on the stack, but function pointers do. It'll be necessary here\nto use the ability to specify particular bytes within a stack slot. Alternatively, if we don't want to allow that,\nbecause we don't think splitting up internal function pointers is a good idea, we could allow separately specifying the padding\nin each stack slot (this is necessary to handle Solidity's external function pointers, assuming we're handling them under this)."}),(0,i.jsxs)(t.admonition,{type:"note",children:[(0,i.jsx)(t.p,{children:"@cameel adds:"}),(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"In the future structs will be allowed to live anywhere.\n:::"}),"\n"]}),(0,i.jsxs)(t.p,{children:["For storage: We ",(0,i.jsx)(t.em,{children:"could"})," do something complicated, assuming that structs might get relocated in all sorts of weird ways,\nbut this is probably not a good idea to start with. Instead we'll just assume that each struct either:"]}),(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"always start on a word boundary and so is always laid out internally in the same way, so we can give the\nlocations of the components relative to the start of the struct, or"}),"\n",(0,i.jsx)(t.li,{children:"is no more than a single word in length and never crosses word boundaries, in which case we can give positions\nwithin the single word it's contained within (byte offsets relative to the start; endianness would have to be\nmarked to make these meaningful)."}),"\n"]}),(0,i.jsx)(t.p,{children:"It'll probably be necessary to include an explicit tag to distinguish between these two cases. Note the second\ncase is included to cover things that aren't actually structs but decompose into multiple parts."}),(0,i.jsx)(t.h3,{id:"tagged-unions",children:"Tagged unions"}),(0,i.jsx)(t.p,{children:"These don't currently exist in Solidity or Vyper, but we should probably handle them? Pyramid had them (in that\nit was dynamically typed so everything was one)."}),(0,i.jsxs)(t.admonition,{type:"note",children:[(0,i.jsx)(t.p,{children:"@cameel notes:"}),(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"They're planned in Solidity and may already exist in Fe. In Solidity they\nwill most likely be implemented in a form similar to Rust's enums with data.\nAlgebraic types in general will be possible in the future.\n:::"}),"\n"]}),(0,i.jsx)(t.p,{children:"For the type, we say what it's a union of."}),(0,i.jsx)(t.h4,{id:"specifying-layout-6",children:"Specifying layout"}),(0,i.jsx)(t.p,{children:"So, we have to specify where to find the tag, and what to do in each case."}),(0,i.jsxs)(t.p,{children:["For where to find the tag, we can give a start position and a length; note that for the reasons discussed below,\nwe may want to allow the tag to be have start and length given in individual ",(0,i.jsx)(t.em,{children:"bits"})," rather than bytes."]}),(0,i.jsx)(t.p,{children:"For each option, then, we can give a layout specification and a start point."}),(0,i.jsx)(t.h3,{id:"union-representations-of-non-union-types",children:"Union representations of non-union types"}),(0,i.jsx)(t.p,{children:"So, this is a bit funky, but what if we allowed union representations of non-union types?"}),(0,i.jsx)(t.p,{children:"That is, a type could indicate that in a particular location, it had a tagged union representation;\nas with tagged unions, it would be specified where to find the tag, and then there'd be an object for each case.\nBut the object would specify a layout, not a type!"}),(0,i.jsx)(t.p,{children:"This would allow handling Solidity storage strings. The last bit of the word would be the tag. In case 0,\nbits 1-31 are the length, and bits 32-255 are the contents. (So, we'd need to be able to specify individual\nbits here, not just bytes. Of course that's partly a concern for strings, not unions.) In case 1, bits 1-255 are\nthe length, and we specify that the contents are at a hashed location. (Note that if we use the ideas below,\nwe wouldn't actually specify the end of the contents, only the start.)"}),(0,i.jsxs)(t.p,{children:["Of course, doing this means that all ",(0,i.jsx)(t.em,{children:"ordinary"})," representations descriptions would need to have an additional\nfield to specify that they're not a union. Or perhaps this information could go in a field outside the representation\ndescription, to avoid that?"]}),(0,i.jsx)(t.h3,{id:"enumerations",children:"Enumerations"}),(0,i.jsx)(t.p,{children:"Maybe these are treated like primitive types? Maybe they're treated like tagged unions whose unioned types are all the unit type? In that case we'd need to be able\nto represent the unit type."}),(0,i.jsxs)(t.admonition,{type:"note",children:[(0,i.jsx)(t.p,{children:"@cameel adds:"}),(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:["This ",(0,i.jsx)(t.em,{children:"might"})," need specifying the size in bytes. In older Solidity versions\nenums took a variable number of bytes, depending on the number of members.\nNow they're limited to 256 members so 1 byte\n(",(0,i.jsx)(t.a,{href:"https://github.com/ethereum/solidity/pull/10247",children:"https://github.com/ethereum/solidity/pull/10247"}),"). Other languages could be\ndoing it differently.\n:::"]}),"\n"]}),(0,i.jsx)(t.h3,{id:"strings-and-bytestrings",children:"Strings and bytestrings"}),(0,i.jsx)(t.p,{children:"Type information: Is it a string or a bytestring? Is there a bound on its length? Is the bound an exact length it must be (as has been proposed for Solidity), or is it a cap (as in Vyper)?"}),(0,i.jsx)(t.p,{children:"We probably don't need to bother with questions of string encodings, everything can be assumed to be UTF-8. Possibly we could have a separate type for ASCII-only strings,\nsince some languages may want that as a separate type (Solidity has separate literals for with or without Unicode, though not separate types).\nWe probably don't need Latin-1 strings or anything like that."}),(0,i.jsx)(t.h4,{id:"specifying-layout-7",children:"Specifying layout"}),(0,i.jsxs)(t.p,{children:["For numbers, endianness was potentially a concern for byte-based locations. Here, it's not; instead it's potentially a concern for storage, since it's ",(0,i.jsx)(t.em,{children:"not"})," byte-based. Once again, though,\nthe EVM makes big-endian easy and little-endian hard, so we'll just assume big-endian and not include an endianness specification."]}),(0,i.jsx)(t.p,{children:"(On the other hand, Solidity does little-endian for arrays, so...?)"}),(0,i.jsxs)(t.p,{children:["For ones of fixed (not merely bounded) length, there's not much to specify. We're assuming big-endian, and the start is stored elsewhere. We may want\nto allow an offset in case the length is stored redundantly? Also, for storage specifically, we do have to notate whether the\nstring is stored at the ",(0,i.jsx)(t.em,{children:"actual"})," specified start, or at a hashed location. So, ",(0,i.jsx)(t.code,{children:"{ hashSlot: boolean }"}),"."]}),(0,i.jsx)(t.p,{children:"For ones of variable length, we have more work to do, as we have to specify where to find both the length and the contents."}),(0,i.jsx)(t.p,{children:"For storage, we can reasonably assume that strings have the two cases that structs do (possibly just the first but seems less clear we should assume that).\n(Actually, if we don't assume that, possibly we could fold primitive bytestrings into the fixed-length case here as well. There may be some situations that warrant\ndistinguishing, but that could likely be handled by explicitly tagging the different types as different types, not representing them differently\ninternally aside from the tag.)"}),(0,i.jsx)(t.p,{children:"So, we can specify where to find the length, the length of the length (or that can be determined by giving the length a type?), and the start of the contents. For byte-based locations\nthat suffices."}),(0,i.jsx)(t.p,{children:"However in storage, when we specify the offset, we also have to specify (for both the length and the contents separately!) whether the offset is relative\nto the current slot or to the hash of the current slot."}),(0,i.jsx)(t.p,{children:"You can also specify an overall length for the whole thing, which is useful for in storage specifying that it should take up a whole number of words;\nfor storage this should be allowed in bytes or in words."}),(0,i.jsx)(t.p,{children:"Of course, Solidity famously does something more complicated with its strings, see union representation of non-union types for a possibility regarding handling that."}),(0,i.jsx)(t.h3,{id:"mappings",children:"Mappings"}),(0,i.jsx)(t.p,{children:"Have to specify key and value types, obviously."}),(0,i.jsx)(t.p,{children:"Mappings are weird and specific enough that it makes sense to build-in a lot of the behavior rather than attempting to be very general."}),(0,i.jsx)(t.h4,{id:"specifying-layout-8",children:"Specifying layout"}),(0,i.jsx)(t.p,{children:"We'll just assume all mappings use something like Solidity or Vyper's system. In this case, what needs to be specified for a given mapping is:"}),(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Does the key go before the slot, or after?"}),"\n",(0,i.jsx)(t.li,{children:"Is the key pre-hashed, like for strings in Vyper?"}),"\n",(0,i.jsx)(t.li,{children:'Is the key padded at all, and if so how? I.e., to what width and with which padding type. (Notionally this padding information could go in the key type itself, adding a "key" location for this purpose. I am not assuming that\nall locations get the same type of padding because this has not always been true in all versions of Solidity.)'}),"\n"]}),(0,i.jsxs)(t.p,{children:["Probably it is best to combine (1) and (2) into a ",(0,i.jsx)(t.code,{children:"mapType"})," and keep (3) separate as a ",(0,i.jsx)(t.code,{children:"paddingType"}),"."]}),(0,i.jsx)(t.h3,{id:"arrays",children:"Arrays"}),(0,i.jsxs)(t.p,{children:["Note: This will exclude strings and bytestrings, handling them separately above, unlike ",(0,i.jsx)(t.a,{href:"/format/pr-preview/pr-161/docs/sketches/prototype",children:"prototype.mdx"}),"; another difference that will have to be figured out."]}),(0,i.jsx)(t.p,{children:"We can split these into fixed-length and variable length (whether bounded or unbounded). And then you've got the base type."}),(0,i.jsx)(t.h4,{id:"specifying-layout-9",children:"Specifying layout"}),(0,i.jsx)(t.p,{children:"Oh boy, arrays. This is where it truly gets messy if we want to be general. Probably some generality will have to be\naxed here for the sake of simplicity."}),(0,i.jsx)(t.p,{children:"If the array is variable length, you need to specify the start of the length and of the contents;\nfor fixed-length, only the latter (it may not be at the start as the length may be stored redundantly). You also need to specify the\nlength of the length, or perhaps that can be handled by giving the length a type."}),(0,i.jsx)(t.p,{children:"In the case of storage, as is typical, this requires not only specifying an offset but also whether to hash the slot (this is separate\nfor the length and for the contents!)."}),(0,i.jsx)(t.p,{children:"Also, as with structs, you're going to have to specify whether the base type is stored inline, or whether it's a pointer, or whether it's\na relative pointer and of what sort."}),(0,i.jsx)(t.p,{children:"You can once again also specify an overall length for the whole thing, which is useful for in storage specifying that it should take up a whole number of words;\nfor storage this should be allowed in bytes or in words."}),(0,i.jsx)(t.p,{children:"What about padding of the elements? Well, that's the messy part... the stride pattern."}),(0,i.jsxs)(t.p,{children:["See, we ",(0,i.jsx)(t.em,{children:"could"})," just specify padding for the base type (what it's padded to and with what padding type). But this wouldn't suffice to\nhandle the case of how Solidity does arrays in storage! Maybe we can make this optional -- you can give a ",(0,i.jsx)(t.code,{children:"paddedWith"})," and ",(0,i.jsx)(t.code,{children:"paddingType"}),",\n",(0,i.jsx)(t.em,{children:"or"})," you can use the more complicated stride pattern system."]}),(0,i.jsx)(t.p,{children:"Note that for storage you will also need to specify an endianness, since storage is word-based rather than byte-based.\nSolidity does arrays little-endian! So we really do need this to be specified here. This could be specified for every\nlocation for consistency, but that seems unnecessary."}),(0,i.jsx)(t.p,{children:"Anyway, stride patterns. Here's a simple proposal for how a stride pattern might be represented."}),(0,i.jsxs)(t.p,{children:["A stride pattern will be an array of objects, each of which is one of the following: ",(0,i.jsx)(t.code,{children:'{ type: "element" }'}),", ",(0,i.jsx)(t.code,{children:'{ type: "zero", length: number }'}),", or ",(0,i.jsx)(t.code,{children:'{ type: "sign", length: number }'}),"."]}),(0,i.jsxs)(t.p,{children:["A stride pattern is interpreted as follows: ",(0,i.jsx)(t.code,{children:'"element"'})," means an element goes here, of its appropriate length (no padding). The ",(0,i.jsx)(t.code,{children:'"zero"'})," type means this many bytes of zeroes.\nAnd (this isn't currently necessary, but) ",(0,i.jsx)(t.code,{children:'"sign"'})," will mean this many bytes of sign-padding, where the thing it's sign-padding is determined from context\n(in big-endian contexts, it's the next thing; in little-endian contexts, the previous thing). The stride pattern is implicitly periodic; the number of ",(0,i.jsx)(t.code,{children:'"element"'})," entries is not\nsupposed to match that of the array, rather, when you get to the end of the stride pattern you go back to the start."]}),(0,i.jsxs)(t.p,{children:["In a byte-based location, this means what it sounds like. In storage, you have to read according to the endianness that was specified. Note it's assumed that no element\nthat fits in a word will cross a word boundary, and that you won't use ",(0,i.jsx)(t.code,{children:'"sign"'})," in places it doesn't make sense, that you won't have structs that are supposed to start\non a word boundary start elsewhere, etc."]}),(0,i.jsx)(t.p,{children:"In addition to the stride pattern, you can separately specify padding for the array as a whole (useful for making clear that it should take up a whole number of words)."}),(0,i.jsx)(t.p,{children:"Solidity examples:"}),(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"uint256[]"})," -- it takes up the whole word, so the pattern is ",(0,i.jsx)(t.code,{children:'[{ type: "element" }]'})]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"uint128[]"})," -- there's two of them, so ",(0,i.jsx)(t.code,{children:'[{ type: "element" }, { type: "element" }]'})]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"uint96[]"})," -- there's two of them and then 64 bytes of padding, so ",(0,i.jsx)(t.code,{children:'[{ type: "element" }, { type: "element" }, { type: "zero", length: 64 }]'})]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"uint96[3][]"})," -- a ",(0,i.jsx)(t.code,{children:"uint96[3]"})," takes up two full words always, so just ",(0,i.jsx)(t.code,{children:'[{ type: "element" }]'})," suffices; what goes on inside the ",(0,i.jsx)(t.code,{children:"uint96[3]"})," can be handled inside there"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"uint96[3]"})," -- the stride pattern is ",(0,i.jsx)(t.code,{children:'[{ type: "element" }, { type: "element" }, { type: "zero", length: 64 }]'})," as above, but now we should ",(0,i.jsx)(t.em,{children:"also"})," specify that the array as\na whole has an overall length of two words, so that in a ",(0,i.jsx)(t.code,{children:"uint96[3][]"}),", there's no confusion about the fact that each one should start on a fresh word boundary.\n(Not that it would be legal to start it anywhere else, but it should still be explicitly specified, not left as error-recovery behavior.)"]}),"\n"]}),(0,i.jsx)(t.h4,{id:"things-probably-not-to-include-for-now",children:"Things probably not to include for now"}),(0,i.jsx)(t.p,{children:"Probably don't attempt to handle arrays that are directly multidimensional (as opposed to\nmultidimensional arrays just being ordinary arrays of arrays). Allowing this also raises possibility\nof a flag for row-major vs column-major order. Probably best to just exclude this for now."}),(0,i.jsxs)(t.admonition,{type:"note",children:[(0,i.jsx)(t.p,{children:"@haltman-at notes in a comment (after writing this)"}),(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"Oh, geez, I just realized there's something big I left out: How things are\npointed to on the stack. Actually, one could perhaps speak of cross-location\npointers in general, but as that doesn't exist mostly at the moment, probably\nno sense in including that; it's premature."}),"\n",(0,i.jsxs)(t.p,{children:["But, I guess something that needs to be added is, for each type, for the\nstack location, I talked about from/to but really we also need to say, does\nthis thing live directly on the stack or is it pointed to. And if it's\npointed to, we need to specify the pointer format -- do we just point to the\nstart, or do we have start/length? And then if it's start/length we need to\nbreak down which part is the start and which part is the length... also, for\nlength, we likely want to be able to specify what the length is measured in\n-- for instance it could potentially be ",(0,i.jsx)(t.code,{children:'"bytes"'})," or ",(0,i.jsx)(t.code,{children:'"words"'})," or ",(0,i.jsx)(t.code,{children:'"items"'}),"."]}),"\n",(0,i.jsx)(t.p,{children:"(Yes this should be added to the PR itself but I don't have a lot of time at\nthe moment)\n:::"}),"\n"]})]})]})]})]})]})]})]})]})]})]})]})}function c(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);