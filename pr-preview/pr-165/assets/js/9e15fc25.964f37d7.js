"use strict";(globalThis.webpackChunk_ethdebug_format_web=globalThis.webpackChunk_ethdebug_format_web||[]).push([[7557],{38898(e,n,t){t.d(n,{A:()=>g});var a=t(14041),i=t(76323);function o(e){const n=e.map((e=>({...e,parentIndex:-1,children:[]}))),t=Array(7).fill(-1);n.forEach(((e,n)=>{const a=t.slice(2,e.level);e.parentIndex=Math.max(...a),t[e.level]=n}));const a=[];return n.forEach((e=>{const{parentIndex:t,...i}=e;t>=0?n[t].children.push(i):a.push(i)})),a}function s({toc:e,minHeadingLevel:n,maxHeadingLevel:t}){return e.flatMap((e=>{const a=s({toc:e.children,minHeadingLevel:n,maxHeadingLevel:t});return function(e){return e.level>=n&&e.level<=t}(e)?[{...e,children:a}]:a}))}function r(e){const n=e.getBoundingClientRect();return n.top===n.bottom?r(e.parentNode):n}function l(e,{anchorTopOffset:n}){const t=e.find((e=>r(e).top>=n));if(t){return function(e){return e.top>0&&e.bottom<window.innerHeight/2}(r(t))?t:e[e.indexOf(t)-1]??null}return e[e.length-1]??null}function d(){const e=(0,a.useRef)(0),{navbar:{hideOnScroll:n}}=(0,i.p)();return(0,a.useEffect)((()=>{e.current=n?0:document.querySelector(".navbar").clientHeight}),[n]),e}function h(e){const n=(0,a.useRef)(void 0),t=d();(0,a.useEffect)((()=>{if(!e)return()=>{};const{linkClassName:a,linkActiveClassName:i,minHeadingLevel:o,maxHeadingLevel:s}=e;function r(){const e=function(e){return Array.from(document.getElementsByClassName(e))}(a),r=function({minHeadingLevel:e,maxHeadingLevel:n}){const t=[];for(let a=e;a<=n;a+=1)t.push(`h${a}.anchor`);return Array.from(document.querySelectorAll(t.join()))}({minHeadingLevel:o,maxHeadingLevel:s}),d=l(r,{anchorTopOffset:t.current}),h=e.find((e=>d&&d.id===function(e){return decodeURIComponent(e.href.substring(e.href.indexOf("#")+1))}(e)));e.forEach((e=>{!function(e,t){t?(n.current&&n.current!==e&&n.current.classList.remove(i),e.classList.add(i),n.current=e):e.classList.remove(i)}(e,e===h)}))}return document.addEventListener("scroll",r),document.addEventListener("resize",r),r(),()=>{document.removeEventListener("scroll",r),document.removeEventListener("resize",r)}}),[e,t])}var c=t(40665),p=t(31085);function u({toc:e,className:n,linkClassName:t,isChild:a}){return e.length?(0,p.jsx)("ul",{className:a?void 0:n,children:e.map((e=>(0,p.jsxs)("li",{children:[(0,p.jsx)(c.A,{to:`#${e.id}`,className:t??void 0,dangerouslySetInnerHTML:{__html:e.value}}),(0,p.jsx)(u,{isChild:!0,toc:e.children,className:n,linkClassName:t})]},e.id)))}):null}const f=a.memo(u);function g({toc:e,className:n="table-of-contents table-of-contents__left-border",linkClassName:t="table-of-contents__link",linkActiveClassName:r,minHeadingLevel:l,maxHeadingLevel:d,...c}){const u=(0,i.p)(),g=l??u.tableOfContents.minHeadingLevel,m=d??u.tableOfContents.maxHeadingLevel,y=function({toc:e,minHeadingLevel:n,maxHeadingLevel:t}){return(0,a.useMemo)((()=>s({toc:o(e),minHeadingLevel:n,maxHeadingLevel:t})),[e,n,t])}({toc:e,minHeadingLevel:g,maxHeadingLevel:m});return h((0,a.useMemo)((()=>{if(t&&r)return{linkClassName:t,linkActiveClassName:r,minHeadingLevel:g,maxHeadingLevel:m}}),[t,r,g,m])),(0,p.jsx)(f,{toc:y,className:n,linkClassName:t,...c})}},57821(e,n,t){t.d(n,{A:()=>s});t(14041);var a=t(38898);const i="tableOfContentsInline_JBRb";var o=t(31085);function s({toc:e,minHeadingLevel:n,maxHeadingLevel:t}){return(0,o.jsx)("div",{className:i,children:(0,o.jsx)(a.A,{toc:e,minHeadingLevel:n,maxHeadingLevel:t,className:"table-of-contents",linkClassName:null})})}},69113(e,n,t){t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"known-challenges","title":"Known challenges","description":"The fundamental challenge for an Ethereum debugging data format is that, on the","source":"@site/docs/known-challenges.mdx","sourceDirName":".","slug":"/known-challenges","permalink":"/format/pr-preview/pr-165/docs/known-challenges","draft":false,"unlisted":false,"editUrl":"https://github.com/ethdebug/format/tree/main/packages/web/docs/known-challenges.mdx","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Goals","permalink":"/format/pr-preview/pr-165/docs/goals"},"next":{"title":"Prototype sketches","permalink":"/format/pr-preview/pr-165/docs/category/prototype-sketches"}}');var i=t(31085),o=t(71184),s=t(57821);const r={sidebar_position:2},l="Known challenges",d={},h=[{value:"Different data formats per location",id:"different-data-formats-per-location",level:2},{value:"The word-based nature of storage and the stack",id:"the-word-based-nature-of-storage-and-the-stack",level:2},{value:"Complex stride patterns",id:"complex-stride-patterns",level:2},{value:"The use of hash-based locations",id:"the-use-of-hash-based-locations",level:2},{value:"Solidity&#39;s two-case string storage",id:"soliditys-two-case-string-storage",level:2},{value:"Mappings",id:"mappings",level:2},{value:"Markings for mapping keys",id:"markings-for-mapping-keys",level:2},{value:"The use of pointers in or to calldata",id:"the-use-of-pointers-in-or-to-calldata",level:2},{value:"Internal function pointers",id:"internal-function-pointers",level:2},{value:"Lack of fixed variable locations on the stack",id:"lack-of-fixed-variable-locations-on-the-stack",level:2},{value:"The possibility of handling other languages",id:"the-possibility-of-handling-other-languages",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"known-challenges",children:"Known challenges"})}),"\n",(0,i.jsx)(n.p,{children:"The fundamental challenge for an Ethereum debugging data format is that, on the\none hand, we want it to be able to handle the complexity of Solidity and other\nexisting EVM languages; but also, we wish to handle these in a suitably general\nmanner rather than simply assuming this complexity, so that it may handle other\nlanguages in the future; but also, we want to keep down the complexity of the\nformat itself if possible."}),"\n",(0,i.jsx)(n.p,{children:"In what follows we'll outline some particular thorns of the EVM in general and\nSolidity and Vyper in particular that will have to be addressed. This is not\nnecessarily a complete list."}),"\n",(0,i.jsx)(s.A,{toc:h}),"\n",(0,i.jsx)(n.h2,{id:"different-data-formats-per-location",children:"Different data formats per location"}),"\n",(0,i.jsx)(n.p,{children:"Any debugging data format will need to handle the fact that in both Solidity and\nin Vyper the same type can have different representations depending on which\nlocation (the stack, memory, storage, calldata, or code) it is stored in. As\nsuch it does not suffice to give a single representation for a single type, but\nrather, it may be necessary to specify multiple representations, corresponding\nto the different data locations."}),"\n",(0,i.jsx)(n.h2,{id:"the-word-based-nature-of-storage-and-the-stack",children:"The word-based nature of storage and the stack"}),"\n",(0,i.jsx)(n.p,{children:"Of the data locations mentioned above, most are byte-based, but two, the stack\nand storage, are word-based. This will likely necessitate slightly different\nhandling for them."}),"\n",(0,i.jsxs)(n.p,{children:["Moreover, the fact that these two locations are word-based means there can be a\nneed to specify endianness. For instance, in Solidity, arrays may pack multiple\nelements into the same storage word, starting from the low byte. However,\nsegments of strings in storage start at the high byte of their word. So it will\nbe necessary to have a way to specify this. (In particular, consider the case\nof a ",(0,i.jsx)(n.code,{children:"bytes2[] storage"}),"; each ",(0,i.jsx)(n.code,{children:"bytes2"})," is packed into the word in a\nlittle-endian order, but each ",(0,i.jsx)(n.code,{children:"bytes2"})," itself is stored in a big-endian order.)"]}),"\n",(0,i.jsx)(n.p,{children:"(Of course, there can also be a need to specify endianness in byte-based\nlocations, e.g. for storage of integers. Currently all EVM languages known to\nme do this in a big-endian fashion, because this is what the EVM makes\nconvenient. It may be OK to assume that integers are big-endian, but the\nreverse possibility is at least worth noting.)"}),"\n",(0,i.jsx)(n.h2,{id:"complex-stride-patterns",children:"Complex stride patterns"}),"\n",(0,i.jsx)(n.p,{children:"In most languages, elements of an array are stored consecutively to one another.\nHowever, this is not always the case, and so the DWARF debugging data format\nallows one to distinguish between the lengths of the array elements and the\nlengths of the array stride; this allows one to handle, say, the case of an\narray whose elements are 2 bytes long but which each only begin on 8-byte\nboundaries."}),"\n",(0,i.jsx)(n.p,{children:"However, this simple notion of stride length is not sufficient for handling\nSolidity's storage arrays, whose stride patterns can be more complex. Solidity\nallows for multiple elements in an array to be packed into a word, without\nfilling the whole word. If we for a moment ignore the word-based nature of\nstorage and instead think of it as byte-based in a little-endian fashion,\nSolidity allows for patterns like \"15 bytes for one element, 15 bytes for the\nnext element, 2 bytes of empty space, repeat\", which can't be expressed with a\nsimple stride length."}),"\n",(0,i.jsx)(n.p,{children:"As such it may be necessary to provide a way to specify more complex stride\npatterns (or packing patterns, as that's really what these are)."}),"\n",(0,i.jsx)(n.h2,{id:"the-use-of-hash-based-locations",children:"The use of hash-based locations"}),"\n",(0,i.jsxs)(n.p,{children:["Storage slots in both Solidity and Vyper are often assigned based on the Keccak\nhash of various things; e.g., in a dynamically-sized array in Solidity, if the\nlength is stored at a slot ",(0,i.jsx)(n.code,{children:"p"}),", the elements are stored beginning at\n",(0,i.jsx)(n.code,{children:"keccak(p)"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The format needs some way to be able to specify this. This also raises the\nquestion of whether we should allow for other hash functions. Other hash\nfunctions are unlikely to be used due to the EVM making keccak much more\nconvenient than other hashes, but it may not be the only possibility as there\nare precompiles for both SHA-256 and RIPEMD-160."}),"\n",(0,i.jsx)(n.h2,{id:"soliditys-two-case-string-storage",children:"Solidity's two-case string storage"}),"\n",(0,i.jsx)(n.p,{children:"Solidity, when storing strings in storage, uses a two-case format, with one case\nfor if it's 31 bytes or shorter, and another case for 32 bytes or longer."}),"\n",(0,i.jsx)(n.p,{children:"In order to handle this, it may be necessary to have a notion of union\nrepresentations, somewhat similar to the notion of union types?"}),"\n",(0,i.jsx)(n.h2,{id:"mappings",children:"Mappings"}),"\n",(0,i.jsx)(n.p,{children:"Both Solidity and Vyper use mappings, and while these work similarly in both\nlanguages, the two aren't the same. It will be necessary to handle both styles,\nand ideally other potential styles as well."}),"\n",(0,i.jsxs)(n.p,{children:["In both languages, given a mapping at position ",(0,i.jsx)(n.code,{children:"p"})," and a key ",(0,i.jsx)(n.code,{children:"k"}),", the value\ncorresponding to ",(0,i.jsx)(n.code,{children:"k"})," is stored at a location determined by the Keccak hash of a\ncombination of ",(0,i.jsx)(n.code,{children:"p"})," and ",(0,i.jsx)(n.code,{children:"k"}),". But the details differ both by the language, and\nwhether we are looking at a value type that fits into a word, or whether we are\nlooking at a string or bytestring."]}),"\n",(0,i.jsxs)(n.p,{children:["Solidity always performs the computation ",(0,i.jsx)(n.code,{children:"keccak(k.p)"}),", where the ",(0,i.jsx)(n.code,{children:"."})," represents\nconcatenation. However, for value types the key is padded to a full word, while\nfor a string or bytestring, no padding is used."]}),"\n",(0,i.jsxs)(n.p,{children:["Vyper is similar, but differs in two ways. For value types, the computation is\ninstead ",(0,i.jsx)(n.code,{children:"keccak(p.k)"}),", with the concatenands in the other order; note that ",(0,i.jsx)(n.code,{children:"k"}),"\nis still padded. Meanwhile, for strings and bytestrings, the computation is\ninstead ",(0,i.jsx)(n.code,{children:"keccak(p.keccak(k))"})," (again with no padding on ",(0,i.jsx)(n.code,{children:"k"}),"). There will need\nto be a way to specify this additional complexity."]}),"\n",(0,i.jsx)(n.h2,{id:"markings-for-mapping-keys",children:"Markings for mapping keys"}),"\n",(0,i.jsx)(n.p,{children:"The problem of keeping track of mapping keys is worth discussing separately."}),"\n",(0,i.jsx)(n.p,{children:"Mappings do not keep track of their keys; as such, it is up to the debugger to\nkeep track of mapping keys touched in a given transaction. This will require\nsome kind of markings."}),"\n",(0,i.jsx)(n.p,{children:"Truffle Debugger currently handles this by using the AST and determining what\nvalue on the stack corresponds to the key specified for a given mapping access.\nHowever, this process is complex and requires several workarounds for unusual\ncases. While presumably markings could be devised that allow this process to\nwork in more generality, it's not clear that it's actually a good solution."}),"\n",(0,i.jsx)(n.p,{children:"An alternate approach, suggested some time ago by Nomic Labs, would be to have\nmarkings applied to the SHA3 instructions that hash key/slot combinations.\nHowever, in the case of Vyper, for strings and bytestrings, one would presumably\nalso need to separately (and differently) mark the SHA3 instruction where the\nstring or bytestring is pre-hashed, prior to the main hashing."}),"\n",(0,i.jsx)(n.h2,{id:"the-use-of-pointers-in-or-to-calldata",children:"The use of pointers in or to calldata"}),"\n",(0,i.jsx)(n.p,{children:"In Solidity's ABI encoding format (used also by Vyper), which is necessarily\nused for variables stored in calldata, pointers are relative. However, they are\nnot relative to their own location, but rather relative to the start of the\nstructure containing them. There will need to be some way to handle this."}),"\n",(0,i.jsx)(n.p,{children:"Moreover, for types in Solidity with a variable number of elements (including\nstrings and bytestrings), pointers on the stack to that type in calldata do not\npoint to the beginning of the calldata representation (which would start with\nthe length), but rather have both a start word and a length word, with the start\nword pointing just past where the length is stored (to the beginning of the\nactual contents). It will be necessary to handle this as well."}),"\n",(0,i.jsx)(n.h2,{id:"internal-function-pointers",children:"Internal function pointers"}),"\n",(0,i.jsx)(n.p,{children:"Solidity includes internal function types, which have several associated\nchallenges."}),"\n",(0,i.jsxs)(n.p,{children:["Firstly, there are two different formats for these (depending on whether or not\n",(0,i.jsx)(n.code,{children:"viaIR"})," was set in compilation), so it will be necessary to handle both."]}),"\n",(0,i.jsxs)(n.p,{children:["Secondly, the format with ",(0,i.jsx)(n.code,{children:"viaIR"})," turned on relies on assigning functions to\narbitrary numeric indices, so the format will have to include information\nmapping indices to functions."]}),"\n",(0,i.jsxs)(n.p,{children:["Thirdly, in the format with ",(0,i.jsx)(n.code,{children:"viaIR"})," turned off, an internal function pointer\nactually breaks down into one PC value for the deployed code and one PC value\nfor the constructor code (although the latter is not always set and is sometimes\nleft as zero). So there will need to be a way to specify this complexity."]}),"\n",(0,i.jsx)(n.p,{children:"Moreover, an internal function pointer can point to a designated revert function\nintroduced by the compiler rather than defined by the user; it will be necessary\nto handle this case."}),"\n",(0,i.jsx)(n.h2,{id:"lack-of-fixed-variable-locations-on-the-stack",children:"Lack of fixed variable locations on the stack"}),"\n",(0,i.jsx)(n.p,{children:"In languages that put variables on the stack, those variables may not have a\nfixed location. (For instance, Solidity with optimization turned on.) There\nwill need to be a way to keep track of variables that move around on the stack."}),"\n",(0,i.jsx)(n.h2,{id:"the-possibility-of-handling-other-languages",children:"The possibility of handling other languages"}),"\n",(0,i.jsx)(n.p,{children:"This is something of a reiteration of the initial point, but it would be ideal\nto be able to handle features that we may expect to see in other languages even\nif they do not appear in Solidity or Vyper."}),"\n",(0,i.jsx)(n.p,{children:"For instance, the (now-defunct) EVM language Pyramid was (largely) dynamically\ntyped, making each variable effectively a sum type. Sum types are an example of\na feature we may want to be able to handle even if not present in either\nSolidity or Vyper."})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);