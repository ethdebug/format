"use strict";(globalThis.webpackChunk_ethdebug_format_web=globalThis.webpackChunk_ethdebug_format_web||[]).push([[5679],{39396(e,n,s){s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>l,frontMatter:()=>a,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"pointer/expression","title":"Expression syntax","description":"Pointer expressions operate on the domain of bytes representing unsigned","source":"@site/spec/pointer/expression.mdx","sourceDirName":"pointer","slug":"/pointer/expression","permalink":"/format/pr-preview/pr-164/spec/pointer/expression","draft":false,"unlisted":false,"editUrl":"https://github.com/ethdebug/format/tree/main/packages/web/spec/pointer/expression.mdx","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"docsSidebar","previous":{"title":"Templates","permalink":"/format/pr-preview/pr-164/spec/pointer/collection/templates"},"next":{"title":"Pointer templates","permalink":"/format/pr-preview/pr-164/spec/pointer/template"}}');var r=s(31085),t=s(71184),o=s(38284);const a={sidebar_position:6},c="Expression syntax",d={},h=[{value:"Literal values",id:"literal-values",level:2},{value:"Variables",id:"variables",level:2},{value:"Arithmetic operations",id:"arithmetic-operations",level:2},{value:"Lookup region definition",id:"lookup-region-definition",level:2},{value:"Reading from the EVM",id:"reading-from-the-evm",level:2},{value:"Keccak256 hashes",id:"keccak256-hashes",level:2},{value:"Bytes concatenation",id:"bytes-concatenation",level:2},{value:"Resize operations",id:"resize-operations",level:2},{value:"Region references",id:"region-references",level:2}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",strong:"strong",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"expression-syntax",children:"Expression syntax"})}),"\n",(0,r.jsx)(n.p,{children:"Pointer expressions operate on the domain of bytes representing unsigned\nintegers."}),"\n",(0,r.jsx)(o.A,{schema:{id:"schema:ethdebug/format/pointer/expression"}}),"\n",(0,r.jsx)(n.h2,{id:"literal-values",children:"Literal values"}),"\n",(0,r.jsx)(n.p,{children:"An expression can be a literal value."}),"\n",(0,r.jsxs)(n.p,{children:["Literal values ",(0,r.jsx)(n.strong,{children:"must"})," be represented either as JSON numbers or as\n",(0,r.jsx)(n.code,{children:"0x"}),"-prefixed hexadecimal strings. Hexadecimal strings always represent a\nliteral string of bytes."]}),"\n",(0,r.jsx)(n.p,{children:"For convenience, this schema does not restrict hexadecimal string\nrepresentations to those that specify an even-number of digits (i.e., those\nthat specify complete byte pairs); odd numbers of hexadecimal digits are fine."}),"\n",(0,r.jsxs)(n.p,{children:["Hexadecimal string representations ",(0,r.jsx)(n.strong,{children:"may"})," omit leading zeroes; values are\nassumed to be left-padded to the bytes width appropriate for the context."]}),"\n",(0,r.jsx)(o.A,{schema:{id:"schema:ethdebug/format/pointer/expression"},pointer:"#/$defs/Literal"}),"\n",(0,r.jsx)(n.h2,{id:"variables",children:"Variables"}),"\n",(0,r.jsx)(n.p,{children:"An expression can be a string value equal to the identifier for a known\nscalar variable introduced by some pointer representation."}),"\n",(0,r.jsxs)(n.p,{children:["For an example where scalar variables may appear, see the\n",(0,r.jsx)(n.a,{href:"/spec/pointer/collection/list",children:"List collection schema"}),"."]}),"\n",(0,r.jsx)(o.A,{schema:{id:"schema:ethdebug/format/pointer/expression"},pointer:"#/$defs/Variable"}),"\n",(0,r.jsx)(n.h2,{id:"arithmetic-operations",children:"Arithmetic operations"}),"\n",(0,r.jsxs)(n.p,{children:["An expression can be an object of the form ",(0,r.jsx)(n.code,{children:"{ <op>: [...] }"}),", where ",(0,r.jsx)(n.code,{children:"<op>"}),"\ndenotes an arithmetic operation."]}),"\n",(0,r.jsx)(o.A,{schema:{id:"schema:ethdebug/format/pointer/expression"},pointer:"#/$defs/Arithmetic"}),"\n",(0,r.jsx)(n.h2,{id:"lookup-region-definition",children:"Lookup region definition"}),"\n",(0,r.jsxs)(n.p,{children:["An expression can reference properties defined for a particular region, such as\nanother region's ",(0,r.jsx)(n.code,{children:'"offset"'})," or ",(0,r.jsx)(n.code,{children:'"length"'}),". Such expressions resolve to the\nsame value as the expression specified for that corresponding property."]}),"\n",(0,r.jsx)(o.A,{schema:{id:"schema:ethdebug/format/pointer/expression"},pointer:"#/$defs/Lookup"}),"\n",(0,r.jsx)(n.h2,{id:"reading-from-the-evm",children:"Reading from the EVM"}),"\n",(0,r.jsxs)(n.p,{children:["An expression can be an object of the form ",(0,r.jsx)(n.code,{children:'{ "$read": "<region>" }'}),", where\n",(0,r.jsx)(n.code,{children:"<region>"})," references a particular region defined in some root pointer."]}),"\n",(0,r.jsx)(n.p,{children:"The value of such an expression is the concatenation of bytes present in the\nrunning machine state that correspond to the bytes addressed by the referenced\nregion."}),"\n",(0,r.jsx)(o.A,{schema:{id:"schema:ethdebug/format/pointer/expression"},pointer:"#/$defs/Read"}),"\n",(0,r.jsx)(n.h2,{id:"keccak256-hashes",children:"Keccak256 hashes"}),"\n",(0,r.jsxs)(n.p,{children:["An expression can be an object of form ",(0,r.jsx)(n.code,{children:'{ "$keccak256": [...] }'}),", indicating\nthat the value of the expression is a Solidity-style, tightly-packed keccak256\nhash of the concatenation of bytes specified by the list."]}),"\n",(0,r.jsx)(o.A,{schema:{id:"schema:ethdebug/format/pointer/expression"},pointer:"#/$defs/Keccak256"}),"\n",(0,r.jsx)(n.h2,{id:"bytes-concatenation",children:"Bytes concatenation"}),"\n",(0,r.jsxs)(n.p,{children:["An expression can be an object of form ",(0,r.jsx)(n.code,{children:'{ "$concat": [...] }'}),", indicating\nthat the value of the expression is the concatenation of bytes from each\nvalue in the list. The byte width of each operand is preserved; no padding\nis added or removed between operands."]}),"\n",(0,r.jsx)(n.p,{children:"This is useful for building composite byte sequences, for example when\nconstructing storage slot keys or preparing data for hashing."}),"\n",(0,r.jsx)(o.A,{schema:{id:"schema:ethdebug/format/pointer/expression"},pointer:"#/$defs/Concat"}),"\n",(0,r.jsx)(n.h2,{id:"resize-operations",children:"Resize operations"}),"\n",(0,r.jsx)(n.p,{children:"In certain situations, e.g. keccak256 hashes, it's crucially important to be\nable to express the bytes width of particular expression values. This schema\nprovides primitives to allow specifying an explicit bytes width for a\nparticular sub-expression."}),"\n",(0,r.jsx)(o.A,{schema:{id:"schema:ethdebug/format/pointer/expression"},pointer:"#/$defs/Resize"}),"\n",(0,r.jsx)(n.h2,{id:"region-references",children:"Region references"}),"\n",(0,r.jsxs)(n.p,{children:["Regions can be referenced either by name (which ",(0,r.jsx)(n.strong,{children:"must"})," be a defined region),\nor by use of the literal string value ",(0,r.jsx)(n.code,{children:'"$this"'})," (which indicates that the\nreferenced region is the region containing the expression itself)."]}),"\n",(0,r.jsxs)(n.p,{children:["In cases where an expression is used outside the context of a particular\nregion definition, the use of ",(0,r.jsx)(n.code,{children:'"$this"'})," is ",(0,r.jsx)(n.strong,{children:"prohibited"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Individual properties ",(0,r.jsx)(n.strong,{children:"may not"})," be defined with any reference to themselves.\nProperties also ",(0,r.jsx)(n.strong,{children:"may not"})," be defined in terms of mutual reference to each\nother. ",(0,r.jsx)("small",{children:"(Don't make this harder than it has to be.)"})]}),"\n",(0,r.jsx)(o.A,{schema:{id:"schema:ethdebug/format/pointer/expression"},pointer:"#/$defs/Reference"})]})}function l(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}}}]);