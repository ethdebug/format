"use strict";(self.webpackChunk_ethdebug_format_web=self.webpackChunk_ethdebug_format_web||[]).push([[8263],{61634:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>o,default:()=>l,frontMatter:()=>r,metadata:()=>a,toc:()=>d});var s=t(52322),i=t(45392);const r={sidebar_position:2},o="Essential type definitions",a={id:"implementation-guides/pointers/types/types",title:"Essential type definitions",description:"This reference implementation uses a few fundamental types/interfaces for",source:"@site/docs/implementation-guides/pointers/types/types.mdx",sourceDirName:"implementation-guides/pointers/types",slug:"/implementation-guides/pointers/types/",permalink:"/format/pr-preview/pr-149/docs/implementation-guides/pointers/types/",draft:!1,unlisted:!1,editUrl:"https://github.com/ethdebug/format/tree/main/packages/web/docs/implementation-guides/pointers/types/types.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"docsSidebar",previous:{title:"Dereferencing pointers",permalink:"/format/pr-preview/pr-149/docs/implementation-guides/pointers/"},next:{title:"Pointer types",permalink:"/format/pr-preview/pr-149/docs/implementation-guides/pointers/types/pointer-types"}},p={},d=[];function c(e){const n={a:"a",h1:"h1",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"essential-type-definitions",children:"Essential type definitions"}),"\n",(0,s.jsx)(n.p,{children:"This reference implementation uses a few fundamental types/interfaces for\ncross-cutting concerns. This section describes upfront what these are, since\nthe rest of the implementation makes heavy use of them:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"/docs/implementation-guides/pointers/types/pointer-types",children:"Pointer types"}),"\nmodel the ",(0,s.jsx)(n.strong,{children:"ethdebug/format/pointer"})," JSON Schema as TypeScript types\n(including corresponding type guards)"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"/docs/implementation-guides/pointers/types/data-and-machines",children:"Data and machines"})," page\ncovers low-level concerns of handling raw bytes and interfacing with\nrunning EVMs."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"/docs/implementation-guides/pointers/types/cursors",children:"Cursors"})," are the\nresult of dereferencing a pointer; they accept a machine state and produce\na list of concrete data address ranges corresponding to runtime pointer\nregions."]}),"\n"]}),"\n"]})]})}function l(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);