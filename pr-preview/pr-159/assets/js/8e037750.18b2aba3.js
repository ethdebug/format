"use strict";(self.webpackChunk_ethdebug_format_web=self.webpackChunk_ethdebug_format_web||[]).push([[7033],{95491:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>p,default:()=>m,frontMatter:()=>c,metadata:()=>d,toc:()=>h});var t=s(52322),i=s(45392),r=s(35683),o=s(77336),a=s(82009);const c={sidebar_position:2},p="Key concepts",d={id:"type/concepts",title:"Key concepts",description:"The ethdebug/format/type schema includes definitions for a few",source:"@site/spec/type/concepts.mdx",sourceDirName:"type",slug:"/type/concepts",permalink:"/format/pr-preview/pr-159/spec/type/concepts",draft:!1,unlisted:!1,editUrl:"https://github.com/ethdebug/format/tree/main/packages/web/spec/type/concepts.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"docsSidebar",previous:{title:"Overview",permalink:"/format/pr-preview/pr-159/spec/type/overview"},next:{title:"Schema",permalink:"/format/pr-preview/pr-159/spec/type/"}},l={},h=[{value:"Types are organized by <code>kind</code>",id:"types-are-organized-by-kind",level:2},{value:"Known vs. unknown kinds",id:"known-vs-unknown-kinds",level:2},{value:"Elementary vs. complex types",id:"elementary-vs-complex-types",level:2},{value:"Complex types&#39; <code>&quot;contains&quot;</code> field",id:"complextypes-contains-field",level:2},{value:"Type wrappers and type references",id:"type-wrappers-and-type-references",level:2},{value:"Type wrapper schema",id:"type-wrapper-schema",level:3},{value:"Type reference schema",id:"type-reference-schema",level:3},{value:"Sometimes types are defined in code",id:"sometimes-types-are-defined-in-code",level:2},{value:"Type definition schema",id:"type-definition-schema",level:3}];function y(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components},{Details:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"key-concepts",children:"Key concepts"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:"ethdebug/format/type"})," schema includes definitions for a few\nconcepts that are worth highlighting here."]}),"\n",(0,t.jsxs)(n.h2,{id:"types-are-organized-by-kind",children:["Types are organized by ",(0,t.jsx)(n.code,{children:"kind"})]}),"\n",(0,t.jsx)(n.admonition,{title:"Example: Boolean type",type:"info",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "kind": "bool"\n}\n'})})}),"\n",(0,t.jsxs)(n.p,{children:["An ",(0,t.jsx)(n.strong,{children:"ethdebug/format/type"})," type representation is a JSON object with a\n",(0,t.jsx)(n.code,{children:"kind"})," field containing a string value."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"kind"})," is a required field for all type representations and is used to\ndiscriminate type objects into the appropriate corresponding subschema for a\nwell-understood family of type."]}),"\n",(0,t.jsx)(n.h2,{id:"known-vs-unknown-kinds",children:"Known vs. unknown kinds"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"ethdebug/format/type"})," defines specific subschemas for known kinds of types.\nKnown types correspond 1-to-1 with a reserved constant string value for the\n",(0,t.jsx)(n.code,{children:"kind"})," field."]}),"\n",(0,t.jsxs)(n.p,{children:["Type representations ",(0,t.jsx)(n.strong,{children:"should"})," adhere to the specific corresponding subschema\nwhen representing a known type. Type representations ",(0,t.jsx)(n.strong,{children:"must not"})," use any of\nthe reserved values for ",(0,t.jsx)(n.code,{children:"kind"})," for any purpose other than adhering to the\ncorresponding subschema."]}),"\n",(0,t.jsxs)(n.p,{children:["This schema makes no restriction on values for the ",(0,t.jsx)(n.code,{children:"kind"})," field other than\nthese reservations. For custom variations on known types and to represent kinds\nof types not supported by this format, type representations ",(0,t.jsx)(n.strong,{children:"may"})," use other\nvalues for ",(0,t.jsx)(n.code,{children:"kind"})," that correspond to associated external subschemas."]}),"\n",(0,t.jsxs)(n.p,{children:["Note that this format defines a\n",(0,t.jsxs)(n.a,{href:"/spec/type/base",children:["base type schema (",(0,t.jsx)(n.strong,{children:"ethdebug/format/type/base"}),")"]}),", to which\nall representations of unknown (and known) types ",(0,t.jsx)(n.strong,{children:"must"})," conform.\nFor unknown types, ",(0,t.jsx)(n.a,{href:"/spec/type",children:(0,t.jsx)(n.strong,{children:"ethdebug/format/type"})}),"\nplaces additional constraints in addition to what the base schema specifies."]}),"\n",(0,t.jsx)(n.h2,{id:"elementary-vs-complex-types",children:"Elementary vs. complex types"}),"\n",(0,t.jsxs)(n.p,{children:["Type representations in this schema fall into one of two ",(0,t.jsx)(n.code,{children:"class"}),"es: either\n",(0,t.jsx)(n.code,{children:'"elementary"'})," or ",(0,t.jsx)(n.code,{children:'"complex"'}),". Type representations express this disinction in\ntwo ways (the optional ",(0,t.jsx)(n.code,{children:'"class"'})," field, and the absence or existence of a\n",(0,t.jsx)(n.code,{children:'"contains"'})," field)."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Elementary types do not compose any other types. For example, ",(0,t.jsx)(n.code,{children:"uint256"})," is an\nelementary type. ",(0,t.jsx)(n.code,{children:"string"})," may be an elementary type for languages that whose\nsemantics treat strings differently than simply an array of characters (like\nSolidity does)."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Complex types compose at least one other type. For instance, ",(0,t.jsx)(n.code,{children:"uint256[]"})," is\nan array type that composes an elementary type. Complex types in this schema\nare polymorphic in how they represent this composition; see\n",(0,t.jsx)(n.a,{href:"#complextypes-contains-field",children:"below"})," for information about complex types'\n",(0,t.jsx)(n.code,{children:'"contains"'})," field."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"complextypes-contains-field",children:["Complex types' ",(0,t.jsx)(n.code,{children:'"contains"'})," field"]}),"\n",(0,t.jsx)(n.p,{children:"Complex types inherently compose at least one other type and may do so in one\nof three forms:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Complex types may compose exactly one other type"}),"\n",(0,t.jsx)(n.li,{children:"Complex types may compose an ordered list of other types"}),"\n",(0,t.jsx)(n.li,{children:"Complex types may compose an object mapping of specific other types by key"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["All three forms of composition polymorphically use the ",(0,t.jsx)(n.code,{children:'"contains"'})," field."]}),"\n",(0,t.jsxs)(n.p,{children:["As described in\n",(0,t.jsx)(n.a,{href:"#type-wrappers-and-type-references",children:"Type wrappers and type references"}),"\nbelow, complex types compose\nother types by way of wrapper objects of the form ",(0,t.jsx)(n.code,{children:'{ "type": ... }'}),", which\npossibly includes other fields alongside ",(0,t.jsx)(n.code,{children:'"type"'}),"."]}),"\n",(0,t.jsxs)(s,{open:!0,children:[(0,t.jsx)("summary",{children:"Example complex types to show different forms"}),(0,t.jsxs)(o.default,{children:[(0,t.jsxs)(a.default,{value:"singleton",label:"Single type",children:[(0,t.jsx)(n.p,{children:"This is an example array type, which composes exactly one other type."}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "kind": "array",\n  "contains": {\n    "type": {\n      "kind": "uint",\n      "bits": 256\n    }\n  }\n}\n'})})]}),(0,t.jsxs)(a.default,{value:"list",label:"Ordered list of types",children:[(0,t.jsx)(n.p,{children:"This is an example array type, which composes an ordered list of member\ntypes."}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "kind": "struct",\n  "contains": [{\n    "name": "balance",\n    "type": {\n      "kind": "uint",\n      "bits": 256\n    }\n  }, {\n    "name": "scoreSheet",\n    "type": {\n      "id": "<some opaque ID for some `ScoreSheet` type>"\n    }\n  }]\n}\n'})}),(0,t.jsxs)(n.p,{children:["In this example, please note how this struct type represents member names\nwith a ",(0,t.jsx)(n.code,{children:'"name"'})," field alongside the ",(0,t.jsx)(n.code,{children:'"type"'})," field, and note how the\nvalue of ",(0,t.jsx)(n.code,{children:'"type"'})," can be either a complete representation or a reference\nobject in the form of ",(0,t.jsx)(n.code,{children:"{ id }"}),"."]})]}),(0,t.jsxs)(a.default,{value:"object",label:"Object mapping of types by key",children:[(0,t.jsx)(n.p,{children:"This is an example mapping type, which composes an object mapping of types\nby key."}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "kind": "mapping",\n  "contains": {\n    "key": {\n      "type": {\n        "kind": "address"\n      }\n    },\n    "value": {\n      "type": {\n        "kind": "uint",\n        "bits": 256\n      }\n    }\n  }\n}\n'})})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"type-wrappers-and-type-references",children:"Type wrappers and type references"}),"\n",(0,t.jsx)(n.p,{children:"This schema defines the concept of a type wrapper and the related concept of a\ntype reference."}),"\n",(0,t.jsx)(n.p,{children:"Type wrappers serve to encapsulate a type representation alongside other fields\nin the same object, and to facilitate discriminating which polymorphic form is\nused for a particular complex type."}),"\n",(0,t.jsxs)(n.p,{children:["Type wrappers are any object of the form\n",(0,t.jsx)(n.code,{children:'{ "type": <type>, ...otherProperties }'}),", where ",(0,t.jsx)(n.code,{children:"<type>"})," is either a complete\ntype representation or a reference to another type by ID."]}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:"Example type wrapper with complete type representation"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'{\n  "name": "beneficiary",\n  "type": {\n    "kind": "address"\n  }\n}\n'})})]}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:"Example type wrapper with reference by ID"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'{\n  "type": {\n    "id": "<opaque-id>"\n  }\n}\n'})})]}),"\n",(0,t.jsxs)(n.p,{children:["Note that ",(0,t.jsx)(n.strong,{children:"ethdebug/format/type"})," places no restriction on IDs other than\nthat they must be either a number or a string. Other components of this format\nat-large may impose restrictions, however."]}),"\n",(0,t.jsx)(n.h3,{id:"type-wrapper-schema",children:"Type wrapper schema"}),"\n",(0,t.jsx)(r.Z,{schema:{id:"schema:ethdebug/format/type/wrapper"}}),"\n",(0,t.jsx)(n.h3,{id:"type-reference-schema",children:"Type reference schema"}),"\n",(0,t.jsxs)(n.p,{children:["A type reference is an object containing the single ",(0,t.jsx)(n.code,{children:'"id"'})," field. This field\nmust be a string or a number."]}),"\n",(0,t.jsx)(r.Z,{schema:{id:"schema:ethdebug/format/type/reference"}}),"\n",(0,t.jsx)(n.h2,{id:"sometimes-types-are-defined-in-code",children:"Sometimes types are defined in code"}),"\n",(0,t.jsxs)(n.p,{children:["Languages provide certain kinds of types by way of allowing their definition\nin user (or runtime) code. These include ",(0,t.jsx)(n.a,{href:"/spec/type/complex/struct",children:"struct"}),",\n",(0,t.jsx)(n.a,{href:"/spec/type/elementary/enum",children:"enum"}),", and ",(0,t.jsx)(n.a,{href:"/spec/type/complex/alias",children:"alias"}),"\ntypes."]}),"\n",(0,t.jsxs)(n.p,{children:["Types with definition information ",(0,t.jsx)(n.strong,{children:"may"})," include a ",(0,t.jsx)(n.code,{children:"definition"})," field that\nspecifies the name of the type (its identifier) and/or the source location of\nits definition."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["When extending the ",(0,t.jsx)(n.a,{href:"/spec/type/base",children:"base type schema"})," for custom kinds of\ntypes with definitions, these custom schemas ",(0,t.jsx)(n.strong,{children:"must"})," require the specification\nof such definitions by way of this same ",(0,t.jsx)(n.code,{children:"definition"})," field and its associated\nschema."]})}),"\n",(0,t.jsxs)(n.p,{children:["This format does not prohibit the inclusion of this ",(0,t.jsx)(n.code,{children:"definition"})," field for any\ntype, so as to support languages where array types, etc. may be defined by name\ndirectly. It is recommended, however, that\ncompilers implementing this format ",(0,t.jsx)(n.strong,{children:"should"})," prefer to use\n",(0,t.jsx)(n.a,{href:"/spec/type/complex/alias",children:"alias"})," type for the common case of assigning a name\nto a type expression."]}),"\n",(0,t.jsx)(n.h3,{id:"type-definition-schema",children:"Type definition schema"}),"\n",(0,t.jsx)(r.Z,{schema:{id:"schema:ethdebug/format/type/definition"}})]})}function m(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(y,{...e})}):y(e)}}}]);