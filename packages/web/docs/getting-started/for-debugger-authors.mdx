---
sidebar_position: 2
---

# For debugger authors

You're building a debugger, transaction tracer, or analysis tool. Here's how
ethdebug/format helps you understand smart contract execution.

## What the format gives you

With ethdebug/format data, your debugger can:

- **Decode raw bytes into meaningful values** — Know that 32 bytes at a
  storage slot represent a `uint256` balance or a `mapping(address => uint)`
- **Find variable values at runtime** — Resolve pointers to locate data in
  storage, memory, or the stack, even when locations are computed dynamically
- **Map bytecode to source** — Show users which line of source code
  corresponds to the current instruction
- **Display variables in scope** — Know which variables exist at each point
  in execution

## Quick example: Reading a type

Type information tells you how to interpret bytes. Here's what a simple
`uint256` type looks like in ethdebug/format:

```json
{
  "kind": "uint",
  "bits": 256
}
```

And a more complex struct:

```json
{
  "kind": "struct",
  "name": "Position",
  "members": [
    { "name": "x", "type": { "kind": "int", "bits": 256 } },
    { "name": "y", "type": { "kind": "int", "bits": 256 } }
  ]
}
```

Your debugger reads these definitions and uses them to decode raw bytes from
EVM state into values users can understand.

## Quick example: Resolving a pointer

Pointers describe where data lives. A simple storage variable pointer:

```json
{
  "location": "storage",
  "slot": "0x0"
}
```

This says: "read from storage slot 0." But pointers can express complex,
dynamic locations too — like array elements or mapping values whose locations
depend on runtime state.

## What you need to implement

To consume ethdebug/format, your debugger needs:

1. **Schema parsing** — Load and validate ethdebug/format JSON
2. **Type decoding** — Convert bytes to values based on type definitions
3. **Pointer resolution** — Evaluate pointer expressions against EVM state
4. **Program interpretation** — Track context as execution progresses

## Go deeper

<div className="row">
  <div className="col col--6">
    <div className="card margin-bottom--md">
      <div className="card__header">
        <h4>Understand the concepts</h4>
      </div>
      <div className="card__body">
        Learn the mental models behind types, pointers, and programs.
      </div>
      <div className="card__footer">
        <a className="button button--secondary button--block"
           href="/docs/concepts">
          Concepts →
        </a>
      </div>
    </div>
  </div>
  <div className="col col--6">
    <div className="card margin-bottom--md">
      <div className="card__header">
        <h4>Implementation guide</h4>
      </div>
      <div className="card__body">
        Walk through a reference implementation of pointer dereferencing.
      </div>
      <div className="card__footer">
        <a className="button button--secondary button--block"
           href="/docs/implementation-guides/pointers">
          Dereferencing pointers →
        </a>
      </div>
    </div>
  </div>
</div>

### Explore by topic

- **[Types](/docs/types)** — How the format describes data structures
- **[Pointers](/docs/pointers)** — How the format describes data locations
- **[Programs](/docs/programs)** — How the format describes runtime context
- **[Specification](/spec/overview)** — Formal schema definitions
