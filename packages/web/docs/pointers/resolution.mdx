---
sidebar_position: 4
---

import { PointerPlayground, PointerExample } from "@theme/PointersExample";

<PointerPlayground>

# Pointer resolution

Pointer resolution is the process of converting a pointer definition into
actual byte values from the EVM state. This page features interactive examples
you can try in the **Pointer Playground** drawer at the bottom of the screen.

## The resolution process

Given a pointer and the current EVM state, resolution proceeds through several
stages:

1. **Evaluate expressions**: Compute any dynamic values (`$sum`, `$keccak256`,
   `$read`, etc.) using the current machine state
2. **Generate regions**: Produce concrete memory/storage/stack regions with
   resolved offsets and lengths
3. **Read bytes**: Fetch the actual bytes from each region
4. **Combine results**: For grouped or conditional pointers, assemble the final
   byte sequence

## Try it yourself

Click **"â–¶ Try it"** on any example below to load it into the Pointer
Playground. You can then edit the pointer and machine state to explore
resolution.

### Simple storage variable

Read a single 32-byte slot from storage:

<PointerExample
  title="Storage slot 0"
  pointer={{ location: "storage", slot: 0 }}
  state={{ storage: { "0x00": "0x000000000000000000000000000000000000000000000000000000000000002a" } }}
/>

### Stack value

Read from the EVM stack (zero-indexed from the top):

<PointerExample
  title="Stack position 0"
  pointer={{ location: "stack", slot: 0 }}
  state={{ stack: ["0x0000000000000000000000000000000000000000000000000000000000000001"] }}
/>

### Memory region

Read a byte range from memory:

<PointerExample
  title="Memory bytes 0-32"
  pointer={{ location: "memory", offset: 0, length: 32 }}
  state={{ memory: "0x48656c6c6f20576f726c64210000000000000000000000000000000000000000" }}
/>

### Dynamic array element (with keccak256)

Access an element of a Solidity dynamic array. The array length is stored at
slot 3, and data starts at `keccak256(3)`:

<PointerExample
  title="Array element at index 2"
  pointer={{
    group: [
      { name: "base", location: "storage", slot: 3 },
      {
        name: "element",
        location: "storage",
        slot: {
          $sum: [
            { $keccak256: [{ ".slot": "base" }] },
            2
          ]
        }
      }
    ]
  }}
  state={{
    storage: {
      "0x03": "0x0000000000000000000000000000000000000000000000000000000000000005"
    }
  }}
/>

**How it works:**
1. The first region "base" reads storage slot 3 (the array length slot)
2. The second region computes `keccak256(slot 3) + 2` to find element index 2
3. Both regions are resolved and their values displayed

### Named region references

Use `.slot`, `.offset`, and `.length` to reference fields from named regions:

<PointerExample
  title="Reference previous region"
  pointer={{
    group: [
      { name: "first", location: "storage", slot: 0 },
      {
        name: "second",
        location: "storage",
        slot: { $sum: [{ ".slot": "first" }, 1] }
      }
    ]
  }}
  state={{
    storage: {
      "0x00": "0x000000000000000000000000000000000000000000000000000000000000000a",
      "0x01": "0x0000000000000000000000000000000000000000000000000000000000000014"
    }
  }}
/>

## Resolution mechanics

### Expression evaluation

Expressions like `$sum`, `$keccak256`, and variable references are evaluated
against the current machine state. The expression language is compositional:

<PointerExample
  title="Composed expression"
  pointer={{
    location: "storage",
    slot: {
      $sum: [
        { $keccak256: [{ $wordsized: 0 }] },
        { $product: [32, 5] }
      ]
    }
  }}
  state={{}}
  description="Computes: keccak256(pad32(0)) + (32 * 5)"
/>

### Multiple regions

Pointers can yield multiple regions using `group` or `list`:

<PointerExample
  title="Group of two regions"
  pointer={{
    group: [
      { name: "length", location: "storage", slot: 0 },
      { name: "data", location: "storage", slot: 1 }
    ]
  }}
  state={{
    storage: {
      "0x00": "0x0000000000000000000000000000000000000000000000000000000000000020",
      "0x01": "0x48656c6c6f000000000000000000000000000000000000000000000000000000"
    }
  }}
/>

## Implementation resources

For details on implementing pointer resolution:

- [Evaluating expressions](/docs/implementation-guides/pointers/evaluating-expressions)
  covers the expression evaluation algorithm
- [Dereference logic](/docs/implementation-guides/pointers/dereference-logic)
  explains the full resolution pipeline
- [Generating regions](/docs/implementation-guides/pointers/dereference-logic/generating-regions)
  details how to produce concrete regions from pointer definitions

## Learn more

- [Expressions documentation](./expressions) for the expression language
- [Regions documentation](./regions) for region structure
- [Pointer specification](/spec/pointer) for formal definitions

</PointerPlayground>
