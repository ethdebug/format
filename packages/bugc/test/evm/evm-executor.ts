/**
 * EVM Executor for testing generated bytecode
 * Uses @ethereumjs/evm for in-process execution
 */

/* eslint-disable no-console */

import { EVM } from "@ethereumjs/evm";
import { SimpleStateManager } from "@ethereumjs/statemanager";
import { Common, Mainnet } from "@ethereumjs/common";
import { Address, Account } from "@ethereumjs/util";
import { hexToBytes, bytesToHex } from "ethereum-cryptography/utils";

export interface ExecutionOptions {
  value?: bigint;
  data?: string;
  origin?: Address;
  caller?: Address;
  gasLimit?: bigint;
}

export interface ExecutionResult {
  success: boolean;
  gasUsed: bigint;
  returnValue: Uint8Array;
  logs: unknown[];
  error?: unknown;
}

interface ExecResult {
  exceptionError?: unknown;
  executionGasUsed?: bigint;
  returnValue?: Uint8Array;
  logs?: unknown[];
}

interface ResultWithExec extends ExecResult {
  execResult?: ExecResult;
}

export class EvmExecutor {
  private evm: EVM;
  private stateManager: SimpleStateManager;
  private contractAddress: Address;
  private deployerAddress: Address;

  constructor() {
    const common = new Common({
      chain: Mainnet,
      hardfork: "shanghai",
    });
    this.stateManager = new SimpleStateManager();
    this.evm = new EVM({
      common,
      stateManager: this.stateManager,
    });

    // Use a fixed contract address for testing
    this.contractAddress = new Address(
      hexToBytes("1234567890123456789012345678901234567890"),
    );

    // Use a fixed deployer address
    this.deployerAddress = new Address(
      hexToBytes("0000000000000000000000000000000000000001"),
    );
  }

  /**
   * Get the deployer address used for deployment
   */
  getDeployerAddress(): Address {
    return this.deployerAddress;
  }

  /**
   * Deploy bytecode to the test contract address
   */
  async deploy(bytecode: string): Promise<void> {
    // Execute the constructor bytecode to get the runtime bytecode
    const code = hexToBytes(bytecode);

    // Initialize deployer account
    const deployerAccount = new Account(0n, BigInt(10) ** BigInt(18));
    await this.stateManager.putAccount(this.deployerAddress, deployerAccount);

    // Initialize contract account before execution
    const contractAccount = new Account(0n, 0n);
    await this.stateManager.putAccount(this.contractAddress, contractAccount);

    // Use runCall with empty to address to simulate CREATE
    const result = await this.evm.runCall({
      caller: this.deployerAddress,
      origin: this.deployerAddress,
      to: undefined, // undefined 'to' means contract creation
      data: code,
      gasLimit: 10_000_000n,
      value: 0n,
    });

    const error = result.execResult?.exceptionError;

    if (error) {
      console.error("Raw error:", error);
      throw new Error(`Deployment failed: ${JSON.stringify(error)}`);
    }

    // Get the created contract address
    const createdAddress = result.createdAddress;
    if (createdAddress) {
      // Update our contract address to the created one
      this.contractAddress = createdAddress;
    }
  }

  /**
   * Execute deployed bytecode
   */
  async execute(
    options: ExecutionOptions = {},
    trace = false,
  ): Promise<ExecutionResult> {
    const runCallOpts = {
      to: this.contractAddress,
      caller: options.caller ?? this.deployerAddress,
      origin: options.origin ?? this.deployerAddress,
      data: options.data ? hexToBytes(options.data) : new Uint8Array(),
      value: options.value ?? 0n,
      gasLimit: options.gasLimit ?? 10_000_000n,
    };

    if (trace) {
      this.evm.events.on(
        "step",
        (step: { pc: number; opcode: { name: string }; stack: bigint[] }) => {
          console.log(
            `[TRACE] PC=${step.pc.toString(16).padStart(4, "0")} ${step.opcode.name} stack=[${step.stack
              .slice(-3)
              .map((s) => s.toString(16))
              .join(", ")}]`,
          );
        },
      );
    }

    const result = await this.evm.runCall(runCallOpts);

    if (trace) {
      this.evm.events.removeAllListeners("step");
    }

    // Access the execution result from the returned object
    const rawResult = result as ResultWithExec;
    const execResult = (rawResult.execResult || rawResult) as ExecResult;

    return {
      success: execResult.exceptionError === undefined,
      gasUsed: execResult.executionGasUsed || 0n,
      returnValue: execResult.returnValue || new Uint8Array(),
      logs: execResult.logs || [],
      error: execResult.exceptionError,
    };
  }

  /**
   * Execute bytecode directly (without deployment)
   */
  async executeCode(
    bytecode: string,
    options: ExecutionOptions = {},
  ): Promise<ExecutionResult> {
    const code = hexToBytes(bytecode);

    // For storage operations to work, we need an account context
    // Create a temporary account with the code
    const tempAddress = new Address(
      hexToBytes("9999999999999999999999999999999999999999"),
    );
    await this.stateManager.putCode(tempAddress, code);
    await this.stateManager.putAccount(tempAddress, new Account(0n, 0n));

    const runCodeOpts = {
      code,
      data: options.data ? hexToBytes(options.data) : new Uint8Array(),
      gasLimit: options.gasLimit ?? 10_000_000n,
      value: options.value ?? 0n,
      origin: options.origin ?? new Address(Buffer.alloc(20)),
      caller: options.caller ?? new Address(Buffer.alloc(20)),
      address: tempAddress, // Add the address context
    };

    const result = await this.evm.runCode(runCodeOpts);

    // Access the execution result from the returned object
    const rawResult = result as ResultWithExec;
    const execResult = (rawResult.execResult || rawResult) as ExecResult;

    return {
      success: execResult.exceptionError === undefined,
      gasUsed: execResult.executionGasUsed || 0n,
      returnValue: execResult.returnValue || new Uint8Array(),
      logs: execResult.logs || [],
      error: execResult.exceptionError,
    };
  }

  /**
   * Get storage value at a specific slot
   */
  async getStorage(slot: bigint): Promise<bigint> {
    const slotBuffer = Buffer.alloc(32);

    // Convert bigint to hex string and pad to 64 characters (32 bytes)
    const hex = slot.toString(16).padStart(64, "0");
    slotBuffer.write(hex, "hex");

    const value = await this.stateManager.getStorage(
      this.contractAddress,
      slotBuffer,
    );

    // Convert Uint8Array to bigint
    if (value.length === 0) return 0n;
    return BigInt("0x" + bytesToHex(value));
  }

  /**
   * Set storage value at a specific slot
   */
  async setStorage(slot: bigint, value: bigint): Promise<void> {
    const slotBuffer = Buffer.alloc(32);
    slotBuffer.writeBigUInt64BE(slot, 24);

    const valueBuffer = Buffer.alloc(32);
    const hex = value.toString(16).padStart(64, "0");
    valueBuffer.write(hex, "hex");

    await this.stateManager.putStorage(
      this.contractAddress,
      slotBuffer,
      valueBuffer,
    );
  }

  /**
   * Get the code at the contract address
   */
  async getCode(): Promise<Uint8Array> {
    return this.stateManager.getCode(this.contractAddress);
  }

  /**
   * Get the contract address
   */
  getContractAddress(): Address {
    return this.contractAddress;
  }

  /**
   * Reset the EVM state
   */
  async reset(): Promise<void> {
    this.stateManager = new SimpleStateManager();
    this.evm = new EVM({
      common: new Common({
        chain: Mainnet,
        hardfork: "shanghai",
      }),
      stateManager: this.stateManager,
    });
  }
}
