name MemoryArray;

// Example 6: Memory Array Access
//
// Expected IR:
//   // Array expression would expand to memory allocation and writes:
//   // First, allocate memory for the array (length + elements)
//   %t0: uint256 = const 160  // 32 bytes for length + 4*32 bytes for elements
//   %t1: uint256 = allocate.memory, size=%t0
//
//   // Store array length at base
//   %t2: uint256 = const 4
//   memory[%t1*] = %t2
//
//   // Store elements at base + 32 + (index * 32)
//   %t3: uint256 = const 42
//   %t4: uint256 = const 0
//   %t5: uint256 = const 32  // add 32 to skip length field
//   %t6 = add %t1, %t5
//   %t7 = offset[%t6].array[%t4]
//   memory[%t7*] = %t3
//
//   %t8: uint256 = const 12
//   %t9: uint256 = const 1
//   %t10 = offset[%t6].array[%t9]
//   memory[%t10*] = %t8
//
//   %t11: uint256 = const 99
//   %t12: uint256 = const 2
//   %t13 = offset[%t6].array[%t12]
//   memory[%t13*] = %t11
//
//   %t14: uint256 = const 101
//   %t15: uint256 = const 3
//   %t16 = offset[%t6].array[%t15]
//   memory[%t16*] = %t14
//
//   // Array index access: items[3]
//   %t17: uint256 = const 3
//   %t18 = offset[%t6].array[%t17]
//   %t19: uint256 = memory[%t18*]
//
// EVM Strategy: Calculate arr + 3*32, then MSTORE/MLOAD
//
// Note: Memory arrays use simple offset arithmetic, no hashing needed

code {
  let items: array<uint256> =  [42, 12, 99, 101];
  let item = items[3];
}
