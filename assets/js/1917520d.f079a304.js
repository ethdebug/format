(self.webpackChunk_ethdebug_format_web=self.webpackChunk_ethdebug_format_web||[]).push([[571],{8844:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>y,contentTitle:()=>h,default:()=>x,frontMatter:()=>d,metadata:()=>m,toc:()=>f});var s=t(5893),r=t(1151),i=t(6220),a=t(3901),o=t(4866),p=t(5162),c=t(3236),l=t.n(c);const d={sidebar_position:3},h="ethdebug/format/type/base",m={id:"type/base",title:"ethdebug/format/type/base",description:"The schema on this page is extended by other, more specific schemas as part of",source:"@site/spec/type/base.mdx",sourceDirName:"type",slug:"/type/base",permalink:"/format/spec/type/base",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"docsSidebar",previous:{title:"ethdebug/format/type [placeholder]",permalink:"/format/spec/type/"}},y={},f=[{value:"Key concepts",id:"key-concepts",level:2},{value:"Types are organized by <code>kind</code>",id:"types-are-organized-by-kind",level:3},{value:"Elementary vs. complex types",id:"elementary-vs-complex-types",level:3},{value:"Type wrappers and type references",id:"type-wrappers-and-type-references",level:3},{value:"Type reference schema",id:"type-reference-schema",level:4},{value:"Type wrapper schema",id:"type-wrapper-schema",level:4},{value:"ComplexType&#39;s <code>&quot;contains&quot;</code> field",id:"complextypes-contains-field",level:3},{value:"Full base schema",id:"full-base-schema",level:2},{value:"Example schema extensions for particular types",id:"example-schema-extensions-for-particular-types",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"ethdebugformattypebase",children:"ethdebug/format/type/base"}),"\n",(0,s.jsxs)(n.admonition,{type:"warning",children:[(0,s.jsxs)(n.p,{children:["The schema on this page is extended by other, more specific schemas as part of\nthe larger ",(0,s.jsx)(n.strong,{children:"ethdebug/format"})," specification. These other schemas specify the\nrepresentation of many common kinds of types (e.g. including signed/unsigned\nintegers, arrays, structs, mappings, etc.). In order to adhere to this format\nfully, compilers that represent known types ",(0,s.jsx)(n.strong,{children:"should"})," do so with the\nappropriate more-specific schema."]}),(0,s.jsxs)(n.p,{children:["Please see the ",(0,s.jsx)(n.a,{href:"/spec/type",children:(0,s.jsx)(n.strong,{children:"ethdebug/format/type"})})," schema for representing\nthese supported types."]})]}),"\n",(0,s.jsxs)(n.p,{children:["This format defines this base schema (",(0,s.jsx)(n.strong,{children:"ethdebug/format/type/base"}),") for\nrepresenting data types from high-level languages. These types may be\nuser-defined or supplied as native data types in a language. This schema\naffords the representation of complex/parametric types, whose definition\ncomposes other types (e.g., arrays and structs, which contain at least one\nunderlying type)."]}),"\n",(0,s.jsxs)(n.p,{children:["This base schema itself is designed to be extended by other schemas in this\nformat. It serves to specify what is ",(0,s.jsx)(n.em,{children:"minimally necessary"})," for a type to be\na valid representation (i.e., all type representations ",(0,s.jsx)(n.strong,{children:"must"})," adhere to at\nleast this base schema)."]}),"\n",(0,s.jsx)(a.Z,{toc:f}),"\n",(0,s.jsx)(n.h2,{id:"key-concepts",children:"Key concepts"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"ethdebug/format/type/base"})," schema includes definitions for a few\nconcepts that are worth highlighting here."]}),"\n",(0,s.jsxs)(n.h3,{id:"types-are-organized-by-kind",children:["Types are organized by ",(0,s.jsx)(n.code,{children:"kind"})]}),"\n",(0,s.jsx)(n.admonition,{title:"Example: Boolean type",type:"info",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "kind": "bool"\n}\n'})})}),"\n",(0,s.jsxs)(n.p,{children:["An ",(0,s.jsx)(n.strong,{children:"ethdebug/format/type/base"})," type representation is a JSON object with a\n",(0,s.jsx)(n.code,{children:"kind"})," field containing a string value."]}),"\n",(0,s.jsxs)(n.p,{children:["This field is intended for use by other ",(0,s.jsx)(n.strong,{children:"ethdebug/format"})," schemas, which\nreserve specific string values for the various ",(0,s.jsx)(n.code,{children:"kind"}),"s of types that\nthis format supports, and for use by implementers of compilers and debuggers\nin situations where coordinating outside this specification is necessary or\nbeneficial."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"kind"})," is a required field for all type representations."]}),"\n",(0,s.jsxs)(n.p,{children:["The primary purpose for the ",(0,s.jsx)(n.code,{children:"kind"})," field is to discriminate type objects into\nthe appropriate corresponding subschema for a well-understood family of type.\nAlthough ",(0,s.jsx)(n.strong,{children:"ethdebug/format/type/base"})," does not impose any constraints on\nobjects based on the ",(0,s.jsx)(n.code,{children:"kind"})," field, it includes this field so as to encourage\nthe one-to-one pairing between values for this field and corresponding\nsubschemas."]}),"\n",(0,s.jsxs)(n.p,{children:["In other words: when extending this schema, ensure there exists exactly one\ncorresponding subschema for each defined value of ",(0,s.jsx)(n.code,{children:"kind"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"elementary-vs-complex-types",children:"Elementary vs. complex types"}),"\n",(0,s.jsxs)(n.p,{children:["Type representations in this schema fall into one of two ",(0,s.jsx)(n.code,{children:"class"}),"es: either\n",(0,s.jsx)(n.code,{children:'"elementary"'})," or ",(0,s.jsx)(n.code,{children:'"complex"'}),". Type representations express this disinction in\ntwo ways (the optional ",(0,s.jsx)(n.code,{children:'"class"'})," field, and the absence or existence of a\n",(0,s.jsx)(n.code,{children:'"contains"'})," field)."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Elementary types do not compose any other types. For example, ",(0,s.jsx)(n.code,{children:"uint256"})," is an\nelementary type. ",(0,s.jsx)(n.code,{children:"string"})," may be an elementary type for languages that whose\nsemantics treat strings differently than simply an array of characters (like\nSolidity does)."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Complex types compose at least one other type. For instance, ",(0,s.jsx)(n.code,{children:"uint256[]"})," is\nan array type that composes an elementary type. Complex types in this schema\nare polymorphic in how they represent this composition; see\n",(0,s.jsx)(n.a,{href:"#complextypes-contains-field",children:"below"})," for information about complex types'\n",(0,s.jsx)(n.code,{children:'"contains"'})," field."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"type-wrappers-and-type-references",children:"Type wrappers and type references"}),"\n",(0,s.jsx)(n.p,{children:"This schema defines the concept of a type wrapper and the related concept of a\ntype reference."}),"\n",(0,s.jsx)(n.p,{children:"Type wrappers serve to encapsulate a type representation alongside other fields\nin the same object, and to facilitate discriminating which polymorphic form is\nused for a particular complex type."}),"\n",(0,s.jsxs)(n.p,{children:["Type wrappers are any object of the form\n",(0,s.jsx)(n.code,{children:'{ "type": <type>, ...otherProperties }'}),", where ",(0,s.jsx)(n.code,{children:"<type>"})," is either a complete\ntype representation or a reference to another type by ID."]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Example type wrapper with complete type representation"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// from a struct type (which defines member types)\n{\n  "member": "beneficiary",\n  "type": {\n    "kind": "address"\n  }\n}\n'})})]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Example type wrapper with reference by ID"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'{\n  "type": {\n    "id": "<opaque-id>"\n  }\n}\n'})})]}),"\n",(0,s.jsxs)(n.p,{children:["Note that ",(0,s.jsx)(n.strong,{children:"ethdebug/format/type/base"})," places no restriction on IDs other than\nthat they must be either a number or a string. Other components of this format\nat-large may impose restrictions, however."]}),"\n",(0,s.jsx)(n.h4,{id:"type-reference-schema",children:"Type reference schema"}),"\n",(0,s.jsxs)(n.p,{children:["A type reference is an object containing the single ",(0,s.jsx)(n.code,{children:'"id"'})," field. This field\nmust be a string or a number."]}),"\n",(0,s.jsx)(i.Z,{schema:{id:"schema:ethdebug/format/type/base"},pointer:"#/$defs/TypeReference"}),"\n",(0,s.jsx)(n.h4,{id:"type-wrapper-schema",children:"Type wrapper schema"}),"\n",(0,s.jsx)(i.Z,{schema:{id:"schema:ethdebug/format/type/base"},pointer:"#/$defs/TypeWrapper",detect:e=>"object"==typeof e&&!("$schema"in e)&&"#/$defs/Type"===e.$ref,transform:({$ref:e,...n},t)=>({...n,type:"object",title:t.$defs.Type.title+" [RECURSIVE]",description:"The root Type schema"})}),"\n",(0,s.jsxs)(n.h3,{id:"complextypes-contains-field",children:["ComplexType's ",(0,s.jsx)(n.code,{children:'"contains"'})," field"]}),"\n",(0,s.jsx)(n.p,{children:"Complex types inherently compose at least one other type and may do so in one\nof three forms:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Complex types may compose exactly one other type"}),"\n",(0,s.jsx)(n.li,{children:"Complex types may compose an ordered list of other types"}),"\n",(0,s.jsxs)(n.li,{children:["Complex types may compose an object mapping of specific other types by key\nAs described ",(0,s.jsx)(n.a,{href:"#type-wrappers-and-type-references",children:"above"}),", complex types compose\nother types. This composition occurs inside the ",(0,s.jsx)(n.code,{children:'"contains"'})," field for all\ncomplex types."]}),"\n"]}),"\n",(0,s.jsxs)(t,{open:!0,children:[(0,s.jsx)("summary",{children:"Example complex types to show different forms"}),(0,s.jsxs)(o.default,{children:[(0,s.jsxs)(p.default,{value:"singleton",label:"Single type",children:[(0,s.jsx)(n.p,{children:"This is an example array type, which composes exactly one other type."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "kind": "array",\n  "contains": {\n    "type": {\n      "kind": "uint",\n      "bits": 256\n    }\n  }\n}\n'})})]}),(0,s.jsxs)(p.default,{value:"list",label:"Ordered list of types",children:[(0,s.jsx)(n.p,{children:"This is an example array type, which composes an ordered list of member\ntypes."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "kind": "struct",\n  "contains": [{\n    "member": "balance",\n    "type": {\n      "kind": "uint",\n      "bits": 256\n    }\n  }, {\n    "member": "scoreSheet",\n    "type": {\n      "id": "<some opaque ID for some `ScoreSheet` type>"\n    }\n  }]\n}\n'})}),(0,s.jsxs)(n.p,{children:["In this example, please note how this struct type represents member names\nwith a ",(0,s.jsx)(n.code,{children:'"member"'})," field alongside the ",(0,s.jsx)(n.code,{children:'"type"'})," field, and note how the\nvalue of ",(0,s.jsx)(n.code,{children:'"type"'})," can be either a complete representation or a reference\nobject in the form of ",(0,s.jsx)(n.code,{children:"{ id }"}),"."]})]}),(0,s.jsxs)(p.default,{value:"object",label:"Object mapping of types by key",children:[(0,s.jsx)(n.p,{children:"This is an example mapping type, which composes an object mapping of types\nby key."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "kind": "mapping",\n  "contains": {\n    "key": {\n      "type": {\n        "kind": "address"\n      }\n    },\n    "value": {\n      "type": {\n        "kind": "uint",\n        "bits": 256\n      }\n    }\n  }\n}\n'})})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"full-base-schema",children:"Full base schema"}),"\n",(0,s.jsx)(i.Z,{schema:{id:"schema:ethdebug/format/type/base"},detect:e=>"object"==typeof e&&!("$schema"in e)&&"schema:ethdebug/format/type/base"===e.$ref,transform:({$ref:e,...n},t)=>({...n,type:"object",title:t.title+" [RECURSIVE]",description:"The root Type schema"})}),"\n",(0,s.jsx)(n.h2,{id:"example-schema-extensions-for-particular-types",children:"Example schema extensions for particular types"}),"\n",(0,s.jsxs)(n.p,{children:["These examples show valid schemas that extend ",(0,s.jsx)(n.strong,{children:"ethdebug/format/types/base"}),"\nfor particular kinds of types."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.em,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": These are just examples and may not\ncorrespond to the canonical ",(0,s.jsx)(n.strong,{children:"ethdebug/format/type"})," schema."]})}),"\n",(0,s.jsxs)(o.default,{defaultValue:"uint",values:[{value:"uint",label:"Example uint type schema"},{value:"array",label:"Example array type schema"},{value:"mapping",label:"Example mapping type schema"}],children:[(0,s.jsx)(p.default,{value:"uint",children:(0,s.jsx)(i.Z,{schema:l()`
        $schema: "https://json-schema.org/draft/2020-12/schema"
        type: object
        properties:
          class:
            type: string
            const: elementary
          kind:
            type: string
            const: uint
          bits:
            type: number
            multipleOf: 8
            minimum: 8
            maximum: 256
        required:
          - kind
          - bits
        examples:
          - kind: uint
            bits: 64
      `})}),(0,s.jsx)(p.default,{value:"array",children:(0,s.jsx)(i.Z,{schema:l()`
        $schema: "https://json-schema.org/draft/2020-12/schema"
        type: object
        properties:
          class:
            type: string
            const: complex
          kind:
            type: string
            const: array
          contains:
            type: object
            properties:
              type:
                $ref: "schema:ethdebug/format/type/base#/$defs/Type"
            required:
              - type
        required:
          - kind
          - contains
        examples:
          - kind: array
            contains:
              type:
                kind: string
        description:
          An example schema for array types. See example value for representing
          an array of strings (\`string[]\`).
      `})}),(0,s.jsx)(p.default,{value:"mapping",children:(0,s.jsx)(i.Z,{schema:l()`
        $schema: "https://json-schema.org/draft/2020-12/schema"
        title: Example mapping type schema
        type: object
        properties:
          class:
            type: string
            const: complex
          kind:
            type: string
            const: array
          contains:
            type: object
            properties:
              key:
                type: object
                properties:
                  type:
                    $ref: "schema:ethdebug/format/type/base#/$defs/Type"
                required:
                  - type
              value:
                type: object
                properties:
                  type:
                    $ref: "schema:ethdebug/format/type/base#/$defs/Type"
                required:
                  - type
            required:
              - key
              - value
        required:
          - kind
          - contains
        examples:
          - kind: mapping
            contains:
              key:
                type:
                  kind: address
                  payable: true
              value:
                type:
                  kind: uint
                  bits: 256
        description:
          An example schema for mapping types. See example value for a mapping
          from an \`address payable\` to a \`uint256\`, adhering to this
          example schema.
      `})})]})]})}function x(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},6220:(e,n,t)=>{"use strict";t.d(n,{Z:()=>u});var s=t(8570),r=t.n(s),i=t(9286),a=t(4866),o=t(5162),p=t(4160);const c=['$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/type/base"\n\ntitle: ethdebug/format/type/base\ndescription:\n  Defines the minimally necessary schema for a data type.\n  Types belong to a particular `class` (`"elementary"` or `"complex"`),\n  and are further identified by a particular `kind`.\ntype: object\noneOf:\n  - $ref: "#/$defs/ElementaryType"\n  - $ref: "#/$defs/ComplexType"\n\n$defs:\n  ElementaryType:\n    title: ElementaryType\n    description:\n      Represents an elementary type (one that does not compose other types)\n    type: object\n    properties:\n      class:\n        type: string\n        const: elementary\n      kind:\n        type: string\n      contains:\n        not:\n          description:\n            "**Elementary types must not specify a `contains` field\n            (to make it easier to discriminate elementary vs. complex)**"\n    required:\n      - kind\n    examples:\n      - kind: uint\n        bits: 256\n\n  ComplexType:\n    title: ComplexType\n    description:\n      Represents a complex type, one that composes other types (e.g., arrays,\n      structs, mappings)\n    type: object\n    properties:\n      class:\n        type: string\n        const: complex\n        description: Indicates that this is a complex type\n      kind:\n        type: string\n        description: The specific kind of complex type, e.g., array or struct\n      contains:\n        title: ComplexType.contains\n        oneOf:\n          - $ref: "#/$defs/TypeWrapper"\n          - $ref: "#/$defs/TypeWrapperArray"\n          - $ref: "#/$defs/TypeWrapperObject"\n    required:\n      - kind\n      - contains\n    examples:\n      - kind: array\n        contains:\n          type:\n            kind: uint\n            bits: 256\n      - kind: struct\n        contains:\n          - member: x\n            type:\n              kind: uint\n              bits: 256\n          - member: y\n            type:\n              kind: uint\n              bits: 256\n      - kind: mapping\n        contains:\n          key:\n            type:\n              kind: address\n              payable: true\n          value:\n            type:\n              kind: uint\n              bits: 256\n\n  TypeReference:\n    title: \'{ "id": ... }\'\n    description: A reference to a known type by ID\n    type: object\n    properties:\n      id:\n        type:\n          - string\n          - number\n    additionalProperties: false\n    required:\n      - id\n\n  TypeWrapper:\n    title: \'{ "type": ... }\'\n    description:\n      A wrapper around a type. Defines a `"type"` field that may include a full\n      Type representation or a reference to a known Type by ID. Note that this\n      schema permits additional properties on the same object.\n    type: object\n    properties:\n      type:\n        oneOf:\n          - $ref: "schema:ethdebug/format/type/base"\n          - $ref: "#/$defs/TypeReference"\n    required:\n      - type\n\n  TypeWrapperArray:\n    title: \'{ "type": ... }[]\'\n    description: A list of wrapped types, where the wrapper may add fields\n    type: array\n    items:\n      $ref: "#/$defs/TypeWrapper"\n\n  TypeWrapperObject:\n    title: \'{ "key": { "type": ... }, ... }\'\n    description:\n      A key-value mapping of wrapped types, where the wrapper may add fields\n    type: object\n    additionalProperties:\n      $ref: "#/$defs/TypeWrapper"\n'].map((e=>({[p.ZP.parse(e).$id]:e}))).reduce(((e,n)=>({...e,...n})),{});function l(e){let{schema:n,pointer:t}=e;if("string"==typeof t&&!t.startsWith("#"))throw new Error("`pointer` option must start with '#'");return function(e){return 1===Object.keys(e).length&&"id"in e}(n)?function(e){let{schema:{id:n},pointer:t}=e;const[s,r]=n.split("#"),i=r?function(e){const n=e.filter((e=>"string"==typeof e)).map((e=>e.slice(1))).join("");if(0===n.length)return;return`#${n}`}([`#${r}`,t]):t,a=c[s];if(!a)throw new Error(`Unknown schema with $id "${s}"`);const o=d(a,i),l=p.ZP.parse(o);return{id:s,pointer:i,yaml:o,schema:l}}({schema:n,pointer:t}):function(e){return 1===Object.keys(e).length&&"yaml"in e}(n)?function(e){let{schema:{yaml:n},pointer:t}=e;const s=d(n,t),r=p.ZP.parse(s),i=r.$id;return i?{id:i,pointer:t,yaml:s,schema:r}:{pointer:t,yaml:s,schema:r}}({schema:n,pointer:t}):function(e){let{schema:n,pointer:t}=e;const s=d(p.ZP.stringify(n),t),r=p.ZP.parse(s),i=r.$id;return i?{id:i,pointer:t,yaml:s,schema:r}:{pointer:t,yaml:s,schema:r}}({schema:n,pointer:t})}function d(e,n){if(!n)return e;let t=p.ZP.parseDocument(e);for(const s of n.slice(2).split("/"))if(t=t.get(s,!0),!t)throw new Error(`Pointer ${n} not found in schema`);return p.ZP.stringify(t)}var h=t(2096),m=t(5893);function y(e){const{id:n,pointer:t,schema:s,yaml:r}=l(e),p=n?n.startsWith("schema:")?n.slice(7):n:void 0,c=p&&t?`${p}${t}`:p||void 0;return(0,m.jsxs)(a.default,{groupId:"schema-language",children:[(0,m.jsx)(o.default,{value:"yaml",label:"YAML",children:(0,m.jsx)(i.default,{className:"schema-listing",language:"yaml",showLineNumbers:!0,title:c||"schema.yaml",children:r})}),(0,m.jsx)(o.default,{value:"json",label:"JSON",children:(0,m.jsx)(i.default,{className:"schema-listing",language:"json",showLineNumbers:!0,title:c?`${c}`:"schema.json",children:JSON.stringify(s,void 0,2)})})]})}const f=(e,n,t)=>{const s=r=>n(r)?t(r,e):"object"!=typeof r||null===r?r:Array.isArray(r)?r.map((e=>s(e))):Object.keys(r).reduce(((e,n)=>(e[n]=s(r[n]),e)),{});return s(e)};function u(e){const{schema:n,yaml:t,pointer:s}=l(e),{detect:p=(()=>!1),transform:c=(e=>e)}=e,d=f(n,p,c);return(0,m.jsxs)(a.default,{children:[(0,m.jsx)(o.default,{value:"viewer",label:"Explore",children:(0,m.jsx)(r(),{schema:d,resolverOptions:{resolvers:{schema:{resolve:e=>{const{schema:n}=l({schema:{id:e.toString()}});return n}}}},viewerOptions:{showExamples:!0,ValueComponent:e=>{let{value:n}=e;return["string","number","bigint","boolean"].includes(typeof n)?(0,m.jsx)("code",{children:n.toString()}):(0,m.jsx)(i.default,{language:"json",children:`${JSON.stringify(n,void 0,2)}`})},DescriptionComponent:e=>{let{description:n}=e;return(0,m.jsx)(h.U,{children:n})}}})}),(0,m.jsx)(o.default,{value:"listing",label:"View source",children:(0,m.jsx)(y,{schema:e.schema,pointer:e.pointer})})]})}},6848:()=>{}}]);