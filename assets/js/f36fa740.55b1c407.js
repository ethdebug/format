"use strict";(globalThis.webpackChunk_ethdebug_format_web=globalThis.webpackChunk_ethdebug_format_web||[]).push([[4770],{792(e,n,s){s.d(n,{A:()=>h});s(14041);var o=s(40665);const t="container_Hrln",i="link_y57m",r="label_feh8",c="schema_kJnE",a="arrow_YbSg";var l=s(31085);function h({schema:e,href:n}){return(0,l.jsx)("div",{className:t,children:(0,l.jsxs)(o.A,{to:n,className:i,children:[(0,l.jsx)("span",{className:r,children:"Schema:"}),(0,l.jsx)("span",{className:c,children:e}),(0,l.jsx)("span",{className:a,children:"\u2192"})]})})}},63382(e,n,s){s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>c,metadata:()=>o,toc:()=>h});const o=JSON.parse('{"id":"concepts/info","title":"Info","description":"This page explains the mental model behind ethdebug/format info objects.","source":"@site/docs/concepts/info.mdx","sourceDirName":"concepts","slug":"/concepts/info","permalink":"/format/docs/concepts/info","draft":false,"unlisted":false,"editUrl":"https://github.com/ethdebug/format/tree/main/packages/web/docs/concepts/info.mdx","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"docsSidebar","previous":{"title":"Programs","permalink":"/format/docs/concepts/programs"},"next":{"title":"Types","permalink":"/format/docs/core-schemas/types/"}}');var t=s(31085),i=s(71184),r=s(792);const c={sidebar_position:6},a="Info",l={},h=[{value:"The info schema is the top-level container",id:"the-info-schema-is-the-top-level-container",level:2},{value:"What an info object contains",id:"what-an-info-object-contains",level:2},{value:"Two schema variants",id:"two-schema-variants",level:2},{value:"ethdebug/format/info",id:"ethdebugformatinfo",level:3},{value:"ethdebug/format/info/resources",id:"ethdebugformatinforesources",level:3},{value:"Expected workflow",id:"expected-workflow",level:2},{value:"Relationship to other schemas",id:"relationship-to-other-schemas",level:2},{value:"When to use which schema",id:"when-to-use-which-schema",level:2},{value:"Next steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"info",children:"Info"})}),"\n",(0,t.jsx)(r.A,{schema:"ethdebug/format/info",href:"/spec/info/overview"}),"\n",(0,t.jsxs)(n.p,{children:["This page explains the mental model behind ",(0,t.jsx)(n.strong,{children:"ethdebug/format"})," info objects.\nFor reference documentation, see the ",(0,t.jsx)(n.a,{href:"/docs/core-schemas/info",children:"Info reference"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"the-info-schema-is-the-top-level-container",children:"The info schema is the top-level container"}),"\n",(0,t.jsxs)(n.p,{children:["While types, pointers, and programs describe individual aspects of debug data,\nthe ",(0,t.jsx)(n.strong,{children:"info schema"})," bundles everything together. It's the top-level container\nthat represents a complete unit of debug information for a compilation."]}),"\n",(0,t.jsx)(n.p,{children:"When a compiler produces debug data, it typically emits an info object (or the\nclosely related info/resources object) containing all the debug information\nfor that compilation."}),"\n",(0,t.jsx)(n.h2,{id:"what-an-info-object-contains",children:"What an info object contains"}),"\n",(0,t.jsxs)(n.p,{children:["An ",(0,t.jsx)(n.strong,{children:"ethdebug/format/info"})," object includes:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Compilation"})," \u2014 compiler metadata and source files (singular)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Programs"})," \u2014 one for each bytecode artifact (create and call\nbytecode)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Shared types"})," \u2014 type definitions referenced across programs\n(object keyed by name)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Shared pointers"})," \u2014 pointer templates referenced across programs\n(object keyed by name)"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This bundling avoids duplication \u2014 when multiple programs reference the same\ntype definition or source file, the info object contains it once with\nreferences pointing to it."}),"\n",(0,t.jsx)(n.h2,{id:"two-schema-variants",children:"Two schema variants"}),"\n",(0,t.jsx)(n.p,{children:"The format defines two related schemas:"}),"\n",(0,t.jsx)(n.h3,{id:"ethdebugformatinfo",children:"ethdebug/format/info"}),"\n",(0,t.jsx)(n.p,{children:"A complete, standalone representation containing all debugging data plus\ncompilation metadata. This is what tools consume when they need full debug\ninformation."}),"\n",(0,t.jsx)(n.h3,{id:"ethdebugformatinforesources",children:"ethdebug/format/info/resources"}),"\n",(0,t.jsxs)(n.p,{children:["A more minimal representation containing compilation-related debug information\n",(0,t.jsx)(n.strong,{children:"without"})," metadata that may already exist elsewhere in compiler output."]}),"\n",(0,t.jsx)(n.p,{children:"The distinction exists because compilers typically already produce structured\nJSON output with compilation metadata. Rather than duplicate that information,\ncompilers can emit info/resources objects and let language-specific tooling\ncombine them with existing compiler output to produce full info objects."}),"\n",(0,t.jsx)(n.h2,{id:"expected-workflow",children:"Expected workflow"}),"\n",(0,t.jsx)(n.p,{children:"The format anticipates this workflow:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Compilers emit info/resources"})," \u2014 alongside their existing JSON output"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Language tooling combines"})," \u2014 merges info/resources with other compiler\noutput"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Tools consume info objects"})," \u2014 use the complete standalone representation"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"To illustrate, consider how this might look inside solc's standard\nJSON output. The shared resources (compilation metadata, types,\npointer templates) live at the top level, while each program sits\nalongside the bytecode it describes:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'{\n  "ethdebug": {\n    "resources": {\n      "compilation": { ... },\n      "types": { ... },\n      "pointers": { ... }\n    }\n  },\n\n  "contracts": {\n    "Token.sol": {\n      "Token": {\n        "abi": [ ... ],\n        "evm": {\n          "bytecode": {\n            "object": "6080...",\n            "ethdebug": { "program": { ... } }\n          },\n          "deployedBytecode": {\n            "object": "6080...",\n            "ethdebug": { "program": { ... } }\n          }\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["A companion tool (or solc itself, via a flag or other operating\nmode) would then gather these pieces \u2014 the top-level resources plus\neach per-bytecode program \u2014 into complete ",(0,t.jsx)(n.strong,{children:"ethdebug/format/info"}),"\nobjects for debugger consumption."]}),"\n",(0,t.jsx)(n.p,{children:"The format recommends that compilers ensure tooling exists to create\nfull info objects, whether through custom compilation modes or\ncompanion tools."}),"\n",(0,t.jsx)(n.h2,{id:"relationship-to-other-schemas",children:"Relationship to other schemas"}),"\n",(0,t.jsx)(n.p,{children:"The info schema connects everything:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"info\n\u251c\u2500\u2500 compilation (singular object)\n\u2502   \u251c\u2500\u2500 compiler\n\u2502   \u251c\u2500\u2500 sources[]\n\u2502   \u2514\u2500\u2500 settings\n\u251c\u2500\u2500 programs[]\n\u2502   \u251c\u2500\u2500 instructions[]\n\u2502   \u2502   \u2514\u2500\u2500 context\n\u2502   \u2502       \u251c\u2500\u2500 variables[]\n\u2502   \u2502       \u2502   \u251c\u2500\u2500 type (or reference)\n\u2502   \u2502       \u2502   \u2514\u2500\u2500 pointer\n\u2502   \u2502       \u2514\u2500\u2500 code (source range)\n\u2502   \u2514\u2500\u2500 compilation reference\n\u251c\u2500\u2500 types{} (shared definitions, keyed by name)\n\u2514\u2500\u2500 pointers{} (shared pointer templates, keyed by name)\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Info objects"})," contain a ",(0,t.jsx)(n.strong,{children:"compilation"})," \u2014 metadata and sources"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Info objects"})," reference ",(0,t.jsx)(n.strong,{children:"programs"})," \u2014 one per bytecode"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Programs"})," reference ",(0,t.jsx)(n.strong,{children:"types"})," and ",(0,t.jsx)(n.strong,{children:"pointers"})," for variables"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Programs"})," reference ",(0,t.jsx)(n.strong,{children:"sources"})," via source ranges in contexts"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Types"})," can reference other ",(0,t.jsx)(n.strong,{children:"types"})," by ID"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Pointers"})," provide reusable pointer templates"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"when-to-use-which-schema",children:"When to use which schema"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use the info schema"})," when:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Building a debugger that consumes debug data"}),"\n",(0,t.jsx)(n.li,{children:"Creating standalone debug artifacts"}),"\n",(0,t.jsx)(n.li,{children:"Distributing debug information separately from compiler output"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use the info/resources schema"})," when:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Implementing a compiler that already produces structured output"}),"\n",(0,t.jsx)(n.li,{children:"Embedding debug data within existing compiler JSON formats"}),"\n",(0,t.jsx)(n.li,{children:"Building tooling that will combine with other compiler output"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/core-schemas/info",children:"Info schema reference"})})," \u2014 Schema documentation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/core-schemas/info/resources",children:"Resources"})})," \u2014 Compilation-level shared data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/spec/info",children:"Info specification"})})," \u2014 Formal schema definitions"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);