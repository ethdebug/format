(self.webpackChunk_ethdebug_format_web=self.webpackChunk_ethdebug_format_web||[]).push([[8470],{72052:(e,t,n)=>{"use strict";n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>c,toc:()=>d});var i=n(52322),a=n(45392),s=(n(84560),n(51114));const o={sidebar_position:4},r="Evaluating pointer expressions",c={id:"implementation-guides/pointers/evaluating-expressions",title:"Evaluating pointer expressions",description:"Expression evaluation is a bit more interesting than reading raw region data,",source:"@site/docs/implementation-guides/pointers/evaluating-expressions.mdx",sourceDirName:"implementation-guides/pointers",slug:"/implementation-guides/pointers/evaluating-expressions",permalink:"/format/docs/implementation-guides/pointers/evaluating-expressions",draft:!1,unlisted:!1,editUrl:"https://github.com/ethdebug/format/tree/main/packages/web/docs/implementation-guides/pointers/evaluating-expressions.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"docsSidebar",previous:{title:"Reading from pointer regions",permalink:"/format/docs/implementation-guides/pointers/reading-from-regions"},next:{title:"The dereference function",permalink:"/format/docs/implementation-guides/pointers/dereference-logic/"}},l={},d=[{value:"Evaluating constants, literals, and variables",id:"evaluating-constants-literals-and-variables",level:2},{value:"Evaluating arithmetic operations",id:"evaluating-arithmetic-operations",level:2},{value:"Evaluating keccak256 hashes",id:"evaluating-keccak256-hashes",level:2},{value:"Evaluating property lookups",id:"evaluating-property-lookups",level:2},{value:"Evaluating machine state reads",id:"evaluating-machine-state-reads",level:2},{value:"Note on <code>&quot;$this&quot;</code> region lookups",id:"note-on-this-region-lookups",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",p:"p",strong:"strong",...(0,a.a)(),...e.components},{Details:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"evaluating-pointer-expressions",children:"Evaluating pointer expressions"}),"\n",(0,i.jsx)(t.p,{children:"Expression evaluation is a bit more interesting than reading raw region data,\nbut, still, performing this evaluation becomes relatively straightforward\nif variable and region references are pre-evaluated:"}),"\n",(0,i.jsx)(s.Z,{packageName:"@ethdebug/pointers",sourcePath:"src/evaluate.ts",extract:e=>e.getExportedDeclarations().get("EvaluateOptions")[0]}),"\n",(0,i.jsxs)(t.p,{children:["The main ",(0,i.jsx)(t.code,{children:"evaluate()"})," function uses type guards to dispatch to the appropriate\nspecific logic based on the kind of expression:"]}),"\n",(0,i.jsxs)(n,{children:[(0,i.jsxs)("summary",{children:["Source code of ",(0,i.jsx)(t.code,{children:"evaluate(expression: Pointer.Expression, options: EvaluateOptions)"})]}),(0,i.jsx)(s.Z,{packageName:"@ethdebug/pointers",sourcePath:"src/evaluate.ts",extract:e=>e.getExportedDeclarations().get("evaluate")[0]})]}),"\n",(0,i.jsx)(t.h2,{id:"evaluating-constants-literals-and-variables",children:"Evaluating constants, literals, and variables"}),"\n",(0,i.jsx)(t.p,{children:"Evaluating constant expressions is quite straightforward:"}),"\n",(0,i.jsx)(s.Z,{packageName:"@ethdebug/pointers",sourcePath:"src/evaluate.ts",extract:e=>e.getFunction("evaluateConstant")}),"\n",(0,i.jsx)(t.p,{children:"Evaluating literals involves detecting hex string vs. number and converting\nappropriate to bytes:"}),"\n",(0,i.jsx)(s.Z,{packageName:"@ethdebug/pointers",sourcePath:"src/evaluate.ts",extract:e=>e.getFunction("evaluateLiteral")}),"\n",(0,i.jsxs)(t.p,{children:["Variable lookups, of course, require consulting the ",(0,i.jsx)(t.code,{children:"variables"})," map passed\nin ",(0,i.jsx)(t.code,{children:"EvaluateOptions"}),":"]}),"\n",(0,i.jsx)(s.Z,{packageName:"@ethdebug/pointers",sourcePath:"src/evaluate.ts",extract:e=>e.getFunction("evaluateVariable")}),"\n",(0,i.jsx)(t.h2,{id:"evaluating-arithmetic-operations",children:"Evaluating arithmetic operations"}),"\n",(0,i.jsx)(t.p,{children:"Doing arithmetic operations follows the logic one might expect: recurse on\nthe operands of the expression and join the results appropriately. Note the\nslight differences in implementation for operations that accept any number\nof operands (sums, products), vs. operations that only accept two operands\n(differences, quotients, remainders)."}),"\n",(0,i.jsx)(t.p,{children:"Evaluating sums:"}),"\n",(0,i.jsx)(s.Z,{packageName:"@ethdebug/pointers",sourcePath:"src/evaluate.ts",extract:e=>e.getFunction("evaluateArithmeticSum")}),"\n",(0,i.jsx)(t.p,{children:"Evaluating products:"}),"\n",(0,i.jsx)(s.Z,{packageName:"@ethdebug/pointers",sourcePath:"src/evaluate.ts",extract:e=>e.getFunction("evaluateArithmeticProduct")}),"\n",(0,i.jsx)(t.p,{children:"Evaluating differences:"}),"\n",(0,i.jsx)(s.Z,{packageName:"@ethdebug/pointers",sourcePath:"src/evaluate.ts",extract:e=>e.getFunction("evaluateArithmeticDifference")}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note"})," how this function operates on unsigned values only by bounding the\nresult below at 0."]}),"\n",(0,i.jsx)(t.p,{children:"Evaluating quotients:"}),"\n",(0,i.jsx)(s.Z,{packageName:"@ethdebug/pointers",sourcePath:"src/evaluate.ts",extract:e=>e.getFunction("evaluateArithmeticQuotient")}),"\n",(0,i.jsx)(t.p,{children:"(Quotients of course use integer division only.)"}),"\n",(0,i.jsx)(t.p,{children:"Evaluating remainders:"}),"\n",(0,i.jsx)(s.Z,{packageName:"@ethdebug/pointers",sourcePath:"src/evaluate.ts",extract:e=>e.getFunction("evaluateArithmeticRemainder")}),"\n",(0,i.jsx)(t.h2,{id:"evaluating-keccak256-hashes",children:"Evaluating keccak256 hashes"}),"\n",(0,i.jsx)(t.p,{children:"Many data types in storage are addressed by way of keccak256 hashing. This\nprocess is somewhat non-trivial because the bytes width of the inputs and the\nprocess for concatenating them must match compiler behavior exactly."}),"\n",(0,i.jsxs)(t.p,{children:["See Solidity's\n",(0,i.jsx)(t.a,{href:"https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html",children:"Layout of State Variables in Storage"}),"\ndocumentation for an example of how one high-level EVM language makes heavy\nuse of hashing to allocate persistent data."]}),"\n",(0,i.jsxs)(t.admonition,{type:"warning",children:[(0,i.jsx)(t.p,{children:"This area of the schema is likely incomplete and could still use additional\nspecification. Be warned that, while this implementation may match the schema\nitself, it may not be fully sufficient for expressing all kinds of data\nallocations."}),(0,i.jsx)(t.p,{children:"Please stay tuned as this work continues being refined."})]}),"\n",(0,i.jsx)(s.Z,{packageName:"@ethdebug/pointers",sourcePath:"src/evaluate.ts",extract:e=>e.getFunction("evaluateKeccak256")}),"\n",(0,i.jsx)(t.h2,{id:"evaluating-property-lookups",children:"Evaluating property lookups"}),"\n",(0,i.jsx)(t.p,{children:"Pointer expressions can compose values taken from the properties of other,\nnamed regions. This not only provides a convenient way to avoid duplication\nwhen writing pointer expressions, but also it is necessary for types with\nparticularly complex data allocations."}),"\n",(0,i.jsxs)(t.p,{children:["Currently, the specification defines lookup operations for three properties:\n",(0,i.jsx)(t.code,{children:"offset"}),", ",(0,i.jsx)(t.code,{children:"length"}),", and ",(0,i.jsx)(t.code,{children:"slot"}),". Runtime checks are required to prevent\naccessing properties that aren't available on the target region (e.g.\nmemory regions do not contain a ",(0,i.jsx)(t.code,{children:"slot"})," property)."]}),"\n",(0,i.jsxs)(t.p,{children:["Since all of these lookups function in the same way, this reference\nimplementation needs only a single\n",(0,i.jsx)(t.code,{children:'evaluateLookup<O extends "slot" | "offset" | "length">'})," function:"]}),"\n",(0,i.jsx)(s.Z,{packageName:"@ethdebug/pointers",sourcePath:"src/evaluate.ts",extract:e=>e.getFunction("evaluateLookup")}),"\n",(0,i.jsx)(t.p,{children:"(The use of generic types here serves mostly to appease the type-checker; the\nminimal type safety it affords is insignificant compared to runtime data\nconsistency concerns, which hopefully the implementation makes clear via its\nuse of runtime definedness checks.)"}),"\n",(0,i.jsx)(t.h2,{id:"evaluating-machine-state-reads",children:"Evaluating machine state reads"}),"\n",(0,i.jsxs)(t.p,{children:["Finally, the last kind of expression defined by this specification is for\nreading raw data from the machine state. A ",(0,i.jsx)(t.code,{children:"Pointer.Expression.Read"})," should\nevaluate to the raw bytes stored at runtime in the region identified by a\nparticular name."]}),"\n",(0,i.jsxs)(t.p,{children:["Thanks to ",(0,i.jsx)(t.code,{children:"evaluate()"}),"'s requirement that its input regions-by-name map\ncontains only concrete\n",(0,i.jsx)(t.a,{href:"/docs/implementation-guides/pointers/types/cursors",children:(0,i.jsx)(t.code,{children:"Cursor.Region"})}),"\nobjects, and by leveraging the existing\n",(0,i.jsxs)(t.a,{href:"/docs/implementation-guides/pointers/reading-from-regions",children:[(0,i.jsx)(t.code,{children:"read()"})," functionality"]}),",\nthis function presents no surprises:"]}),"\n",(0,i.jsx)(s.Z,{packageName:"@ethdebug/pointers",sourcePath:"src/evaluate.ts",extract:e=>e.getFunction("evaluateRead")}),"\n",(0,i.jsxs)(t.h2,{id:"note-on-this-region-lookups",children:["Note on ",(0,i.jsx)(t.code,{children:'"$this"'})," region lookups"]}),"\n",(0,i.jsxs)(t.p,{children:["Astute readers might notice that these docs contain no mention until now\nabout how to implement support for expressions that reference the region in\nwhich they are defined, a mechanism the schema permits via the special region\nname identifier ",(0,i.jsx)(t.code,{children:'"$this"'}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Performing ",(0,i.jsx)(t.em,{children:"read"})," operations against ",(0,i.jsx)(t.code,{children:'"$this"'})," region is meaningless since\nthis schema does not afford any mechanism for defining regions recursively\ndown to a base case (or similar composition). Thus, the only syntactic\nconstruct for self-referential reads resembles, e.g., defining a storage region\nwhose ",(0,i.jsx)(t.code,{children:"slot"})," is ",(0,i.jsx)(t.code,{children:'{ $read: "$this" }'}),". Evaluating this ",(0,i.jsx)(t.code,{children:"slot"})," would require\nknowing the slot before knowing where to read, and knowing the slow requires\nknowing the machine value, ad nauseum."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.em,{children:"Property lookup expressions"}),", on the other hand, are completely\nacceptable\u2014provided they do not include circular references of any cycle\nlength."]}),"\n",(0,i.jsxs)(t.p,{children:["Since the ",(0,i.jsx)(t.code,{children:"evaluate<.*>()"})," functions here are written to accept only one\nexpression at a time, this reference implementation relegates this concern to a\nhigher-level module; proper use of ",(0,i.jsx)(t.code,{children:"evaluate()"})," here requires its\n",(0,i.jsx)(t.code,{children:"options.regions"})," map to include a pre-evaluated (albeit partial)\n",(0,i.jsx)(t.code,{children:'"$this"'})," region."]}),"\n",(0,i.jsxs)(t.p,{children:["The logic for creating ",(0,i.jsx)(t.code,{children:'"$this"'})," regions and calling ",(0,i.jsx)(t.code,{children:"evaluate()"})," correctly\nis described in the section pertaining to that area of the code. Be\nforewarned that this reference implementation takes a na\xefve trial-and-error\napproach for determining property evaluation order; implementations requiring\na more robust strategy will need to do some amount of pre-processing."]})]})}function u(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},48313:e=>{function t(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}t.keys=()=>[],t.resolve=t,t.id=48313,e.exports=t},51114:(e,t,n)=>{"use strict";n.d(t,{Z:()=>c});var i=n(84560),a=n.n(i),s=n(20477),o=n(42408);var r=n(52322);function c(e){let{packageName:t,sourcePath:n,extract:i,...c}=e;const l=function(e){const{packages:t}=(0,o.eZ)("project-code-plugin");if(!(e in t))throw new Error(`Unknown package name ${e}`);const{sourceFiles:n}=t[e],i=new s.IKL({useInMemoryFileSystem:!0});for(const{filePath:a,text:s}of n)i.createSourceFile(a,s,{overwrite:!0});return i}(t),d=l.getSourceFileOrThrow(n);if(!i)return(0,r.jsx)(a(),{title:n,language:"typescript",showLineNumbers:!0,children:d.getFullText()});const h=i(d,l);return(0,r.jsx)(a(),{language:"typescript",...c,children:h.getFullText().trim()})}},56699:()=>{},68379:()=>{},68382:()=>{},78867:()=>{},21212:()=>{},89854:()=>{},25800:()=>{},93037:()=>{},26996:()=>{}}]);