(self.webpackChunk_ethdebug_format_web=self.webpackChunk_ethdebug_format_web||[]).push([[571],{8844:(e,t,s)=>{"use strict";s.r(t),s.d(t,{assets:()=>m,contentTitle:()=>h,default:()=>x,frontMatter:()=>l,metadata:()=>y,toc:()=>f});var n=s(5893),r=s(1151),i=s(6419),a=s(3901),o=s(4866),p=s(5162),c=s(3236),d=s.n(c);const l={sidebar_position:3},h="ethdebug/format/type/base",y={id:"type/base",title:"ethdebug/format/type/base",description:"The schema on this page is extended by other, more specific schemas as part of",source:"@site/spec/type/base.mdx",sourceDirName:"type",slug:"/type/base",permalink:"/format/spec/type/base",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"docsSidebar",previous:{title:"ethdebug/format/type [placeholder]",permalink:"/format/spec/type/"}},m={},f=[{value:"Key concepts",id:"key-concepts",level:2},{value:"Types are organized by <code>kind</code>",id:"types-are-organized-by-kind",level:3},{value:"Elementary vs. complex types",id:"elementary-vs-complex-types",level:3},{value:"Type wrappers and type references",id:"type-wrappers-and-type-references",level:3},{value:"Type reference schema",id:"type-reference-schema",level:4},{value:"Type wrapper schema",id:"type-wrapper-schema",level:4},{value:"ComplexType&#39;s <code>&quot;contains&quot;</code> field",id:"complextypes-contains-field",level:3},{value:"Example complex types to show different forms",id:"example-complex-types-to-show-different-forms",level:4},{value:"Full base schema",id:"full-base-schema",level:2},{value:"Example schema extensions for particular types",id:"example-schema-extensions-for-particular-types",level:2}];function u(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components},{Details:s}=t;return s||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"ethdebugformattypebase",children:"ethdebug/format/type/base"}),"\n",(0,n.jsxs)(t.admonition,{type:"warning",children:[(0,n.jsxs)(t.p,{children:["The schema on this page is extended by other, more specific schemas as part of\nthe larger ",(0,n.jsx)(t.strong,{children:"ethdebug/format"})," specification. These other schemas specify the\nrepresentation of many common kinds of types (e.g. including signed/unsigned\nintegers, arrays, structs, mappings, etc.). In order to adhere to this format\nfully, compilers that represent known types ",(0,n.jsx)(t.strong,{children:"should"})," do so with the\nappropriate more-specific schema."]}),(0,n.jsxs)(t.p,{children:["Please see the ",(0,n.jsx)(t.a,{href:"/spec/type",children:(0,n.jsx)(t.strong,{children:"ethdebug/format/type"})})," schema for representing\nthese supported types."]})]}),"\n",(0,n.jsxs)(t.p,{children:["This format defines this base schema (",(0,n.jsx)(t.strong,{children:"ethdebug/format/type/base"}),") for\nrepresenting data types from high-level languages. These types may be\nuser-defined or supplied as native data types in a language. This schema\naffords the representation of complex/parametric types, whose definition\ncomposes other types (e.g., arrays and structs, which contain at least one\nunderlying type)."]}),"\n",(0,n.jsxs)(t.p,{children:["This base schema itself is designed to be extended by other schemas in this\nformat. It serves to specify what is ",(0,n.jsx)(t.em,{children:"minimally necessary"})," for a type to be\na valid representation (i.e., all type representations ",(0,n.jsx)(t.strong,{children:"must"})," adhere to at\nleast this base schema)."]}),"\n",(0,n.jsx)(a.Z,{toc:f}),"\n",(0,n.jsx)(t.h2,{id:"key-concepts",children:"Key concepts"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.strong,{children:"ethdebug/format/type/base"})," schema includes definitions for a few\nconcepts that are worth highlighting here."]}),"\n",(0,n.jsxs)(t.h3,{id:"types-are-organized-by-kind",children:["Types are organized by ",(0,n.jsx)(t.code,{children:"kind"})]}),"\n",(0,n.jsx)(t.admonition,{title:"Example: Boolean type",type:"info",children:(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-json",children:'{\n  "kind": "bool"\n}\n'})})}),"\n",(0,n.jsxs)(t.p,{children:["An ",(0,n.jsx)(t.strong,{children:"ethdebug/format/type/base"})," type representation is a JSON object with a\n",(0,n.jsx)(t.code,{children:"kind"})," field containing a string value."]}),"\n",(0,n.jsxs)(t.p,{children:["This field is intended for use by other ",(0,n.jsx)(t.strong,{children:"ethdebug/format"})," schemas, which\nreserve specific string values for the various ",(0,n.jsx)(t.code,{children:"kind"}),"s of types that\nthis format supports, and for use by implementers of compilers and debuggers\nin situations where coordinating outside this specification is necessary or\nbeneficial."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"kind"})," is a required field for all type representations."]}),"\n",(0,n.jsxs)(t.p,{children:["The primary purpose for the ",(0,n.jsx)(t.code,{children:"kind"})," field is to discriminate type objects into\nthe appropriate corresponding subschema for a well-understood family of type.\nAlthough ",(0,n.jsx)(t.strong,{children:"ethdebug/format/type/base"})," does not impose any constraints on\nobjects based on the ",(0,n.jsx)(t.code,{children:"kind"})," field, it includes this field so as to encourage\nthe one-to-one pairing between values for this field and corresponding\nsubschemas."]}),"\n",(0,n.jsxs)(t.p,{children:["In other words: when extending this schema, ensure there exists exactly one\ncorresponding subschema for each defined value of ",(0,n.jsx)(t.code,{children:"kind"}),"."]}),"\n",(0,n.jsx)(t.h3,{id:"elementary-vs-complex-types",children:"Elementary vs. complex types"}),"\n",(0,n.jsxs)(t.p,{children:["Type representations in this schema fall into one of two ",(0,n.jsx)(t.code,{children:"class"}),"es: either\n",(0,n.jsx)(t.code,{children:'"elementary"'})," or ",(0,n.jsx)(t.code,{children:'"complex"'}),". Type representations express this disinction in\ntwo ways (the optional ",(0,n.jsx)(t.code,{children:'"class"'})," field, and the absence or existence of a\n",(0,n.jsx)(t.code,{children:'"contains"'})," field)."]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["Elementary types do not compose any other types. For example, ",(0,n.jsx)(t.code,{children:"uint256"})," is an\nelementary type. ",(0,n.jsx)(t.code,{children:"string"})," may be an elementary type for languages that whose\nsemantics treat strings differently than simply an array of characters (like\nSolidity does)."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["Complex types compose at least one other type. For instance, ",(0,n.jsx)(t.code,{children:"uint256[]"})," is\nan array type that composes an elementary type. Complex types in this schema\nare polymorphic in how they represent this composition; see\n",(0,n.jsx)(t.a,{href:"#complextypes-contains-field",children:"below"})," for information about complex types'\n",(0,n.jsx)(t.code,{children:'"contains"'})," field."]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"type-wrappers-and-type-references",children:"Type wrappers and type references"}),"\n",(0,n.jsx)(t.p,{children:"This schema defines the concept of a type wrapper and the related concept of a\ntype reference."}),"\n",(0,n.jsx)(t.p,{children:"Type wrappers serve to encapsulate a type representation alongside other fields\nin the same object, and to facilitate discriminating which polymorphic form is\nused for a particular complex type."}),"\n",(0,n.jsxs)(t.p,{children:["Type wrappers are any object of the form\n",(0,n.jsx)(t.code,{children:'{ "type": <type>, ...otherProperties }'}),", where ",(0,n.jsx)(t.code,{children:"<type>"})," is either a complete\ntype representation or a reference to another type by ID."]}),"\n",(0,n.jsxs)(s,{children:[(0,n.jsx)("summary",{children:"Example type wrapper with complete type representation"}),(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-javascript",children:'// from a struct type (which defines member types)\n{\n  "member": "beneficiary",\n  "type": {\n    "kind": "address"\n  }\n}\n'})})]}),"\n",(0,n.jsxs)(s,{children:[(0,n.jsx)("summary",{children:"Example type wrapper with reference by ID"}),(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-javascript",children:'{\n  "type": {\n    "id": "<opaque-id>"\n  }\n}\n'})})]}),"\n",(0,n.jsxs)(t.p,{children:["Note that ",(0,n.jsx)(t.strong,{children:"ethdebug/format/type/base"})," places no restriction on IDs other than\nthat they must be either a number or a string. Other components of this format\nat-large may impose restrictions, however."]}),"\n",(0,n.jsx)(t.h4,{id:"type-reference-schema",children:"Type reference schema"}),"\n",(0,n.jsxs)(t.p,{children:["A type reference is an object containing the single ",(0,n.jsx)(t.code,{children:'"id"'})," field. This field\nmust be a string or a number."]}),"\n",(0,n.jsx)(i.Z,{schema:"schema:ethdebug/format/type/base",pointer:"#/$defs/TypeReference"}),"\n",(0,n.jsx)(t.h4,{id:"type-wrapper-schema",children:"Type wrapper schema"}),"\n",(0,n.jsx)(i.Z,{schema:"schema:ethdebug/format/type/base",pointer:"#/$defs/TypeWrapper",detect:e=>"object"==typeof e&&!("$schema"in e)&&"#/$defs/Type"===e.$ref,transform:({$ref:e,...t},s)=>({...t,type:"object",title:s.$defs.Type.title+" [RECURSIVE]",description:"The root Type schema"})}),"\n",(0,n.jsxs)(t.h3,{id:"complextypes-contains-field",children:["ComplexType's ",(0,n.jsx)(t.code,{children:'"contains"'})," field"]}),"\n",(0,n.jsx)(t.p,{children:"Complex types inherently compose at least one other type and may do so in one\nof three forms:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Complex types may compose exactly one other type"}),"\n",(0,n.jsx)(t.li,{children:"Complex types may compose an ordered list of other types"}),"\n",(0,n.jsxs)(t.li,{children:["Complex types may compose an object mapping of specific other types by key\nAs described ",(0,n.jsx)(t.a,{href:"#type-wrappers-and-type-references",children:"above"}),", complex types compose\nother types. This composition occurs inside the ",(0,n.jsx)(t.code,{children:'"contains"'})," field for all\ncomplex types."]}),"\n"]}),"\n",(0,n.jsx)(t.h4,{id:"example-complex-types-to-show-different-forms",children:"Example complex types to show different forms"}),"\n",(0,n.jsxs)(o.default,{defaultValue:"singleton",values:[{value:"singleton",label:"Single type"},{value:"list",label:"Ordered list of types"},{value:"object",label:"Object mapping of types by key"}],children:[(0,n.jsxs)(p.default,{value:"singleton",children:[(0,n.jsx)(t.p,{children:"This is an example array type, which composes exactly one other type."}),(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-json",children:'{\n  "kind": "array",\n  "contains": {\n    "type": {\n      "kind": "uint",\n      "bits": 256\n    }\n  }\n}\n'})})]}),(0,n.jsxs)(p.default,{value:"list",children:[(0,n.jsx)(t.p,{children:"This is an example array type, which composes an ordered list of member\ntypes."}),(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-json",children:'{\n  "kind": "struct",\n  "contains": [{\n    "member": "balance",\n    "type": {\n      "kind": "uint",\n      "bits": 256\n    }\n  }, {\n    "member": "scoreSheet",\n    "type": {\n      "id": "<some opaque ID for some `ScoreSheet` type>"\n    }\n  }]\n}\n'})}),(0,n.jsxs)(t.p,{children:["In this example, please note how this struct type represents member names\nwith a ",(0,n.jsx)(t.code,{children:'"member"'})," field alongside the ",(0,n.jsx)(t.code,{children:'"type"'})," field, and note how the\nvalue of ",(0,n.jsx)(t.code,{children:'"type"'})," can be either a complete representation or a reference\nobject in the form of ",(0,n.jsx)(t.code,{children:"{ id }"}),"."]})]}),(0,n.jsxs)(p.default,{value:"object",children:[(0,n.jsx)(t.p,{children:"This is an example mapping type, which composes an object mapping of types\nby key."}),(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-json",children:'{\n  "kind": "mapping",\n  "contains": {\n    "key": {\n      "type": {\n        "kind": "address"\n      }\n    },\n    "value": {\n      "type": {\n        "kind": "uint",\n        "bits": 256\n      }\n    }\n  }\n}\n'})})]})]}),"\n",(0,n.jsx)(t.h2,{id:"full-base-schema",children:"Full base schema"}),"\n",(0,n.jsx)(i.Z,{schema:"schema:ethdebug/format/type/base",detect:e=>"object"==typeof e&&!("$schema"in e)&&"schema:ethdebug/format/type/base"===e.$ref,transform:({$ref:e,...t},s)=>({...t,type:"object",title:s.title+" [RECURSIVE]",description:"The root Type schema"})}),"\n",(0,n.jsx)(t.h2,{id:"example-schema-extensions-for-particular-types",children:"Example schema extensions for particular types"}),"\n",(0,n.jsxs)(t.p,{children:["These examples show valid schemas that extend ",(0,n.jsx)(t.strong,{children:"ethdebug/format/types/base"}),"\nfor particular kinds of types."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsxs)(t.em,{children:[(0,n.jsx)(t.strong,{children:"Note"}),": These are just examples and may not\ncorrespond to the canonical ",(0,n.jsx)(t.strong,{children:"ethdebug/format/type"})," schema."]})}),"\n",(0,n.jsxs)(o.default,{defaultValue:"uint",values:[{value:"uint",label:"Example uint type schema"},{value:"array",label:"Example array type schema"},{value:"mapping",label:"Example mapping type schema"}],children:[(0,n.jsx)(p.default,{value:"uint",children:(0,n.jsx)(i.Z,{schema:d()`
        $schema: "https://json-schema.org/draft/2020-12/schema"
        type: object
        properties:
          class:
            type: string
            const: elementary
          kind:
            type: string
            const: uint
          bits:
            type: number
            multipleOf: 8
            minimum: 8
            maximum: 256
        required:
          - kind
          - bits
        examples:
          - kind: uint
            bits: 64
      `})}),(0,n.jsx)(p.default,{value:"array",children:(0,n.jsx)(i.Z,{schema:d()`
        $schema: "https://json-schema.org/draft/2020-12/schema"
        type: object
        properties:
          class:
            type: string
            const: complex
          kind:
            type: string
            const: array
          contains:
            type: object
            properties:
              type:
                $ref: "schema:ethdebug/format/type/base#/$defs/Type"
            required:
              - type
        required:
          - kind
          - contains
        examples:
          - kind: array
            contains:
              type:
                kind: string
        description:
          An example schema for array types. See example value for representing
          an array of strings (\`string[]\`).
      `})}),(0,n.jsx)(p.default,{value:"mapping",children:(0,n.jsx)(i.Z,{schema:d()`
        $schema: "https://json-schema.org/draft/2020-12/schema"
        title: Example mapping type schema
        type: object
        properties:
          class:
            type: string
            const: complex
          kind:
            type: string
            const: array
          contains:
            type: object
            properties:
              key:
                type: object
                properties:
                  type:
                    $ref: "schema:ethdebug/format/type/base#/$defs/Type"
                required:
                  - type
              value:
                type: object
                properties:
                  type:
                    $ref: "schema:ethdebug/format/type/base#/$defs/Type"
                required:
                  - type
            required:
              - key
              - value
        required:
          - kind
          - contains
        examples:
          - kind: mapping
            contains:
              key:
                type:
                  kind: address
                  payable: true
              value:
                type:
                  kind: uint
                  bits: 256
        description:
          An example schema for mapping types. See example value for a mapping
          from an \`address payable\` to a \`uint256\`, adhering to this
          example schema.
      `})})]})]})}function x(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(u,{...e})}):u(e)}},6419:(e,t,s)=>{"use strict";s.d(t,{Z:()=>d});var n=s(8570),r=s.n(n),i=s(9286),a=s(4618),o=s(2096),p=s(5893);const c=(e,t,s)=>{const n=r=>t(r)?s(r,e):"object"!=typeof r||null===r?r:Array.isArray(r)?r.map((e=>n(e))):Object.keys(r).reduce(((e,t)=>(e[t]=n(r[t]),e)),{});return n(e)};function d(e){let{schema:t,pointer:s="",detect:n=(()=>!1),transform:d=(e=>e)}=e;const l="string"==typeof t?(0,a.V)(t):t,h=c(l,n,d);return(0,p.jsx)(r(),{schema:h,resolverOptions:{jsonPointer:s,resolvers:{schema:{resolve:e=>(0,a.V)(e.toString())}}},viewerOptions:{showExamples:!0,ValueComponent:e=>{let{value:t}=e;return["string","number","bigint","boolean"].includes(typeof t)?(0,p.jsx)("code",{children:t.toString()}):(0,p.jsx)(i.default,{language:"json",children:`${JSON.stringify(t,void 0,2)}`})},DescriptionComponent:e=>{let{description:t}=e;return(0,p.jsx)(o.U,{children:t})}}})}},4618:(e,t,s)=>{"use strict";s.d(t,{V:()=>r});const n=[{$schema:"https://json-schema.org/draft/2020-12/schema",$id:"schema:ethdebug/format/type/base",title:"ethdebug/format/type/base",description:'Defines the minimally necessary schema for a data type. Types belong to a particular `class` (`"elementary"` or `"complex"`), and are further identified by a particular `kind`.',type:"object",oneOf:[{$ref:"#/$defs/ElementaryType"},{$ref:"#/$defs/ComplexType"}],$defs:{ElementaryType:{title:"ElementaryType",description:"Represents an elementary type (one that does not compose other types)",type:"object",properties:{class:{type:"string",const:"elementary"},kind:{type:"string"},contains:{not:{description:"**Elementary types must not specify a `contains` field (to make it easier to discriminate elementary vs. complex)**"}}},required:["kind"],examples:[{kind:"uint",bits:256}]},ComplexType:{title:"ComplexType",description:"Represents a complex type, one that composes other types (e.g., arrays, structs, mappings)",type:"object",properties:{class:{type:"string",const:"complex",description:"Indicates that this is a complex type"},kind:{type:"string",description:"The specific kind of complex type, e.g., array or struct"},contains:{title:"ComplexType.contains",oneOf:[{$ref:"#/$defs/TypeWrapper"},{$ref:"#/$defs/TypeWrapperArray"},{$ref:"#/$defs/TypeWrapperObject"}]}},required:["kind","contains"],examples:[{kind:"array",contains:{type:{kind:"uint",bits:256}}},{kind:"struct",contains:[{member:"x",type:{kind:"uint",bits:256}},{member:"y",type:{kind:"uint",bits:256}}]},{kind:"mapping",contains:{key:{type:{kind:"address",payable:!0}},value:{type:{kind:"uint",bits:256}}}}]},TypeReference:{title:'{ "id": ... }',description:"A reference to a known type by ID",type:"object",properties:{id:{type:["string","number"]}},additionalProperties:!1,required:["id"]},TypeWrapper:{title:'{ "type": ... }',description:'A wrapper around a type. Defines a `"type"` field that may include a full Type representation or a reference to a known Type by ID. Note that this schema permits additional properties on the same object.',type:"object",properties:{type:{oneOf:[{$ref:"schema:ethdebug/format/type/base"},{$ref:"#/$defs/TypeReference"}]}},required:["type"]},TypeWrapperArray:{title:'{ "type": ... }[]',description:"A list of wrapped types, where the wrapper may add fields",type:"array",items:{$ref:"#/$defs/TypeWrapper"}},TypeWrapperObject:{title:'{ "key": { "type": ... }, ... }',description:"A key-value mapping of wrapped types, where the wrapper may add fields",type:"object",additionalProperties:{$ref:"#/$defs/TypeWrapper"}}}}].map((e=>({[e.$id]:e}))).reduce(((e,t)=>({...e,...t})),{}),r=e=>n[e]},6848:()=>{}}]);