"use strict";(self.webpackChunk_ethdebug_format_web=self.webpackChunk_ethdebug_format_web||[]).push([[93],{9310:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var r=t(5893),s=t(1151);t(6220),t(897);const i={sidebar_position:2},a="ethdebug/format/type [placeholder]",o={id:"type/type",title:"ethdebug/format/type [placeholder]",description:"This schema remains unspecified. Please see the Type schemas",source:"@site/spec/type/type.mdx",sourceDirName:"type",slug:"/type/",permalink:"/format/spec/type/",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"docsSidebar",previous:{title:"Overview",permalink:"/format/spec/type/overview"},next:{title:"ethdebug/format/type/base",permalink:"/format/spec/type/base"}},c={},p=[];function d(e){const n={a:"a",admonition:"admonition",h1:"h1",p:"p",strong:"strong",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"ethdebugformattype-placeholder",children:"ethdebug/format/type [placeholder]"}),"\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsxs)(n.p,{children:["This schema remains unspecified. Please see the Type schemas\n",(0,r.jsx)(n.a,{href:"/spec/type/overview",children:"Overview"})," for more information on how these\nschemas will be organized, and/or please review the\n",(0,r.jsxs)(n.a,{href:"/spec/type/base",children:[(0,r.jsx)(n.strong,{children:"ethdebug/format/type/base"})," schema"]})," that is intended\nto serve as base subschema for ",(0,r.jsx)(n.strong,{children:"ethdebug/format/type"}),"."]}),(0,r.jsx)(n.p,{children:"We appreciate your interest in these developing efforts."})]})]})}function l(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},6220:(e,n,t)=>{t.d(n,{Z:()=>b});var r=t(8570),s=t.n(r),i=t(9286),a=t(4866),o=t(5162),c=t(4160);const p=['$schema: "https://json-schema.org/draft/2020-12/schema"\n$id: "schema:ethdebug/format/type/base"\n\ntitle: ethdebug/format/type/base\ndescription:\n  Defines the minimally necessary schema for a data type.\n  Types belong to a particular `class` (`"elementary"` or `"complex"`),\n  and are further identified by a particular `kind`.\ntype: object\noneOf:\n  - $ref: "#/$defs/ElementaryType"\n  - $ref: "#/$defs/ComplexType"\n\n$defs:\n  ElementaryType:\n    title: ElementaryType\n    description:\n      Represents an elementary type (one that does not compose other types)\n    type: object\n    properties:\n      class:\n        type: string\n        const: elementary\n      kind:\n        type: string\n      contains:\n        not:\n          description:\n            "**Elementary types must not specify a `contains` field\n            (to make it easier to discriminate elementary vs. complex)**"\n    required:\n      - kind\n    examples:\n      - kind: uint\n        bits: 256\n\n  ComplexType:\n    title: ComplexType\n    description:\n      Represents a complex type, one that composes other types (e.g., arrays,\n      structs, mappings)\n    type: object\n    properties:\n      class:\n        type: string\n        const: complex\n        description: Indicates that this is a complex type\n      kind:\n        type: string\n        description: The specific kind of complex type, e.g., array or struct\n      contains:\n        title: ComplexType.contains\n        oneOf:\n          - $ref: "#/$defs/TypeWrapper"\n          - $ref: "#/$defs/TypeWrapperArray"\n          - $ref: "#/$defs/TypeWrapperObject"\n    required:\n      - kind\n      - contains\n    examples:\n      - kind: array\n        contains:\n          type:\n            kind: uint\n            bits: 256\n      - kind: struct\n        contains:\n          - member: x\n            type:\n              kind: uint\n              bits: 256\n          - member: y\n            type:\n              kind: uint\n              bits: 256\n      - kind: mapping\n        contains:\n          key:\n            type:\n              kind: address\n              payable: true\n          value:\n            type:\n              kind: uint\n              bits: 256\n\n  TypeReference:\n    title: \'{ "id": ... }\'\n    description: A reference to a known type by ID\n    type: object\n    properties:\n      id:\n        type:\n          - string\n          - number\n    additionalProperties: false\n    required:\n      - id\n\n  TypeWrapper:\n    title: \'{ "type": ... }\'\n    description:\n      A wrapper around a type. Defines a `"type"` field that may include a full\n      Type representation or a reference to a known Type by ID. Note that this\n      schema permits additional properties on the same object.\n    type: object\n    properties:\n      type:\n        oneOf:\n          - $ref: "schema:ethdebug/format/type/base"\n          - $ref: "#/$defs/TypeReference"\n    required:\n      - type\n\n  TypeWrapperArray:\n    title: \'{ "type": ... }[]\'\n    description: A list of wrapped types, where the wrapper may add fields\n    type: array\n    items:\n      $ref: "#/$defs/TypeWrapper"\n\n  TypeWrapperObject:\n    title: \'{ "key": { "type": ... }, ... }\'\n    description:\n      A key-value mapping of wrapped types, where the wrapper may add fields\n    type: object\n    additionalProperties:\n      $ref: "#/$defs/TypeWrapper"\n'].map((e=>({[c.ZP.parse(e).$id]:e}))).reduce(((e,n)=>({...e,...n})),{}),d={"schema:ethdebug/format/type/base":{title:"ethdebug/format/type/base schema",href:"/spec/type/base"},"schema:ethdebug/format/type/base#/$defs/TypeWrapper":{title:"Base type wrapper schema",href:"/spec/type/base#base-type-wrapper-schema"}};function l(e){let{schema:n,pointer:t}=e;if("string"==typeof t&&!t.startsWith("#"))throw new Error("`pointer` option must start with '#'");return function(e){return 1===Object.keys(e).length&&"id"in e}(n)?function(e){let{schema:{id:n},pointer:t}=e;const[r,s]=n.split("#"),i=s?function(e){const n=e.filter((e=>"string"==typeof e)).map((e=>e.slice(1))).join("");if(0===n.length)return;return`#${n}`}([`#${s}`,t]):t,a=p[r];if(!a)throw new Error(`Unknown schema with $id "${r}"`);const o=h(a,i),d=c.ZP.parse(o),l=c.ZP.parse(a);return{id:r,pointer:i,yaml:o,schema:d,rootSchema:l}}({schema:n,pointer:t}):function(e){return 1===Object.keys(e).length&&"yaml"in e}(n)?function(e){let{schema:{yaml:n},pointer:t}=e;const r=h(n,t),s=c.ZP.parse(r),i=c.ZP.parse(n),a=s.$id;return a?{id:a,pointer:t,yaml:r,schema:s,rootSchema:i}:{pointer:t,yaml:r,schema:s,rootSchema:i}}({schema:n,pointer:t}):function(e){let{schema:n,pointer:t}=e;const r=h(c.ZP.stringify(n),t),s=c.ZP.parse(r),i=s.$id;return i?{id:i,pointer:t,yaml:r,schema:s,rootSchema:n}:{pointer:t,yaml:r,schema:s,rootSchema:n}}({schema:n,pointer:t})}function h(e,n){if(!n)return e;let t=c.ZP.parseDocument(e);for(const r of n.slice(2).split("/"))if(t=t.get(r,!0),!t)throw new Error(`Pointer ${n} not found in schema`);return c.ZP.stringify(t)}var m=t(4155),y=t(2096),u=t(5893);function f(e){const{id:n,pointer:t,schema:r,yaml:s}=l(e),c=n?n.startsWith("schema:")?n.slice(7):n:void 0,p=c&&t?`${c}${t}`:c||void 0;return(0,u.jsxs)(a.default,{groupId:"schema-language",children:[(0,u.jsx)(o.default,{value:"yaml",label:"YAML",children:(0,u.jsx)(i.default,{className:"schema-listing",language:"yaml",showLineNumbers:!0,title:p||"schema.yaml",children:s})}),(0,u.jsx)(o.default,{value:"json",label:"JSON",children:(0,u.jsx)(i.default,{className:"schema-listing",language:"json",showLineNumbers:!0,title:p?`${p}`:"schema.json",children:JSON.stringify(r,void 0,2)})})]})}function b(e){const n=l(e),{id:t,rootSchema:r,yaml:c,pointer:p}=n,h=g(r,`${t}#`);return(0,u.jsxs)(a.default,{children:[(0,u.jsx)(o.default,{value:"viewer",label:"Explore",children:(0,u.jsx)(m.Gi.Provider,{value:{rootSchemaInfo:n,schemaIndex:d},children:(0,u.jsx)(s(),{schema:h,resolverOptions:{jsonPointer:p,resolvers:{schema:{resolve:e=>{const n=e.toString(),{schema:t}=l({schema:{id:n}});return g(t,`${n}#`)}}}},viewerOptions:{showExamples:!0,ValueComponent:e=>{let{value:n}=e;return["string","number","bigint","boolean"].includes(typeof n)?(0,u.jsx)("code",{children:n.toString()}):(0,u.jsx)(i.default,{language:"json",children:`${JSON.stringify(n,void 0,2)}`})},DescriptionComponent:e=>{let{description:n}=e;return(0,u.jsx)(y.U,{children:n})}}})})}),(0,u.jsx)(o.default,{value:"listing",label:"View source",children:(0,u.jsx)(f,{schema:e.schema,pointer:e.pointer})})]})}function g(e,n){return Array.isArray(e)?e.map(((e,t)=>g(e,`${n}/${t}`))):null!==e&&"object"==typeof e?Object.keys(e).reduce(((t,r)=>{const s=e[r];return t[r]=g(s,`${n}/${r}`),t}),{[m.D9]:n.endsWith("#")?n.slice(0,-1):n}):e}},4155:(e,n,t)=>{t.d(n,{D9:()=>a,Gi:()=>s,J5:()=>i});var r=t(7294);const s=(0,r.createContext)({schemaIndex:{}}),i=()=>(0,r.useContext)(s),a=Symbol("__$internalId")},4445:(e,n,t)=>{t.r(n),t.d(n,{default:()=>i});t(7294);var r=t(5295),s=t(5893);function i(e){const{schema:n}=e,t=void 0!==n.if,i=void 0!==n.dependentRequired,a=void 0!==n.dependentSchemas,o=void 0!==n.dependencies;return(0,s.jsxs)(s.Fragment,{children:[t&&(0,s.jsx)(r.IfElseThen,{schema:n}),i&&(0,s.jsx)(r.DependentRequired,{schema:n}),a&&(0,s.jsx)(r.DependentSchemas,{schema:n}),o&&(0,s.jsx)(r.Dependencies,{schema:n})]})}},8205:(e,n,t)=>{t.r(n),t.d(n,{default:()=>d});t(7294);var r=t(239),s=t.n(r),i=t(4866),a=t(5162),o=t(897),c=t(9914),p=t(5893);function d(e){const{schema:n}=e,{jsonPointer:t,level:r}=(0,c.useSchemaHierarchyContext)(),d=function(e){const{allOf:n}=e;if(!n.every((e=>{const{title:n,description:t,if:r,then:s,...i}=e;return r&&s&&0===Object.keys(i).length})))return;const t=n.every((e=>{const{if:n}=e;if(!("properties"in n))return!1;const t=n.properties;if(1!==Object.keys(t).length)return!1;const r=Object.keys(t)[0],{const:s}=t[r];return"string"==typeof s&&!!s}));if(!t)return;const r=Object.keys(n[0].if.properties)[0],s=n.map(((e,n)=>{let{if:t,then:s}=e;return{[t.properties[r].const]:{schema:s,index:n}}})).reduce(((e,n)=>({...e,...n})),{}),i=Object.keys(s).length===n.length;if(!i)return;return{propertyName:r,schemasByConst:s}}(n);if(!d)return(0,p.jsx)(p.Fragment,{children:(0,p.jsx)(s(),{...e})});const{propertyName:l,schemasByConst:h}=d;return(0,p.jsxs)("div",{children:[(0,p.jsx)("hr",{}),(0,p.jsx)("span",{className:"badge badge--info",children:"polymorphic discriminator"}),"\xa0 The value of the ",(0,p.jsx)("strong",{children:l})," field determines which sub-schema applies:",(0,p.jsx)(i.default,{children:Object.entries(h).map((e=>{let[n,{schema:s,index:i}]=e;return(0,p.jsx)(a.default,{label:n,value:n,children:(0,p.jsx)(c.SchemaHierarchyContextProvider,{value:{level:r+1,jsonPointer:`${t}/allOf/${i}`},children:(0,p.jsx)(o.CreateNodes,{schema:s})})},n)}))})]})}},2501:(e,n,t)=>{t.r(n),t.d(n,{default:()=>p});t(7294);var r=t(9212),s=t.n(r),i=t(9914),a=t(4155),o=t(9960),c=t(5893);function p(e){const{level:n}=(0,i.useSchemaHierarchyContext)(),{schemaIndex:t}=(0,a.J5)(),{schema:{[a.D9]:r,...p},...d}=e;if(r&&r in t&&n>0){const{href:e,title:n=`${r.startsWith("schema:")?r.slice(7):r} schema`}=t[r];return(0,c.jsx)(c.Fragment,{children:(0,c.jsxs)("p",{children:["See ",(0,c.jsx)(o.Z,{to:e,children:n})," documentation."]})})}return(0,c.jsx)(c.Fragment,{children:(0,c.jsx)(s(),{schema:p,...d})})}}}]);