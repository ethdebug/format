"use strict";(self.webpackChunk_ethdebug_format_web=self.webpackChunk_ethdebug_format_web||[]).push([[2095],{98870:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"docsSidebar":[{"type":"link","label":"Project overview","href":"/format/docs/overview","docId":"overview","unlisted":false},{"type":"link","label":"Known challenges","href":"/format/docs/known-challenges","docId":"known-challenges","unlisted":false},{"type":"category","label":"Prototype sketches","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"@haltman-at\'s allocation data draft","href":"/format/docs/sketches/layout","docId":"sketches/layout","unlisted":false},{"type":"link","label":"@jtoman\'s format prototype","href":"/format/docs/sketches/prototype","docId":"sketches/prototype","unlisted":false}],"href":"/format/docs/category/prototype-sketches"},{"type":"category","label":"Implementation guides","collapsible":true,"collapsed":true,"items":[{"type":"category","label":"Dereferencing pointers","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Overview","href":"/format/docs/implementation-guides/pointers/overview","docId":"implementation-guides/pointers/overview","unlisted":false},{"type":"category","label":"Essential type definitions","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Pointer types","href":"/format/docs/implementation-guides/pointers/types/pointer-types","docId":"implementation-guides/pointers/types/pointer-types","unlisted":false},{"type":"link","label":"Data and machines","href":"/format/docs/implementation-guides/pointers/types/data-and-machines","docId":"implementation-guides/pointers/types/data-and-machines","unlisted":false},{"type":"link","label":"Cursor objects","href":"/format/docs/implementation-guides/pointers/types/cursors","docId":"implementation-guides/pointers/types/cursors","unlisted":false}],"href":"/format/docs/implementation-guides/pointers/types/"},{"type":"link","label":"Reading from pointer regions","href":"/format/docs/implementation-guides/pointers/reading-from-regions","docId":"implementation-guides/pointers/reading-from-regions","unlisted":false},{"type":"link","label":"Evaluating pointer expressions","href":"/format/docs/implementation-guides/pointers/evaluating-expressions","docId":"implementation-guides/pointers/evaluating-expressions","unlisted":false},{"type":"category","label":"The dereference function","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Summary","href":"/format/docs/implementation-guides/pointers/dereference-logic/summary","docId":"implementation-guides/pointers/dereference-logic/summary","unlisted":false},{"type":"link","label":"Generating regions on the fly","href":"/format/docs/implementation-guides/pointers/dereference-logic/generating-regions","docId":"implementation-guides/pointers/dereference-logic/generating-regions","unlisted":false},{"type":"link","label":"Making regions concrete","href":"/format/docs/implementation-guides/pointers/dereference-logic/making-regions-concrete","docId":"implementation-guides/pointers/dereference-logic/making-regions-concrete","unlisted":false}],"href":"/format/docs/implementation-guides/pointers/dereference-logic/"}],"href":"/format/docs/category/dereferencing-pointers"}],"href":"/format/docs/category/implementation-guides"}]},"docs":{"implementation-guides/pointers/dereference-logic/dereference-logic":{"id":"implementation-guides/pointers/dereference-logic/dereference-logic","title":"The dereference function","description":"These next few pages cover how the components described thus far are combined","sidebar":"docsSidebar"},"implementation-guides/pointers/dereference-logic/generating-regions":{"id":"implementation-guides/pointers/dereference-logic/generating-regions","title":"Generating regions on the fly","description":"The dereference() function internally creates an","sidebar":"docsSidebar"},"implementation-guides/pointers/dereference-logic/making-regions-concrete":{"id":"implementation-guides/pointers/dereference-logic/making-regions-concrete","title":"Making regions concrete","description":"There are two main aspects involved when converting from a Pointer.Region,","sidebar":"docsSidebar"},"implementation-guides/pointers/dereference-logic/summary":{"id":"implementation-guides/pointers/dereference-logic/summary","title":"Summary","description":"The pages in this section cover the internals of the dereference() function","sidebar":"docsSidebar"},"implementation-guides/pointers/evaluating-expressions":{"id":"implementation-guides/pointers/evaluating-expressions","title":"Evaluating pointer expressions","description":"Expression evaluation is a bit more interesting than reading raw region data,","sidebar":"docsSidebar"},"implementation-guides/pointers/overview":{"id":"implementation-guides/pointers/overview","title":"Overview","description":"Debuggers looking to support ethdebug/format must be prepared to","sidebar":"docsSidebar"},"implementation-guides/pointers/reading-from-regions":{"id":"implementation-guides/pointers/reading-from-regions","title":"Reading from pointer regions","description":"Being able to read a particular pointer region\'s data from a machine state","sidebar":"docsSidebar"},"implementation-guides/pointers/types/cursors":{"id":"implementation-guides/pointers/types/cursors","title":"Cursor objects","description":"The core functionality that @ethdebug/pointers provides is the","sidebar":"docsSidebar"},"implementation-guides/pointers/types/data-and-machines":{"id":"implementation-guides/pointers/types/data-and-machines","title":"Data and machines","description":"The @ethdebug/pointers package includes two abstractions that it uses for","sidebar":"docsSidebar"},"implementation-guides/pointers/types/pointer-types":{"id":"implementation-guides/pointers/types/pointer-types","title":"Pointer types","description":"Types and type guards for all kinds of pointers","sidebar":"docsSidebar"},"implementation-guides/pointers/types/types":{"id":"implementation-guides/pointers/types/types","title":"Essential type definitions","description":"This reference implementation uses a few fundamental types/interfaces for","sidebar":"docsSidebar"},"known-challenges":{"id":"known-challenges","title":"Known challenges","description":"The fundamental challenge for an Ethereum debugging data format is that, on the","sidebar":"docsSidebar"},"overview":{"id":"overview","title":"Project overview","description":"Summary, rationale, and project goals","sidebar":"docsSidebar"},"sketches/layout":{"id":"sketches/layout","title":"@haltman-at\'s allocation data draft","description":"Initial format sketch","sidebar":"docsSidebar"},"sketches/prototype":{"id":"sketches/prototype","title":"@jtoman\'s format prototype","description":"Initial format sketch","sidebar":"docsSidebar"}}}}')}}]);