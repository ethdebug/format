(self.webpackChunk_ethdebug_format_web=self.webpackChunk_ethdebug_format_web||[]).push([[1685],{41374:(e,t,n)=>{"use strict";n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>d});var i=n(52322),o=n(45392),s=n(51114);const r={sidebar_position:3},c="Invoking the compiler",a={id:"implementation-guides/pointers/testing/compilation",title:"Invoking the compiler",description:"In being able to test a pointer dereference implementation, it is necessary to",source:"@site/docs/implementation-guides/pointers/testing/compilation.mdx",sourceDirName:"implementation-guides/pointers/testing",slug:"/implementation-guides/pointers/testing/compilation",permalink:"/format/docs/implementation-guides/pointers/testing/compilation",draft:!1,unlisted:!1,editUrl:"https://github.com/ethdebug/format/tree/main/packages/web/docs/implementation-guides/pointers/testing/compilation.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"docsSidebar",previous:{title:"Finding example pointers",permalink:"/format/docs/implementation-guides/pointers/testing/example-pointers"},next:{title:"Simulating a blockchain",permalink:"/format/docs/implementation-guides/pointers/testing/blockchain-simulation"}},l={},d=[{value:"Integration logic",id:"integration-logic",level:2},{value:"The <code>CompileOptions</code> interface",id:"the-compileoptions-interface",level:2},{value:"&quot;Syntactic sugar&quot;-like helper function",id:"syntactic-sugar-like-helper-function",level:2}];function p(e){const t={code:"code",h1:"h1",h2:"h2",p:"p",strong:"strong",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"invoking-the-compiler",children:"Invoking the compiler"}),"\n",(0,i.jsxs)(t.p,{children:["In being able to test a pointer dereference implementation, it is necessary to\npair each tested pointer with associated EVM code that makes the pointer\nmeaningful. To avoid solutions such as pre-compiling Solidity or handwriting EVM\nbytecode, the ",(0,i.jsx)(t.strong,{children:"@ethdebug/pointers"})," reference implementation's integration\ntests are written so that each test case is described in terms of Solidity code\nthat the testing infrastructure compiles when executing the test."]}),"\n",(0,i.jsxs)(t.p,{children:["The strategy taken by these tests is to use Solidity's ",(0,i.jsx)(t.code,{children:"constructor"})," mechanism\nfor allowing tests to specify variable assignment and mutation logic without\nneeding to manage deployed contract instances. All these integration test cases\nthus observe pointers only via the trace of a contract creation transaction."]}),"\n",(0,i.jsx)(t.h2,{id:"integration-logic",children:"Integration logic"}),"\n",(0,i.jsxs)(t.p,{children:["This testing infrastructure includes the ",(0,i.jsx)(t.code,{children:"compileCreateBytecode()"})," function,\nwhich accepts input resembling Solidity's compiler input data as argument (i.e.,\nthe collection of source contents by path and additional contract target\ninformation) and asynchronously returns ",(0,i.jsx)(t.code,{children:"Data"})," with the create (deployment)\nbytecode for the target contract."]}),"\n",(0,i.jsx)(s.Z,{packageName:"@ethdebug/pointers",sourcePath:"test/solc.ts",extract:e=>e.getFunction("compileCreateBytecode")}),"\n",(0,i.jsxs)(t.h2,{id:"the-compileoptions-interface",children:["The ",(0,i.jsx)(t.code,{children:"CompileOptions"})," interface"]}),"\n",(0,i.jsx)(s.Z,{packageName:"@ethdebug/pointers",sourcePath:"test/solc.ts",extract:e=>e.getInterface("CompileOptions")}),"\n",(0,i.jsx)(t.h2,{id:"syntactic-sugar-like-helper-function",children:'"Syntactic sugar"-like helper function'}),"\n",(0,i.jsxs)(t.p,{children:["To avoid test cases' needing to describe their associated code samples in terms\nof source content by path, test cases that require only a single source file can\nuse the ",(0,i.jsx)(t.code,{children:"singleSourceCompilation()"})," helper function that provides a more\nsuccinct method for generating ",(0,i.jsx)(t.code,{children:"CompileOptions"})," objects:"]}),"\n",(0,i.jsx)(s.Z,{packageName:"@ethdebug/pointers",sourcePath:"test/solc.ts",extract:e=>e.getFunction("singleSourceCompilation")})]})}function h(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},48313:e=>{function t(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}t.keys=()=>[],t.resolve=t,t.id=48313,e.exports=t},51114:(e,t,n)=>{"use strict";n.d(t,{Z:()=>a});var i=n(84560),o=n.n(i),s=n(20477),r=n(42408);var c=n(52322);function a(e){let{packageName:t,sourcePath:n,extract:i,...a}=e;const l=function(e){const{packages:t}=(0,r.eZ)("project-code-plugin");if(!(e in t))throw new Error(`Unknown package name ${e}`);const{sourceFiles:n}=t[e],i=new s.IKL({useInMemoryFileSystem:!0});for(const{filePath:o,text:s}of n)i.createSourceFile(o,s,{overwrite:!0});return i}(t),d=l.getSourceFileOrThrow(n);if(!i)return(0,c.jsx)(o(),{title:n,language:"typescript",showLineNumbers:!0,children:d.getFullText()});const p=i(d,l);return(0,c.jsx)(o(),{language:"typescript",...a,children:p.getFullText().trim()})}},56699:()=>{},68379:()=>{},68382:()=>{},78867:()=>{},21212:()=>{},89854:()=>{},25800:()=>{},93037:()=>{},26996:()=>{}}]);