"use strict";(self.webpackChunk_ethdebug_format_web=self.webpackChunk_ethdebug_format_web||[]).push([[7316],{80046:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>c,toc:()=>m});var a=n(52322),r=n(45392),s=n(78962);const i={sidebar_position:1},o="Overview",c={id:"program/overview",title:"Overview",description:"ethdebug/format/program is a JSON schema for describing compile-time",source:"@site/spec/program/overview.mdx",sourceDirName:"program",slug:"/program/overview",permalink:"/format/spec/program/overview",draft:!1,unlisted:!1,editUrl:"https://github.com/ethdebug/format/tree/main/packages/web/spec/program/overview.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"docsSidebar",previous:{title:"Source range schema",permalink:"/format/spec/materials/source-range"},next:{title:"Key concepts",permalink:"/format/spec/program/concepts"}},l={},m=[{value:"Status",id:"status",level:2},{value:"Reading this schema",id:"reading-this-schema",level:2}];function h(e){const t={a:"a",admonition:"admonition",h1:"h1",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"overview",children:"Overview"}),"\n",(0,a.jsxs)(t.admonition,{title:"Summary",type:"tip",children:[(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"ethdebug/format/program"})," is a JSON schema for describing compile-time\ninformation about EVM bytecode, organized from the perspective of individual\nmachine instructions."]}),(0,a.jsxs)(t.p,{children:["In ",(0,a.jsx)(t.strong,{children:"ethdebug/format"}),', a program record (or "program") represents one block of\nexecutable EVM machine code that a compiler generated for a specific contract.\nThis could be either the contract\'s runtime call bytecode or the bytecode\nto create the contract.']}),(0,a.jsx)(t.p,{children:'A program is structured as a sequence of instruction records ("instructions"),\nwhere each corresponds to a single EVM instruction in the machine code. Each\ninstruction contains information about the high-level language context at that\npoint in the bytecode. This allows debuggers to map low-level machine state\nback to high-level language concepts at any point during execution.'}),(0,a.jsx)(t.p,{children:"Key information that programs contain for a particular instruction might\ninclude:"}),(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:'the source range or source ranges that are "associated" with the\ninstruction'}),"\n",(0,a.jsx)(t.li,{children:"the collection of known high-level variables at that point in time,\nincluding their types and where to find the bytes with those variables'\nvalues"}),"\n",(0,a.jsx)(t.li,{children:"signals to indicate that the instruction is part of some control flow\noperation, such as calling some function from another."}),"\n"]}),(0,a.jsxs)(t.p,{children:["These program records provide debuggers with a powerful reference resource\nto be consulted while observing a running EVM. At each step of EVM machine\nexecution, debuggers can find the matching ",(0,a.jsx)(t.strong,{children:"ethdebug/format"})," program\ninstruction and use its information to maintain a coherent model of the\nhigh-level world, step-by-step."]})]}),"\n",(0,a.jsxs)(t.p,{children:["This format defines the primary ",(0,a.jsx)(t.strong,{children:"ethdebug/format/program"})," schema as well as\nvarious sub-schemas in the ethdebug/format/program/* namespace."]}),"\n",(0,a.jsxs)(t.p,{children:["JSON values adhering to this schema contain comprehensive information about a\nparticular EVM bytecode object. This includes contract metadata (e.g., reference to the source range where the contract is defined) and, importantly, an\nordered list of ",(0,a.jsx)(t.strong,{children:"ethdebug/format/program/instruction"})," objects."]}),"\n",(0,a.jsx)(t.p,{children:"Each instruction object contains essential details for translating low-level\nmachine state at the time of the instruction back into high-level language\nconcepts. This allows debuggers to provide a meaningful representation of\nprogram state at any point during execution."}),"\n",(0,a.jsx)(t.h2,{id:"status",children:"Status"}),"\n",(0,a.jsx)(s.Z,{schema:"program"}),"\n",(0,a.jsx)(t.h2,{id:"reading-this-schema",children:"Reading this schema"}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.strong,{children:"ethdebug/format/program"})," schema is a root schema that composes other\nrelated schemas in the ethdebug/format/program/* namespace."]}),"\n",(0,a.jsxs)(t.p,{children:["These schemas (like all schemas in this format) are specified as\n",(0,a.jsx)(t.a,{href:"https://json-schema.org",children:"JSON Schema"}),", draft 2020-12."]}),"\n",(0,a.jsx)(t.p,{children:"Please refer to one or more of the following resources in this section, or\nsee the navigation bar for complete contents:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"/spec/program/concepts",children:"Key concepts"})}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"/spec/program",children:"Schema"})," (",(0,a.jsx)(t.strong,{children:"ethdebug/format/program"})," schema listing)"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"/spec/program/instruction",children:"Instruction schema"}),"\n(",(0,a.jsx)(t.strong,{children:"ethdebug/format/program/instruction"})," schema listing)"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"/spec/program/context",children:"Context schema"}),"\n(",(0,a.jsx)(t.strong,{children:"ethdebug/format/program/context"})," schema listing)"]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},21758:(e,t,n)=>{n.d(t,{Z:()=>o});n(2784);var a=n(27718),r=n(26322);const s={badge:"badge_iR2u",link:"link_nYcl",small:"small_Yy3L",medium:"medium_LJck",large:"large_yhV6","in-design":"in-design_I73u",implementable:"implementable_biw8","reference-available":"reference-available_fUlT"};var i=n(52322);function o(e){let{status:t,size:n="medium",linkToStatus:o=!0}=e;const c=r.N4[t],l=(0,i.jsx)("span",{className:`${s.badge} ${s[n]} ${s[t]}`,title:c.description,children:c.label});return o?(0,i.jsx)(a.Z,{to:"/status",className:s.link,children:l}):l}},78962:(e,t,n)=>{n.d(t,{Z:()=>c});n(2784);var a=n(27718),r=n(26322),s=n(21758);const i={banner:"banner_ic1Q","in-design":"in-design_l2HR",implementable:"implementable_QDmt","reference-available":"reference-available_b2oQ",header:"header_E_u8",summary:"summary_t2HN",caveats:"caveats_r5DJ",note:"note_Tv0e",reference:"reference_ZvC4",learnMore:"learnMore_fSRC"};var o=n(52322);function c(e){let{schema:t}=e;const n=r.Wk[t],c=r.N4[n.level];return(0,o.jsxs)("div",{className:`${i.banner} ${i[n.level]}`,children:[(0,o.jsx)("div",{className:i.header,children:(0,o.jsx)(s.Z,{status:n.level,linkToStatus:!1,size:"large"})}),(0,o.jsx)("p",{className:i.summary,children:n.summary}),n.caveats.length>0&&(0,o.jsxs)("div",{className:i.caveats,children:[(0,o.jsx)("strong",{children:"Known limitations:"}),(0,o.jsx)("ul",{children:n.caveats.map(((e,t)=>(0,o.jsx)("li",{children:e},t)))})]}),(0,o.jsx)("p",{className:i.note,children:c.adoptersNote}),n.referenceUrl&&(0,o.jsx)("p",{className:i.reference,children:(0,o.jsx)(a.Z,{to:n.referenceUrl,children:"View reference implementation guide \u2192"})}),(0,o.jsx)("p",{className:i.learnMore,children:(0,o.jsx)(a.Z,{to:"/status",children:"Learn more about status levels \u2192"})})]})}},26322:(e,t,n)=>{n.d(t,{N4:()=>a,Wk:()=>r});const a={"in-design":{label:"In Design",color:"#6366f1",description:"Actively being developed. Expect significant changes to structure and semantics.",adoptersNote:"Early feedback welcome, but implementations should expect breaking changes."},implementable:{label:"Implementable",color:"#d97706",description:"Stable enough to build against. Minor changes possible but core design is settled.",adoptersNote:"Tooling can implement against this schema with reasonable confidence."},"reference-available":{label:"Reference Available",color:"#059669",description:"Stable schema with a working reference implementation available (debugger-side and/or compiler-side).",adoptersNote:"Reference implementation demonstrates correct behavior. Check details for which side (debugger/compiler) has implementations."}},r={pointer:{level:"reference-available",summary:"Comprehensive schema for describing data locations in EVM state. Debugger-side reference implementation available in @ethdebug/pointers.",caveats:["Pointer templates cannot rename their output region names, limiting composability for complex scenarios.","No compiler-side reference implementation yet."],detailsPath:"/spec/pointer/overview#status",referenceUrl:"/docs/implementation-guides/pointers"},type:{level:"implementable",summary:"Complete coverage of Solidity types (elementary and complex).",caveats:["No support for generic types (e.g., parameterized types)."],detailsPath:"/spec/type/overview#status"},program:{level:"in-design",summary:"Schema for describing high-level program structure and instruction contexts. Core structure is foundational, but context system is actively evolving.",caveats:["Context types for function calls, returns, and reverts are still being designed.","Broader structural changes may occur to accommodate new concerns."],detailsPath:"/spec/program/overview#status"},data:{level:"implementable",summary:"Foundational schemas for common data representations (hex strings, unsigned integers, values).",caveats:[],detailsPath:"/spec/data/overview#status"},materials:{level:"implementable",summary:"Schemas for compilation metadata, source files, and source ranges.",caveats:[],detailsPath:"/spec/materials/overview#status"},info:{level:"implementable",summary:"Intentionally minimal schema for representing compilation-related debug information.",caveats:[],detailsPath:"/spec/info/overview#status"}}}}]);