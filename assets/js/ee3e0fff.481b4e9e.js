"use strict";(self.webpackChunk_ethdebug_format_web=self.webpackChunk_ethdebug_format_web||[]).push([[9437],{86512:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>c,toc:()=>h});var i=s(52322),r=s(45392),t=s(64223);const o={sidebar_position:6},a="Expression syntax",c={id:"pointer/expression",title:"Expression syntax",description:"Pointer expressions operate on the domain of bytes representing unsigned",source:"@site/spec/pointer/expression.mdx",sourceDirName:"pointer",slug:"/pointer/expression",permalink:"/format/spec/pointer/expression",draft:!1,unlisted:!1,editUrl:"https://github.com/ethdebug/format/tree/main/packages/web/spec/pointer/expression.mdx",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"docsSidebar",previous:{title:"Scope",permalink:"/format/spec/pointer/collection/scope"},next:{title:"ethdebug/format/materials",permalink:"/format/spec/category/ethdebugformatmaterials"}},d={},h=[{value:"Literal values",id:"literal-values",level:2},{value:"Scalar variables",id:"scalar-variables",level:2},{value:"Arithmetic operations",id:"arithmetic-operations",level:2},{value:"Lookup region definition",id:"lookup-region-definition",level:2},{value:"Reading from the EVM",id:"reading-from-the-evm",level:2},{value:"Keccak256 hashes",id:"keccak256-hashes",level:2},{value:"Region references",id:"region-references",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"expression-syntax",children:"Expression syntax"}),"\n",(0,i.jsx)(n.p,{children:"Pointer expressions operate on the domain of bytes representing unsigned\nintegers."}),"\n",(0,i.jsx)(t.Z,{schema:{id:"schema:ethdebug/format/pointer/expression"}}),"\n",(0,i.jsx)(n.h2,{id:"literal-values",children:"Literal values"}),"\n",(0,i.jsx)(n.p,{children:"An expression can be a literal value."}),"\n",(0,i.jsxs)(n.p,{children:["Literal values ",(0,i.jsx)(n.strong,{children:"must"})," be represented either as JSON numbers or as\n",(0,i.jsx)(n.code,{children:"0x"}),"-prefixed hexadecimal strings. Hexadecimal strings always represent a\nliteral string of bytes."]}),"\n",(0,i.jsx)(n.p,{children:"For convenience, this schema does not restrict hexadecimal string\nrepresentations to those that specify an even-number of digits (i.e., those\nthat specify complete byte pairs); odd numbers of hexadecimal digits are fine."}),"\n",(0,i.jsxs)(n.p,{children:["Hexadecimal string representations ",(0,i.jsx)(n.strong,{children:"may"})," omit leading zeroes; values are\nassumed to be left-padded to the bytes width appropriate for the context."]}),"\n",(0,i.jsx)(t.Z,{schema:{id:"schema:ethdebug/format/pointer/expression"},pointer:"#/$defs/Literal"}),"\n",(0,i.jsx)(n.h2,{id:"scalar-variables",children:"Scalar variables"}),"\n",(0,i.jsx)(n.p,{children:"An expression can be a string value equal to the identifier for a known\nscalar variable introduced by some pointer representation."}),"\n",(0,i.jsxs)(n.p,{children:["For an example where scalar variables may appear, see the\n",(0,i.jsx)(n.a,{href:"/spec/pointer/collection/list",children:"List collection schema"}),"."]}),"\n",(0,i.jsx)(t.Z,{schema:{id:"schema:ethdebug/format/pointer/expression"},pointer:"#/$defs/Literal"}),"\n",(0,i.jsx)(n.h2,{id:"arithmetic-operations",children:"Arithmetic operations"}),"\n",(0,i.jsxs)(n.p,{children:["An expression can be an object of the form ",(0,i.jsx)(n.code,{children:"{ <op>: [...] }"}),", where ",(0,i.jsx)(n.code,{children:"<op>"}),"\ndenotes an arithmetic operation."]}),"\n",(0,i.jsx)(t.Z,{schema:{id:"schema:ethdebug/format/pointer/expression"},pointer:"#/$defs/Arithmetic"}),"\n",(0,i.jsx)(n.h2,{id:"lookup-region-definition",children:"Lookup region definition"}),"\n",(0,i.jsxs)(n.p,{children:["An expression can reference properties defined for a particular region, such as\nanother region's ",(0,i.jsx)(n.code,{children:'"offset"'})," or ",(0,i.jsx)(n.code,{children:'"length"'}),". Such expressions resolve to the\nsame value as the expression specified for that corresponding property."]}),"\n",(0,i.jsx)(t.Z,{schema:{id:"schema:ethdebug/format/pointer/expression"},pointer:"#/$defs/Lookup"}),"\n",(0,i.jsx)(n.h2,{id:"reading-from-the-evm",children:"Reading from the EVM"}),"\n",(0,i.jsxs)(n.p,{children:["An expression can be an object of the form ",(0,i.jsx)(n.code,{children:'{ "$read": "<region>" }'}),", where\n",(0,i.jsx)(n.code,{children:"<region>"})," references a particular region defined in some root pointer."]}),"\n",(0,i.jsx)(n.p,{children:"The value of such an expression is the concatenation of bytes present in the\nrunning machine state that correspond to the bytes addressed by the referenced\nregion."}),"\n",(0,i.jsx)(t.Z,{schema:{id:"schema:ethdebug/format/pointer/expression"},pointer:"#/$defs/Read"}),"\n",(0,i.jsx)(n.h2,{id:"keccak256-hashes",children:"Keccak256 hashes"}),"\n",(0,i.jsxs)(n.p,{children:["An expression can be an object of form ",(0,i.jsx)(n.code,{children:'{ "$keccak256": [...] }'}),", indicating\nthat the value of the expression is a Solidity-style, tightly-packed keccak256\nhash of the concatenation of bytes specified by the list."]}),"\n",(0,i.jsx)(t.Z,{schema:{id:"schema:ethdebug/format/pointer/expression"},pointer:"#/$defs/Keccak256"}),"\n",(0,i.jsx)(n.h2,{id:"region-references",children:"Region references"}),"\n",(0,i.jsxs)(n.p,{children:["Regions can be referenced either by name (which ",(0,i.jsx)(n.strong,{children:"must"})," be a defined region),\nor by use of the literal string value ",(0,i.jsx)(n.code,{children:'"$this"'})," (which indicates that the\nreferenced region is the region containing the expression itself)."]}),"\n",(0,i.jsxs)(n.p,{children:["In cases where an expression is used outside the context of a particular\nregion definition, the use of ",(0,i.jsx)(n.code,{children:'"$this"'})," is ",(0,i.jsx)(n.strong,{children:"prohibited"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Individual properties ",(0,i.jsx)(n.strong,{children:"may not"})," be defined with any reference to themselves.\nProperties also ",(0,i.jsx)(n.strong,{children:"may not"})," be defined in terms of mutual reference to each\nother. ",(0,i.jsx)("small",{children:"(Don't make this harder than it has to be.)"})]}),"\n",(0,i.jsx)(t.Z,{schema:{id:"schema:ethdebug/format/pointer/expression"},pointer:"#/$defs/Reference"})]})}function p(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);