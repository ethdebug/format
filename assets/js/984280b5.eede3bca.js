"use strict";(globalThis.webpackChunk_ethdebug_format_web=globalThis.webpackChunk_ethdebug_format_web||[]).push([[3881],{792(e,n,s){s.d(n,{A:()=>h});s(14041);var t=s(40665);const r="container_Hrln",i="link_y57m",o="label_feh8",a="schema_kJnE",c="arrow_YbSg";var l=s(31085);function h({schema:e,href:n}){return(0,l.jsx)("div",{className:r,children:(0,l.jsxs)(t.A,{to:n,className:i,children:[(0,l.jsx)("span",{className:o,children:"Schema:"}),(0,l.jsx)("span",{className:a,children:e}),(0,l.jsx)("span",{className:c,children:"\u2192"})]})})}},56733(e,n,s){s.r(n),s.d(n,{assets:()=>h,contentTitle:()=>l,default:()=>x,frontMatter:()=>c,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"concepts/programs","title":"Programs","description":"This page explains the mental model behind ethdebug/format program","source":"@site/docs/concepts/programs.mdx","sourceDirName":"concepts","slug":"/concepts/programs","permalink":"/format/docs/concepts/programs","draft":false,"unlisted":false,"editUrl":"https://github.com/ethdebug/format/tree/main/packages/web/docs/concepts/programs.mdx","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"docsSidebar","previous":{"title":"Pointers","permalink":"/format/docs/concepts/pointers"},"next":{"title":"Info","permalink":"/format/docs/concepts/info"}}');var r=s(31085),i=s(71184),o=s(792),a=s(87270);const c={sidebar_position:5},l="Programs",h={},d=[{value:"Programs map bytecode to high-level context",id:"programs-map-bytecode-to-high-level-context",level:2},{value:"Programs correspond to bytecode",id:"programs-correspond-to-bytecode",level:2},{value:"Instruction listings",id:"instruction-listings",level:2},{value:"Context information",id:"context-information",level:2},{value:"Source ranges",id:"source-ranges",level:3},{value:"Variables",id:"variables",level:3},{value:"Compilation frame",id:"compilation-frame",level:3},{value:"Context is valid after instruction execution",id:"context-is-valid-after-instruction-execution",level:2},{value:"Contexts as state transitions",id:"contexts-as-state-transitions",level:2},{value:"What tracing enables",id:"what-tracing-enables",level:2},{value:"Next steps",id:"next-steps",level:2}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"programs",children:"Programs"})}),"\n",(0,r.jsx)(o.A,{schema:"ethdebug/format/program",href:"/spec/program/overview"}),"\n",(0,r.jsxs)(n.p,{children:["This page explains the mental model behind ",(0,r.jsx)(n.strong,{children:"ethdebug/format"})," program\nrepresentations. For reference documentation on instructions, variables, and\ntracing, see the ",(0,r.jsx)(n.a,{href:"/docs/core-schemas/programs",children:"Programs reference"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"programs-map-bytecode-to-high-level-context",children:"Programs map bytecode to high-level context"}),"\n",(0,r.jsxs)(n.p,{children:["When a compiler transforms source code into bytecode, it creates a gap between\nwhat developers wrote and what actually executes. A ",(0,r.jsx)(n.strong,{children:"program"})," bridges this\ngap by providing high-level context for each bytecode instruction."]}),"\n",(0,r.jsx)(n.p,{children:"Programs enable debuggers to answer:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"What source code corresponds to this instruction?"}),"\n",(0,r.jsx)(n.li,{children:"What variables are in scope right now?"}),"\n",(0,r.jsx)(n.li,{children:"What function are we in?"}),"\n",(0,r.jsx)(n.li,{children:'Should this instruction be treated as "stepping into" a call?'}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"programs-correspond-to-bytecode",children:"Programs correspond to bytecode"}),"\n",(0,r.jsx)(n.p,{children:"Each program is associated with a specific piece of bytecode:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Call bytecode"})," \u2014 executed when a contract receives a message"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Create bytecode"})," \u2014 executed during contract deployment"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The same contract typically has both: create bytecode runs once during\ndeployment, call bytecode runs whenever the contract is invoked afterward."}),"\n",(0,r.jsxs)(n.p,{children:['Think of it as: "you have this bytecode \u2192 here\'s its program." A program\nreferences the compilation that produced the bytecode, linking back to\nsource files and compiler metadata through the\n',(0,r.jsx)(n.a,{href:"/docs/core-schemas/info/resources",children:"info/resources"})," schema."]}),"\n",(0,r.jsx)(n.h2,{id:"instruction-listings",children:"Instruction listings"}),"\n",(0,r.jsxs)(n.p,{children:["Programs contain a sequential list of ",(0,r.jsx)(n.strong,{children:"instructions"}),", one for each machine\ninstruction in the bytecode. Each instruction specifies:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"offset"})," \u2014 the byte position in the bytecode (equal to the program counter\non non-EOF EVMs)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"context"})," \u2014 high-level information about this point in execution"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Instructions are ordered to match the bytecode, enabling fast lookup by offset.\nNot every byte offset has an entry \u2014 only positions where opcodes begin."}),"\n",(0,r.jsx)(a.A,{schema:"program",href:"/spec/program/overview",title:"Instruction list",children:'{\n  "instructions": [\n    { "offset": 0, "context": { /* ... */ } },\n    { "offset": 1, "context": { /* ... */ } },\n    { "offset": 4, "context": { /* ... */ } }\n  ]\n}'}),"\n",(0,r.jsx)(n.h2,{id:"context-information",children:"Context information"}),"\n",(0,r.jsxs)(n.p,{children:["Each instruction's ",(0,r.jsx)(n.strong,{children:"context"})," describes what's true at that point in\nexecution. Context information may include:"]}),"\n",(0,r.jsx)(n.h3,{id:"source-ranges",children:"Source ranges"}),"\n",(0,r.jsx)(n.p,{children:"Which source code relates to this instruction:"}),"\n",(0,r.jsx)(a.A,{schema:"program/context/code",href:"/spec/program/context/code",children:'{\n  "code": {\n    "source": { "id": "source-1" },\n    "range": { "offset": 150, "length": 25 }\n  }\n}'}),"\n",(0,r.jsx)(n.h3,{id:"variables",children:"Variables"}),"\n",(0,r.jsx)(n.p,{children:"What variables are in scope and where to find their values:"}),"\n",(0,r.jsx)(a.A,{schema:"program/context/variables",href:"/spec/program/context/variables",children:'{\n  "variables": [\n    {\n      "identifier": "balance",\n      "type": { "kind": "uint", "bits": 256 },\n      "pointer": { "location": "storage", "slot": 0 }\n    }\n  ]\n}'}),"\n",(0,r.jsx)(n.p,{children:"Each variable has an identifier, a type, and a pointer. The pointer tells the\ndebugger where to find the variable's current value."}),"\n",(0,r.jsx)(n.h3,{id:"compilation-frame",children:"Compilation frame"}),"\n",(0,r.jsx)(n.p,{children:"Specifies which compilation frame the context applies to. This\nsupports compilers with distinct stages (e.g., source language vs.\nintermediate representation):"}),"\n",(0,r.jsx)(a.A,{schema:"program/context/frame",href:"/spec/program/context/frame",children:'{\n  "frame": "source"\n}'}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"frame"})," value is a string naming the relevant compilation frame\n(e.g., ",(0,r.jsx)(n.code,{children:'"source"'}),", ",(0,r.jsx)(n.code,{children:'"ir"'}),"), allowing the same instruction to carry\ncontext for different compiler stages."]}),"\n",(0,r.jsx)(n.h2,{id:"context-is-valid-after-instruction-execution",children:"Context is valid after instruction execution"}),"\n",(0,r.jsxs)(n.p,{children:["An instruction's context describes the state that exists ",(0,r.jsx)(n.strong,{children:"after"})," that\ninstruction completes. This timing is important:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Before the instruction runs, the previous context applies"}),"\n",(0,r.jsx)(n.li,{children:"After the instruction runs, this context applies"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"For example, if an instruction stores a value in a variable, the variable's\npointer in that instruction's context points to where the value now lives."}),"\n",(0,r.jsx)(n.h2,{id:"contexts-as-state-transitions",children:"Contexts as state transitions"}),"\n",(0,r.jsx)(n.p,{children:"A debugger maintains a model of the high-level program state as it steps\nthrough execution. Each context encountered serves as a state transition:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Debugger observes the program counter"}),"\n",(0,r.jsx)(n.li,{children:"Looks up the instruction at that offset"}),"\n",(0,r.jsx)(n.li,{children:"Reads the context to learn what changed"}),"\n",(0,r.jsx)(n.li,{children:"Updates its high-level state model"}),"\n",(0,r.jsx)(n.li,{children:"Continues to the next instruction"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Contexts can be composed using:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"gather"})," \u2014 combine multiple context pieces together"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"pick"})," \u2014 choose a context based on a runtime condition"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"remark"})," \u2014 add metadata without changing scope"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This composition enables describing complex scenarios like conditional variable\nassignments or function inlining."}),"\n",(0,r.jsx)(n.h2,{id:"what-tracing-enables",children:"What tracing enables"}),"\n",(0,r.jsx)(n.p,{children:"By following contexts through execution, debuggers can provide:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source mapping"})," \u2014 show the current line in source code"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Variable inspection"})," \u2014 display current values of in-scope variables"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Call stacks"})," \u2014 reconstruct function call history"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Data structure visualization"})," \u2014 present arrays and mappings meaningfully"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Control flow insight"})," \u2014 indicate loop iterations, function boundaries"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The program schema provides the compile-time guarantees that make runtime\ndebugging possible."}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/core-schemas/programs/instructions",children:"Instructions"})})," \u2014 Reference for instruction\nstructure"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/core-schemas/programs/variables",children:"Variables"})})," \u2014 Reference for variable\ndefinitions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/core-schemas/programs/tracing",children:"Tracing"})})," \u2014 Guide to using programs during\nexecution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/spec/program",children:"Program specification"})})," \u2014 Formal schema definitions"]}),"\n"]})]})}function x(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},87270(e,n,s){s.d(n,{A:()=>x});s(14041);var t=s(40665),r=s(54034),i=s.n(r);const o="container_eo8G",a="header_CGit",c="title_NhXp",l="schemaLink_R3qF",h="schemaName_hPpq",d="schemaLabel_TlZH";var p=s(31085);function x({schema:e,href:n,children:s,title:r}){const x="string"==typeof s?s:JSON.stringify(s,null,2),m=e.startsWith("ethdebug/format/")?e:`ethdebug/format/${e}`;return(0,p.jsxs)("div",{className:o,children:[(0,p.jsxs)("div",{className:a,children:[r&&(0,p.jsx)("span",{className:c,children:r}),(0,p.jsxs)(t.A,{to:n,className:l,children:[(0,p.jsx)("span",{className:d,children:"Schema:"}),(0,p.jsx)("span",{className:h,children:m})]})]}),(0,p.jsx)(i(),{language:"json",children:x})]})}}}]);