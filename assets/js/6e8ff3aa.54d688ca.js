"use strict";(self.webpackChunk_ethdebug_format_web=self.webpackChunk_ethdebug_format_web||[]).push([[93],{9310:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>o,contentTitle:()=>p,default:()=>y,frontMatter:()=>n,metadata:()=>a,toc:()=>d});var s=r(5893),i=r(1151);r(6419),r(897),r(4618);const n={sidebar_position:2},p="ethdebug/format/type [placeholder]",a={id:"type/type",title:"ethdebug/format/type [placeholder]",description:"This schema remains unspecified. Please see the Type schemas",source:"@site/spec/type/type.mdx",sourceDirName:"type",slug:"/type/",permalink:"/format/spec/type/",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"docsSidebar",previous:{title:"Overview",permalink:"/format/spec/type/overview"},next:{title:"ethdebug/format/type/base",permalink:"/format/spec/type/base"}},o={},d=[];function c(e){const t={a:"a",admonition:"admonition",h1:"h1",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"ethdebugformattype-placeholder",children:"ethdebug/format/type [placeholder]"}),"\n",(0,s.jsxs)(t.admonition,{type:"note",children:[(0,s.jsxs)(t.p,{children:["This schema remains unspecified. Please see the Type schemas\n",(0,s.jsx)(t.a,{href:"/spec/type/overview",children:"Overview"})," for more information on how these\nschemas will be organized, and/or please review the\n",(0,s.jsxs)(t.a,{href:"/spec/type/base",children:[(0,s.jsx)(t.strong,{children:"ethdebug/format/type/base"})," schema"]})," that is intended\nto serve as base subschema for ",(0,s.jsx)(t.strong,{children:"ethdebug/format/type"}),"."]}),(0,s.jsx)(t.p,{children:"We appreciate your interest in these developing efforts."})]})]})}function y(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},6419:(e,t,r)=>{r.d(t,{Z:()=>c});var s=r(8570),i=r.n(s),n=r(9286),p=r(4618),a=r(2096),o=r(5893);const d=(e,t,r)=>{const s=i=>t(i)?r(i,e):"object"!=typeof i||null===i?i:Array.isArray(i)?i.map((e=>s(e))):Object.keys(i).reduce(((e,t)=>(e[t]=s(i[t]),e)),{});return s(e)};function c(e){let{schema:t,pointer:r="",detect:s=(()=>!1),transform:c=(e=>e)}=e;const y="string"==typeof t?(0,p.V)(t):t,l=d(y,s,c);return(0,o.jsx)(i(),{schema:l,resolverOptions:{jsonPointer:r,resolvers:{schema:{resolve:e=>(0,p.V)(e.toString())}}},viewerOptions:{showExamples:!0,ValueComponent:e=>{let{value:t}=e;return["string","number","bigint","boolean"].includes(typeof t)?(0,o.jsx)("code",{children:t.toString()}):(0,o.jsx)(n.default,{language:"json",children:`${JSON.stringify(t,void 0,2)}`})},DescriptionComponent:e=>{let{description:t}=e;return(0,o.jsx)(a.U,{children:t})}}})}},4618:(e,t,r)=>{r.d(t,{V:()=>i});const s=[{$schema:"https://json-schema.org/draft/2020-12/schema",$id:"schema:ethdebug/format/type/base",title:"ethdebug/format/type/base",description:'Defines the minimally necessary schema for a data type. Types belong to a particular `class` (`"elementary"` or `"complex"`), and are further identified by a particular `kind`.',type:"object",oneOf:[{$ref:"#/$defs/ElementaryType"},{$ref:"#/$defs/ComplexType"}],$defs:{ElementaryType:{title:"ElementaryType",description:"Represents an elementary type (one that does not compose other types)",type:"object",properties:{class:{type:"string",const:"elementary"},kind:{type:"string"},contains:{not:{description:"**Elementary types must not specify a `contains` field (to make it easier to discriminate elementary vs. complex)**"}}},required:["kind"],examples:[{kind:"uint",bits:256}]},ComplexType:{title:"ComplexType",description:"Represents a complex type, one that composes other types (e.g., arrays, structs, mappings)",type:"object",properties:{class:{type:"string",const:"complex",description:"Indicates that this is a complex type"},kind:{type:"string",description:"The specific kind of complex type, e.g., array or struct"},contains:{title:"ComplexType.contains",oneOf:[{$ref:"#/$defs/TypeWrapper"},{$ref:"#/$defs/TypeWrapperArray"},{$ref:"#/$defs/TypeWrapperObject"}]}},required:["kind","contains"],examples:[{kind:"array",contains:{type:{kind:"uint",bits:256}}},{kind:"struct",contains:[{member:"x",type:{kind:"uint",bits:256}},{member:"y",type:{kind:"uint",bits:256}}]},{kind:"mapping",contains:{key:{type:{kind:"address",payable:!0}},value:{type:{kind:"uint",bits:256}}}}]},TypeReference:{title:'{ "id": ... }',description:"A reference to a known type by ID",type:"object",properties:{id:{type:["string","number"]}},additionalProperties:!1,required:["id"]},TypeWrapper:{title:'{ "type": ... }',description:'A wrapper around a type. Defines a `"type"` field that may include a full Type representation or a reference to a known Type by ID. Note that this schema permits additional properties on the same object.',type:"object",properties:{type:{oneOf:[{$ref:"schema:ethdebug/format/type/base"},{$ref:"#/$defs/TypeReference"}]}},required:["type"]},TypeWrapperArray:{title:'{ "type": ... }[]',description:"A list of wrapped types, where the wrapper may add fields",type:"array",items:{$ref:"#/$defs/TypeWrapper"}},TypeWrapperObject:{title:'{ "key": { "type": ... }, ... }',description:"A key-value mapping of wrapped types, where the wrapper may add fields",type:"object",additionalProperties:{$ref:"#/$defs/TypeWrapper"}}}}].map((e=>({[e.$id]:e}))).reduce(((e,t)=>({...e,...t})),{}),i=e=>s[e]}}]);